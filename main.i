# 1 "src/main.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 395 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "src/main.cpp" 2








# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iostream" 1 3
# 37 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iostream" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__config" 1 3
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__config" 3
# 443 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__config" 3
namespace std {
  inline namespace __1 {
  }
}
# 38 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iostream" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ios" 1 3
# 215 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ios" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iosfwd" 1 3
# 90 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iosfwd" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/wchar.h" 1 3
# 113 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/wchar.h" 3






# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 1 3 4
# 70 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types.h" 1 3 4
# 27 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/cdefs.h" 1 3 4
# 587 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 588 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/cdefs.h" 2 3 4
# 653 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_posix_availability.h" 1 3 4
# 654 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/cdefs.h" 2 3 4
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/_types.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/_types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/_types.h" 1 3 4
# 37 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;







typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types.h" 2 3 4
# 55 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 57 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types.h" 2 3 4
# 28 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types.h" 2 3 4
# 40 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 71 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/Availability.h" 1 3 4
# 206 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/Availability.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/AvailabilityInternal.h" 1 3 4
# 207 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/Availability.h" 2 3 4
# 73 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 75 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_size_t.h" 3 4
typedef __darwin_size_t size_t;
# 76 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_mbstate_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_mbstate_t.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/types.h" 1 3 4
# 35 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 1 3 4
# 76 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_int8_t.h" 3 4
typedef signed char int8_t;
# 77 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_int16_t.h" 3 4
typedef short int16_t;
# 78 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_int32_t.h" 3 4
typedef int int32_t;
# 79 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_int64_t.h" 3 4
typedef long long int64_t;
# 80 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_int8_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_int8_t.h" 3 4
typedef unsigned char u_int8_t;
# 82 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_int16_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_int16_t.h" 3 4
typedef unsigned short u_int16_t;
# 83 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_int32_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_int32_t.h" 3 4
typedef unsigned int u_int32_t;
# 84 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_int64_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_int64_t.h" 3 4
typedef unsigned long long u_int64_t;
# 85 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 2 3 4


typedef int64_t register_t;





# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_intptr_t.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/types.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_intptr_t.h" 2 3 4

typedef __darwin_intptr_t intptr_t;
# 93 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_uintptr_t.h" 3 4
typedef unsigned long uintptr_t;
# 94 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/types.h" 2 3 4



typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;







typedef u_int64_t syscall_arg_t;
# 36 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/types.h" 2 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_mbstate_t.h" 2 3 4
typedef __darwin_mbstate_t mbstate_t;
# 77 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_ct_rune_t.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;
# 78 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_rune_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_rune_t.h" 3 4
typedef __darwin_rune_t rune_t;
# 79 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 80 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4
# 89 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdarg.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 90 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdio.h" 1 3 4
# 106 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdio.h" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 1 3 4
# 64 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_stdio.h" 1 3 4
# 75 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_stdio.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_va_list.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_va_list.h" 3 4
typedef __darwin_va_list va_list;
# 76 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_stdio.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/stdio.h" 1 3 4
# 37 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/stdio.h" 3 4
extern "C" {

int renameat(int, const char *, int, const char *) __attribute__((availability(macosx,introduced=10.10)));






int renamex_np(const char *, const char *, unsigned int) __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)));
int renameatx_np(int, const char *, int, const char *, unsigned int) __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)));



}
# 80 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;
# 92 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 126 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (* _Nullable _close)(void *);
 int (* _Nullable _read) (void *, char *, int);
 fpos_t (* _Nullable _seek) (void *, fpos_t, int);
 int (* _Nullable _write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;
# 65 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 2 3 4

extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
# 141 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 3 4
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);



FILE *fopen(const char * __filename, const char * __mode) __asm("_" "fopen" );

int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" );
size_t fread(void * __ptr, size_t __size, size_t __nitems, FILE * __stream);
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen" );
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * __ptr, size_t __size, size_t __nitems, FILE * __stream) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *__old, const char *__new);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((__availability__(swift, unavailable, message="Use snprintf instead.")));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);

__attribute__((__availability__(swift, unavailable, message="Use mkstemp(3) instead.")))

__attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((__availability__(swift, unavailable, message="Use vsnprintf instead.")));
}
# 204 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 3 4
extern "C" {



char *ctermid(char *);





FILE *fdopen(int, const char *) __asm("_" "fdopen" );

int fileno(FILE *);
}
# 231 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 3 4
extern "C" {
int pclose(FILE *) __attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead.")));



FILE *popen(const char *, const char *) __asm("_" "popen" ) __attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead.")));

}
# 252 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 3 4
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}







inline __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 289 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 3 4
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);


__attribute__((__availability__(swift, unavailable, message="Use mkstemp(3) instead.")))

__attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tempnam(const char *__dir, const char *__prefix) __asm("_" "tempnam" );
}
# 328 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_off_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_off_t.h" 3 4
typedef __darwin_off_t off_t;
# 329 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 2 3 4

extern "C" {
int fseeko(FILE * __stream, off_t __offset, int __whence);
off_t ftello(FILE * __stream);
}



extern "C" {
int snprintf(char * __str, size_t __size, const char * __format, ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * __stream, const char * __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * __format, va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * __str, size_t __size, const char * __format, va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * __str, const char * __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}
# 353 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_ssize_t.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 354 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdio.h" 2 3 4

extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getdelim(char ** __linep, size_t * __linecapp, int __delimiter, FILE * __stream) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getline(char ** __linep, size_t * __linecapp, FILE * __stream) __attribute__((availability(macosx,introduced=10.7)));
FILE *fmemopen(void * __buf, size_t __size, const char * __mode) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
FILE *open_memstream(char **__bufp, size_t *__sizep) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
}







extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char ** , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char ** , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);





FILE *funopen(const void *,
                 int (* _Nullable)(void *, char *, int),
                 int (* _Nullable)(void *, const char *, int),
                 fpos_t (* _Nullable)(void *, fpos_t, int),
                 int (* _Nullable)(void *));
}
# 109 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdio.h" 2 3
# 91 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/time.h" 1 3 4
# 68 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/time.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_clock_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_clock_t.h" 3 4
typedef __darwin_clock_t clock_t;
# 69 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/time.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_time_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_time_t.h" 3 4
typedef __darwin_time_t time_t;
# 72 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/time.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_timespec.h" 1 3 4
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_timespec.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 73 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/time.h" 2 3 4

struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 97 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" );
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) __asm("_" "nanosleep" );
# 152 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/time.h" 3 4
typedef enum {
_CLOCK_REALTIME __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 0,

_CLOCK_MONOTONIC __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 6,


_CLOCK_MONOTONIC_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 4,

_CLOCK_MONOTONIC_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 5,

_CLOCK_UPTIME_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 8,

_CLOCK_UPTIME_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 9,


_CLOCK_PROCESS_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 12,

_CLOCK_THREAD_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 16

} clockid_t;

__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_getres(clockid_t __clock_id, struct timespec *__res);

__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_gettime(clockid_t __clock_id, struct timespec *__tp);


__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
__uint64_t clock_gettime_nsec_np(clockid_t __clock_id);


__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,unavailable)))
__attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable)))
int clock_settime(clockid_t __clock_id, const struct timespec *__tp);





}
# 92 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_wctype.h" 1 3 4
# 42 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_wctype.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/__wctype.h" 1 3 4
# 60 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/__wctype.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_wint_t.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_wint_t.h" 3 4
typedef __darwin_wint_t wint_t;
# 61 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/__wctype.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_wctype_t.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_wctype_t.h" 3 4
typedef __darwin_wctype_t wctype_t;
# 63 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/__wctype.h" 2 3 4
# 72 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/__wctype.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ctype.h" 1 3 4
# 37 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ctype.h" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/ctype.h" 1 3 4
# 69 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/ctype.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_ctype.h" 1 3 4
# 70 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_ctype.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/runetype.h" 1 3 4
# 49 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/runetype.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 50 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/runetype.h" 2 3 4
# 60 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/runetype.h" 3 4
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;



extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 71 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_ctype.h" 2 3 4
# 128 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_ctype.h" 3 4
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 147 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_ctype.h" 3 4
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}


inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 187 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_ctype.h" 3 4
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}


inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

inline int
tolower(int _c)
{
        return (__tolower(_c));
}

inline int
toupper(int _c)
{
        return (__toupper(_c));
}


inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 70 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/ctype.h" 2 3 4
# 40 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ctype.h" 2 3
# 73 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/__wctype.h" 2 3 4
# 43 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_wctype.h" 2 3 4







inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 155 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_wctype.h" 3 4
extern "C" {
wctype_t
 wctype(const char *);
}
# 93 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 2 3 4



extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...);
int fwscanf(FILE * , const wchar_t * , ...);
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * , ...);
int swscanf(const wchar_t * , const wchar_t * , ...);
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list);
int vwprintf(const wchar_t * , __darwin_va_list);
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" );
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...);
int wscanf(const wchar_t * , ...);
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
# 169 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 3 4
extern "C" {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list);
int vwscanf(const wchar_t * , __darwin_va_list);
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** );

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

}
# 194 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcsdup(const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
FILE *open_wmemstream(wchar_t ** __bufp, size_t * __sizep) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
}







extern "C" {
wchar_t *fgetwln(FILE * , size_t *) __attribute__((availability(macosx,introduced=10.7)));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
# 120 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/wchar.h" 2 3
# 131 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/wchar.h" 3
extern "C++" {
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
wchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcschr( wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
wchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcspbrk( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
wchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcsrchr( wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
wchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcsstr( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
wchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return (wchar_t*)wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
}
# 91 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iosfwd" 2 3
# 94 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iosfwd" 3


namespace std {inline namespace __1 {

class __attribute__ ((__visibility__("default"))) ios_base;

template<class _CharT> struct __attribute__ ((__type_visibility__("default"))) char_traits;
template<class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _State> class __attribute__ ((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;

typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;






typedef long long streamoff;


template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;



template <class _Tp, class _Alloc = allocator<_Tp> >
class __attribute__ ((__type_visibility__("default"))) vector;

} }
# 216 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ios" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 1 3
# 15 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 1 3
# 470 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string_view" 1 3
# 169 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string_view" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__string" 1 3
# 56 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__string" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 1 3
# 639 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/initializer_list" 1 3
# 47 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/initializer_list" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstddef" 1 3
# 41 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstddef" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stddef.h" 1 3 4
# 51 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 118 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stddef.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/__stddef_max_align_t.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/__stddef_max_align_t.h" 3 4
typedef long double max_align_t;
# 119 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stddef.h" 2 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstddef" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__nullptr" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__nullptr" 3
# 55 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__nullptr" 3
namespace std
{
    typedef decltype(nullptr) nullptr_t;
}
# 46 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstddef" 2 3

namespace std {inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;




using ::max_align_t;




} }


namespace std
{
enum class byte : unsigned char {};

constexpr byte& operator|=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = byte(static_cast<unsigned char>(__lhs) | static_cast<unsigned char>(__rhs)); }
constexpr byte operator| (byte __lhs, byte __rhs) noexcept
{ return byte(static_cast<unsigned char>(__lhs) | static_cast<unsigned char>(__rhs)); }

constexpr byte& operator&=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = byte(static_cast<unsigned char>(__lhs) & static_cast<unsigned char>(__rhs)); }
constexpr byte operator& (byte __lhs, byte __rhs) noexcept
{ return byte(static_cast<unsigned char>(__lhs) & static_cast<unsigned char>(__rhs)); }

constexpr byte& operator^=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = byte(static_cast<unsigned char>(__lhs) ^ static_cast<unsigned char>(__rhs)); }
constexpr byte operator^ (byte __lhs, byte __rhs) noexcept
{ return byte(static_cast<unsigned char>(__lhs) ^ static_cast<unsigned char>(__rhs)); }

constexpr byte operator~ (byte __b) noexcept
{ return byte(~static_cast<unsigned char>(__b)); }

}


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 1 3
# 390 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstddef" 1 3
# 391 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 2 3
# 394 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3


namespace std {inline namespace __1 {

template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) pair;
template <class _Tp> class __attribute__ ((__type_visibility__("default"))) reference_wrapper;
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;

template <class>
struct __void_t { typedef void type; };

template <class _Tp>
struct __identity { typedef _Tp type; };

template <class _Tp, bool>
struct __attribute__ ((__type_visibility__("default"))) __dependent_type : public _Tp {};

template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};


template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;


template <bool, class _Tp> struct __attribute__ ((__type_visibility__("default"))) __lazy_enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};

template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};


template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;





template <class _Tp>
inline constexpr
__attribute__((__no_sanitize__("cfi"))) __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
addressof(_Tp& __x) noexcept
{
    return __builtin_addressof(__x);
}
# 496 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;


struct __two {char __lx[2];};



template <class _Tp, _Tp __v>
struct __attribute__ ((__type_visibility__("default"))) integral_constant
{
    static constexpr const _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        constexpr operator value_type() const noexcept {return value;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
         constexpr value_type operator ()() const noexcept {return value;}

};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;


template <bool __b>
using bool_constant = integral_constant<bool, __b>;





typedef bool_constant<(true)> true_type;
typedef bool_constant<(false)> false_type;





template <bool _Last, class ..._Preds>
struct __lazy_and_impl;

template <class ..._Preds>
struct __lazy_and_impl<false, _Preds...> : false_type {};

template <>
struct __lazy_and_impl<true> : true_type {};

template <class _Pred>
struct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};

template <class _Hp, class ..._Tp>
struct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};

template <class _P1, class ..._Pr>
struct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};



template <bool _List, class ..._Preds>
struct __lazy_or_impl;

template <class ..._Preds>
struct __lazy_or_impl<true, _Preds...> : true_type {};

template <>
struct __lazy_or_impl<false> : false_type {};

template <class _Hp, class ..._Tp>
struct __lazy_or_impl<false, _Hp, _Tp...>
        : __lazy_or_impl<_Hp::type::value, _Tp...> {};

template <class _P1, class ..._Pr>
struct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};



template <class _Pred>
struct __lazy_not : integral_constant<bool, !_Pred::type::value> {};


template<class...> struct __and_;
template<> struct __and_<> : true_type {};

template<class _B0> struct __and_<_B0> : _B0 {};

template<class _B0, class _B1>
struct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};

template<class _B0, class _B1, class _B2, class... _Bn>
struct __and_<_B0, _B1, _B2, _Bn...>
        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};


template<class...> struct __or_;
template<> struct __or_<> : false_type {};

template<class _B0> struct __or_<_B0> : _B0 {};

template<class _B0, class _B1>
struct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};

template<class _B0, class _B1, class _B2, class... _Bn>
struct __or_<_B0, _B1, _B2, _Bn...>
        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};


template<class _Tp>
struct __not_ : conditional<_Tp::value, false_type, true_type>::type {};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const<_Tp const> : public true_type {};


template <class _Tp> constexpr bool is_const_v
    = is_const<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};


template <class _Tp> constexpr bool is_volatile_v
    = is_volatile<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};

template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};

template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};

template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;




template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};


template <class _Tp> constexpr bool is_void_v
    = is_void<_Tp>::value;




template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};


template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_null_pointer
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};


template <class _Tp> constexpr bool is_null_pointer_v
    = is_null_pointer<_Tp>::value;





template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};

template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long long> : public true_type {};

template <> struct __libcpp_is_integral<__int128_t> : public true_type {};
template <> struct __libcpp_is_integral<__uint128_t> : public true_type {};


template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};


template <class _Tp> constexpr bool is_integral_v
    = is_integral<_Tp>::value;




template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};


template <class _Tp> constexpr bool is_floating_point_v
    = is_floating_point<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array
    : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[_Np]>
    : public true_type {};


template <class _Tp> constexpr bool is_array_v
    = is_array<_Tp>::value;




template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};


template <class _Tp> constexpr bool is_pointer_v
    = is_pointer<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference<_Tp&&> : public true_type {};


template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference<_Tp&&> : public true_type {};



template <class _Tp> constexpr bool is_reference_v
    = is_reference<_Tp>::value;

template <class _Tp> constexpr bool is_lvalue_reference_v
    = is_lvalue_reference<_Tp>::value;

template <class _Tp> constexpr bool is_rvalue_reference_v
    = is_rvalue_reference<_Tp>::value;





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 800 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp> constexpr bool is_union_v
    = is_union<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 825 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp> constexpr bool is_class_v
    = is_class<_Tp>::value;




template <class _Tp, class _Up> struct __attribute__ ((__type_visibility__("default"))) is_same : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};


template <class _Tp, class _Up> constexpr bool is_same_v
    = is_same<_Tp, _Up>::value;




namespace __libcpp_is_function_imp
{
struct __dummy_type {};
template <class _Tp> char __test(_Tp*);
template <class _Tp> char __test(__dummy_type);
template <class _Tp> __two __test(...);
template <class _Tp> _Tp& __source(int);
template <class _Tp> __dummy_type __source(...);
}

template <class _Tp, bool = is_class<_Tp>::value ||
                            is_union<_Tp>::value ||
                            is_void<_Tp>::value ||
                            is_reference<_Tp>::value ||
                            __is_nullptr_t<_Tp>::value >
struct __libcpp_is_function
    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>
    {};
template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function
    : public __libcpp_is_function<_Tp> {};


template <class _Tp> constexpr bool is_function_v
    = is_function<_Tp>::value;
# 875 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};


template <class _Tp> struct __libcpp_is_member_function_pointer
    : public false_type {};

template <class _Ret, class _Class>
struct __libcpp_is_member_function_pointer<_Ret _Class::*>
    : public is_function<_Ret> {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer
    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};


template <class _Tp> constexpr bool is_member_function_pointer_v
    = is_member_function_pointer<_Tp>::value;




template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_pointer
    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};


template <class _Tp> constexpr bool is_member_pointer_v
    = is_member_pointer<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer
    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
                                    !is_member_function_pointer<_Tp>::value> {};


template <class _Tp> constexpr bool is_member_object_pointer_v
    = is_member_object_pointer<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 944 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp> constexpr bool is_enum_v
    = is_enum<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};


template <class _Tp> constexpr bool is_arithmetic_v
    = is_arithmetic<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};


template <class _Tp> constexpr bool is_fundamental_v
    = is_fundamental<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_scalar
    : public integral_constant<bool, is_arithmetic<_Tp>::value ||
                                     is_member_pointer<_Tp>::value ||
                                     is_pointer<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_enum<_Tp>::value > {};

template <> struct __attribute__ ((__type_visibility__("default"))) is_scalar<nullptr_t> : public true_type {};


template <class _Tp> constexpr bool is_scalar_v
    = is_scalar<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_object
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_array<_Tp>::value ||
                                     is_union<_Tp>::value ||
                                     is_class<_Tp>::value > {};


template <class _Tp> constexpr bool is_object_v
    = is_object<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};


template <class _Tp> constexpr bool is_compound_v
    = is_compound<_Tp>::value;





struct __is_referenceable_impl {
    template <class _Tp> static _Tp& __test(int);
    template <class _Tp> static __two __test(...);
};

template <class _Tp>
struct __is_referenceable : integral_constant<bool,
    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};




template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_const<_Tp>::value >
struct __add_const {typedef _Tp type;};

template <class _Tp>
struct __add_const<_Tp, false> {typedef const _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_const
    {typedef typename __add_const<_Tp>::type type;};


template <class _Tp> using add_const_t = typename add_const<_Tp>::type;




template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_volatile<_Tp>::value >
struct __add_volatile {typedef _Tp type;};

template <class _Tp>
struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_volatile
    {typedef typename __add_volatile<_Tp>::type type;};


template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_cv
    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};


template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&&> {typedef _Tp type;};



template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;




template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference
{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};


template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;




template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_rvalue_reference
{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};


template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;






template <class _Tp> _Tp&& __declval(int);
template <class _Tp> _Tp __declval(long);

template <class _Tp>
decltype(std::__1::__declval<_Tp>(0))
declval() noexcept;
# 1123 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp>
struct __uncvref {
    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
};

template <class _Tp>
struct __unconstref {
    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
};


template <class _Tp>
using __uncvref_t = typename __uncvref<_Tp>::type;




template <class _Tp, class _Up>
struct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,
                                   typename __uncvref<_Up>::type> {};

struct __any
{
    __any(...);
};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef _Tp type;};


template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;




template <class _Tp,
        bool = __is_referenceable<_Tp>::value ||
                is_same<typename remove_cv<_Tp>::type, void>::value>
struct __add_pointer_impl
    {typedef typename remove_reference<_Tp>::type* type;};
template <class _Tp> struct __add_pointer_impl<_Tp, false>
    {typedef _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer
    {typedef typename __add_pointer_impl<_Tp>::type type;};


template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;




template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public bool_constant<(_Tp(-1) < _Tp(0))> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};


template <class _Tp> constexpr bool is_signed_v
    = is_signed<_Tp>::value;




template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public bool_constant<(_Tp(0) < _Tp(-1))> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};


template <class _Tp> constexpr bool is_unsigned_v
    = is_unsigned<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};


template <class _Tp> constexpr size_t rank_v
    = rank<_Tp>::value;




template <class _Tp, unsigned _Ip = 0> struct __attribute__ ((__type_visibility__("default"))) extent
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};


template <class _Tp, unsigned _Ip = 0> constexpr size_t extent_v
    = extent<_Tp, _Ip>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};


template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};


template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




template <class _Up, bool>
struct __decay {
    typedef typename remove_cv<_Up>::type type;
};

template <class _Up>
struct __decay<_Up, true> {
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
};


template <class _Tp> using decay_t = typename decay<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)> {};


template <class _Tp> constexpr bool is_abstract_v
    = is_abstract<_Tp>::value;





template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};






template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
is_final : public integral_constant<bool, __is_final(_Tp)> {};



template <class _Tp> constexpr bool is_final_v
    = is_final<_Tp>::value;





template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
is_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};


template <class _Tp>
constexpr bool is_aggregate_v = is_aggregate<_Tp>::value;
# 1359 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Bp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 1391 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Bp, class _Dp> constexpr bool is_base_of_v
    = is_base_of<_Bp, _Dp>::value;






template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
                                     !is_abstract<_T2>::value> {};
# 1481 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _From, class _To> constexpr bool is_convertible_v
    = is_convertible<_From, _To>::value;






template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 1517 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp> constexpr bool is_empty_v
    = is_empty<_Tp>::value;






template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 1542 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp> constexpr bool is_polymorphic_v
    = is_polymorphic<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 1561 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp> constexpr bool has_virtual_destructor_v
    = has_virtual_destructor<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, __alignof__(_Tp)> {};


template <class _Tp> constexpr size_t alignment_of_v
    = alignment_of<_Tp>::value;




template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{

    __nat() = delete;
    __nat(const __nat&) = delete;
    __nat& operator=(const __nat&) = delete;
    ~__nat() = delete;

};

template <class _Tp>
struct __align_type
{
    static const size_t value = alignment_of<_Tp>::value;
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             void
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    static_assert(!is_void<_Aligner>::value, "");
    union type
    {
        _Aligner __align;
        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
    };
};


template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
# 1686 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};


template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};
# 1711 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <size_t _I0, size_t ..._In>
struct __static_max;

template <size_t _I0>
struct __static_max<_I0>
{
    static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t ..._In>
struct __static_max<_I0, _I1, _In...>
{
    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
                                             __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class ..._Types>
struct aligned_union
{
    static const size_t alignment_value = __static_max<__alignof__(_Type0),
                                                       __alignof__(_Types)...>::value;
    static const size_t __len = __static_max<_Len, sizeof(_Type0),
                                             sizeof(_Types)...>::value;
    typedef typename aligned_storage<__len, alignment_value>::type type;
};


template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;




template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef decltype(__test(declval<_Tp>())) type;
   static const bool value = !is_same<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote_imp
{
public:
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
    typedef typename __promote_imp<_A3>::type __type3;
public:
    typedef decltype(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
public:
    typedef decltype(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote_imp<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};



typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,

    __type_list<__int128_t,

    __nat

    >

    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,

    __type_list<__uint128_t,

    __nat

    >

    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};

template <> struct __make_signed<__int128_t, true> {typedef __int128_t type;};
template <> struct __make_signed<__uint128_t, true> {typedef __int128_t type;};


template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;


template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};

template <> struct __make_unsigned<__int128_t, true> {typedef __uint128_t type;};
template <> struct __make_unsigned<__uint128_t, true> {typedef __uint128_t type;};


template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
# 2010 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp>
    : public common_type<_Tp, _Tp> {};



template <class _Tp, class _Up, class = void>
struct __common_type2_imp {};

template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up,
    typename __void_t<decltype(
        true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>()
    )>::type>
{
    typedef typename decay<decltype(
        true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>()
    )>::type type;
};

template <class _Tp, class _Up,
          class _DTp = typename decay<_Tp>::type,
          class _DUp = typename decay<_Up>::type>
using __common_type2 =
  typename conditional<
    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,
    __common_type2_imp<_Tp, _Up>,
    common_type<_DTp, _DUp>
  >::type;

template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up>
    : __common_type2<_Tp, _Up> {};



template <class ...Tp> struct __common_types;

template <class, class = void>
struct __common_type_impl {};

template <class _Tp, class _Up>
struct __common_type_impl<
    __common_types<_Tp, _Up>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
{
  typedef typename common_type<_Tp, _Up>::type type;
};

template <class _Tp, class _Up, class ..._Vp>
struct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
  : __common_type_impl<
      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >
{

};

template <class _Tp, class _Up, class ..._Vp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up, _Vp...>
    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};


template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;






template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<decltype((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type
__is_assignable_test(int);

template <class, class>
false_type __is_assignable_test(...);


template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public decltype((std::__1::__is_assignable_test<_Tp, _Arg>(0))) {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct is_assignable
    : public __is_assignable_imp<_Tp, _Arg> {};


template <class _Tp, class _Arg> constexpr bool is_assignable_v
    = is_assignable<_Tp, _Arg>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp> constexpr bool is_copy_assignable_v
    = is_copy_assignable<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_move_assignable

    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                           typename add_rvalue_reference<_Tp>::type> {};





template <class _Tp> constexpr bool is_move_assignable_v
    = is_move_assignable<_Tp>::value;
# 2149 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class>
struct __is_destructible_apply { typedef int type; };

template <typename _Tp>
struct __is_destructor_wellformed {
    template <typename _Tp1>
    static char __test (
        typename __is_destructible_apply<decltype(std::__1::declval<_Tp1&>().~_Tp1())>::type
    );

    template <typename _Tp1>
    static __two __test (...);

    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};

template <class _Tp, bool>
struct __destructible_imp;

template <class _Tp>
struct __destructible_imp<_Tp, false>
   : public std::__1::integral_constant<bool,
        __is_destructor_wellformed<typename std::__1::remove_all_extents<_Tp>::type>::value> {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public std::__1::true_type {};

template <class _Tp, bool>
struct __destructible_false;

template <class _Tp>
struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__1::is_reference<_Tp>::value> {};

template <class _Tp>
struct __destructible_false<_Tp, true> : public std::__1::false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, std::__1::is_function<_Tp>::value> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public std::__1::false_type {};

template <>
struct is_destructible<void>
    : public std::__1::false_type {};


template <class _Tp> constexpr bool is_destructible_v
    = is_destructible<_Tp>::value;






template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename remove_reference<_Tp>::type&&
move(_Tp&& __t) noexcept
{
    typedef typename remove_reference<_Tp>::type _Up;
    return static_cast<_Up&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type& __t) noexcept
{
    return static_cast<_Tp&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type&& __t) noexcept
{
    static_assert(!is_lvalue_reference<_Tp>::value,
                  "can not forward an rvalue as an lvalue");
    return static_cast<_Tp&&>(__t);
}
# 2277 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename decay<_Tp>::type
__decay_copy(_Tp&& __t)
{
    return std::__1::forward<_Tp>(__t);
}
# 2299 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};




template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
# 2756 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{



};


template <class _DecayedFp>
struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};



template <class _Callable> class result_of;
# 2937 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
namespace __is_construct
{
struct __nat {};
}
# 3059 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
    {};
# 3244 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp, class ..._Args> constexpr bool is_constructible_v
    = is_constructible<_Tp, _Args...>::value;




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};


template <class _Tp> constexpr bool is_default_constructible_v
    = is_default_constructible<_Tp>::value;




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp> constexpr bool is_copy_constructible_v
    = is_copy_constructible<_Tp>::value;




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_move_constructible

    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};


template <class _Tp> constexpr bool is_move_constructible_v
    = is_move_constructible<_Tp>::value;
# 3294 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
{
};
# 3416 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp, class... _Args> constexpr bool is_trivially_constructible_v
    = is_trivially_constructible<_Tp, _Args...>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};


template <class _Tp> constexpr bool is_trivially_default_constructible_v
    = is_trivially_default_constructible<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};


template <class _Tp> constexpr bool is_trivially_copy_constructible_v
    = is_trivially_copy_constructible<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_constructible

    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};


template <class _Tp> constexpr bool is_trivially_move_constructible_v
    = is_trivially_move_constructible<_Tp>::value;






template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 3496 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp, class _Arg> constexpr bool is_trivially_assignable_v
    = is_trivially_assignable<_Tp, _Arg>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp> constexpr bool is_trivially_copy_assignable_v
    = is_trivially_copy_assignable<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,

                                     typename add_rvalue_reference<_Tp>::type>



    {};


template <class _Tp> constexpr bool is_trivially_move_assignable_v
    = is_trivially_move_assignable<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};
# 3549 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp> constexpr bool is_trivially_destructible_v
    = is_trivially_destructible<_Tp>::value;
# 3568 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;

template <class _Tp, class... _Args>
struct __libcpp_is_nothrow_constructible< true, false, _Tp, _Args...>
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
{
};

template <class _Tp>
void __implicit_conversion_to(_Tp) noexcept { }

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_constructible< true, true, _Tp, _Arg>
    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>
{
};

template <class _Tp, bool _IsReference, class... _Args>
struct __libcpp_is_nothrow_constructible< false, _IsReference, _Tp, _Args...>
    : public false_type
{
};

template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>
{
};

template <class _Tp, size_t _Ns>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp[_Ns]>
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>
{
};
# 3714 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp, class ..._Args> constexpr bool is_nothrow_constructible_v
    = is_nothrow_constructible<_Tp, _Args...>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};


template <class _Tp> constexpr bool is_nothrow_default_constructible_v
    = is_nothrow_default_constructible<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp> constexpr bool is_nothrow_copy_constructible_v
    = is_nothrow_copy_constructible<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_constructible

    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};


template <class _Tp> constexpr bool is_nothrow_move_constructible_v
    = is_nothrow_move_constructible<_Tp>::value;






template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
    : public integral_constant<bool, noexcept(std::__1::declval<_Tp>() = std::__1::declval<_Arg>()) >
{
};

template <class _Tp, class _Arg>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable
    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
{
};
# 3824 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp, class _Arg> constexpr bool is_nothrow_assignable_v
    = is_nothrow_assignable<_Tp, _Arg>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp> constexpr bool is_nothrow_copy_assignable_v
    = is_nothrow_copy_assignable<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,

                                     typename add_rvalue_reference<_Tp>::type>



    {};


template <class _Tp> constexpr bool is_nothrow_move_assignable_v
    = is_nothrow_move_assignable<_Tp>::value;






template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp>
    : public false_type
{
};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::__1::declval<_Tp>().~_Tp()) >
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
{
};

template <class _Tp, size_t _Ns>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp[_Ns]>
    : public is_nothrow_destructible<_Tp>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&>
    : public true_type
{
};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&&>
    : public true_type
{
};
# 3917 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp> constexpr bool is_nothrow_destructible_v
    = is_nothrow_destructible<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 3939 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp> constexpr bool is_pod_v
    = is_pod<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_literal_type

    : public integral_constant<bool, __is_literal(_Tp)>




    {};


template <class _Tp> constexpr bool is_literal_type_v
    = is_literal_type<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};


template <class _Tp> constexpr bool is_standard_layout_v
    = is_standard_layout<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>





    {};


template <class _Tp> constexpr bool is_trivially_copyable_v
    = is_trivially_copyable<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};


template <class _Tp> constexpr bool is_trivial_v
    = is_trivial<_Tp>::value;


template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};





template <class ..._Tp> struct __check_complete;

template <>
struct __check_complete<>
{
};

template <class _Hp, class _T0, class ..._Tp>
struct __check_complete<_Hp, _T0, _Tp...>
    : private __check_complete<_Hp>,
      private __check_complete<_T0, _Tp...>
{
};

template <class _Hp>
struct __check_complete<_Hp, _Hp>
    : private __check_complete<_Hp>
{
};

template <class _Tp>
struct __check_complete<_Tp>
{
    static_assert(sizeof(_Tp) > 0, "Type must be complete.");
};

template <class _Tp>
struct __check_complete<_Tp&>
    : private __check_complete<_Tp>
{
};

template <class _Tp>
struct __check_complete<_Tp&&>
    : private __check_complete<_Tp>
{
};

template <class _Rp, class ..._Param>
struct __check_complete<_Rp (*)(_Param...)>
    : private __check_complete<_Rp>
{
};

template <class ..._Param>
struct __check_complete<void (*)(_Param...)>
{
};

template <class _Rp, class ..._Param>
struct __check_complete<_Rp (_Param...)>
    : private __check_complete<_Rp>
{
};

template <class ..._Param>
struct __check_complete<void (_Param...)>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...)>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) &>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) &&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const&&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class>
struct __check_complete<_Rp _Class::*>
    : private __check_complete<_Class>
{
};


template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet2 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet5 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;
# 4223 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class ..._Args>
auto __invoke(__any, _Args&& ...__args) -> __nat;

template <class ..._Args>
auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;



template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)) { return (std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)) { return (std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)) { return ((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)) { return ((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...); }



template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f)) -> decltype(std::__1::forward<_A0>(__a0).*__f) { return std::__1::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f)) -> decltype(std::__1::forward<_A0>(__a0).*__f) { return std::__1::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__1::forward<_A0>(__a0)).*__f) { return (*std::__1::forward<_A0>(__a0)).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__1::forward<_A0>(__a0)).*__f) { return (*std::__1::forward<_A0>(__a0)).*__f; }



template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) { return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) { return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...); }





template <class _Ret, class _Fp, class ..._Args>
struct __invokable_r
    : private __check_complete<_Fp>
{
    using _Result = decltype(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));

    static const bool value =
        conditional<
            !is_same<_Result, __nat>::value,
            typename conditional<
                is_void<_Ret>::value,
                true_type,
                is_convertible<_Result, _Ret>
            >::type,
            false_type
        >::type::value;
};

template <class _Fp, class ..._Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
{
    typedef __nothrow_invokable_r_imp _ThisT;

    template <class _Tp>
    static void __test_noexcept(_Tp) noexcept;

    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...)));
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
{
    static const bool value = noexcept(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));
};

template <class _Ret, class _Fp, class ..._Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<
            __invokable_r<_Ret, _Fp, _Args...>::value,
            is_void<_Ret>::value,
            _Ret, _Fp, _Args...
    >;

template <class _Fp, class ..._Args>
struct __invoke_of
    : public enable_if<
        __invokable<_Fp, _Args...>::value,
        typename __invokable_r<void, _Fp, _Args...>::_Result>
{
};



template <class _Fp, class ..._Args>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fp(_Args...)>
    : public __invoke_of<_Fp, _Args...>
{
};


template <class _Tp> using result_of_t = typename result_of<_Tp>::type;






template <class _Fn, class _Ret = void>
struct __attribute__ ((__type_visibility__("default"))) is_callable;

template <class _Fn, class ..._Args, class _Ret>
struct __attribute__ ((__type_visibility__("default"))) is_callable<_Fn(_Args...), _Ret>
    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};

template <class _Fn, class _Ret = void>
constexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;



template <class _Fn, class _Ret = void>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_callable;

template <class _Fn, class ..._Args, class _Ret>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_callable<_Fn(_Args...), _Ret>
    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>
{};

template <class _Fn, class _Ret = void>
constexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;





template <class _Tp> struct __is_swappable;
template <class _Tp> struct __is_nothrow_swappable;

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    is_move_constructible<_Tp>::value &&
    is_move_assignable<_Tp>::value
>::type



swap(_Tp& __x, _Tp& __y) noexcept(is_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::value)

{
    _Tp __t(std::__1::move(__x));
    __x = std::__1::move(__y);
    __y = std::__1::move(__t);
}

template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value);

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)

               noexcept(noexcept(swap(*std::__1::declval<_ForwardIterator1>(), *std::__1::declval<_ForwardIterator2>())))

{
    swap(*__a, *__b);
}



namespace __detail
{


template <class _Tp, class _Up = _Tp,
          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with
{
    template <class _LHS, class _RHS>
    static decltype(swap(std::__1::declval<_LHS>(), std::__1::declval<_RHS>()))
    __test_swap(int);
    template <class, class>
    static __nat __test_swap(long);


    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

    static const bool value = !is_same<__swap1, __nat>::value
                           && !is_same<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(std::__1::declval<_Tp>(), std::__1::declval<_Up>()))
  && noexcept(swap(std::__1::declval<_Up>(), std::__1::declval<_Tp>()));



};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

}

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
{
};

template <class _Tp>
struct __is_nothrow_swappable
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
{
};



template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_swappable_with
    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_swappable
    : public conditional<
        __is_referenceable<_Tp>::value,
        is_swappable_with<
            typename add_lvalue_reference<_Tp>::type,
            typename add_lvalue_reference<_Tp>::type>,
        false_type
    >::type
{
};

template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_swappable_with
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_swappable
    : public conditional<
        __is_referenceable<_Tp>::value,
        is_nothrow_swappable_with<
            typename add_lvalue_reference<_Tp>::type,
            typename add_lvalue_reference<_Tp>::type>,
        false_type
    >::type
{
};

template <class _Tp, class _Up>
constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;

template <class _Tp>
constexpr bool is_swappable_v = is_swappable<_Tp>::value;

template <class _Tp, class _Up>
constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;

template <class _Tp>
constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;





template <class _Tp>
struct underlying_type
{
    typedef __underlying_type(_Tp) type;
};


template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
# 4612 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/type_traits" 3
template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type
{
    typedef typename underlying_type<_Tp>::type type;
    typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __convert_to_integral(int __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned __convert_to_integral(unsigned __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long __convert_to_integral(long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long __convert_to_integral(unsigned long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long long __convert_to_integral(long long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__int128_t __convert_to_integral(__int128_t __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) { return __val; }



template <class _Tp>
struct __has_operator_addressof_member_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(std::__1::declval<_Up>().operator&()), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof_free_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(operator&(std::__1::declval<_Up>())), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof
    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
                                  || __has_operator_addressof_free_imp<_Tp>::value>
{};






template <class...> using void_t = void;


template <class... _Args>
struct conjunction : __and_<_Args...> {};
template<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;

template <class... _Args>
struct disjunction : __or_<_Args...> {};
template<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;

template <class _Tp>
struct negation : __not_<_Tp> {};
template<class _Tp> constexpr bool negation_v = negation<_Tp>::value;





struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second>>
    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type {};




template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};



template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
    : false_type {};



} }



namespace std
{
template <class _Integer>
  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &
  operator<<=(byte& __lhs, _Integer __shift) noexcept
  { return __lhs = byte(static_cast<unsigned char>(__lhs) << __shift); }

template <class _Integer>
  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type
  operator<< (byte __lhs, _Integer __shift) noexcept
  { return byte(static_cast<unsigned char>(__lhs) << __shift); }

template <class _Integer>
  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &
  operator>>=(byte& __lhs, _Integer __shift) noexcept
  { return __lhs = byte(static_cast<unsigned char>(__lhs) >> __shift); }

template <class _Integer>
  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type
  operator>> (byte __lhs, _Integer __shift) noexcept
  { return byte(static_cast<unsigned char>(__lhs) >> __shift); }

template <class _Integer>
  constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type
  to_integer(byte __b) noexcept { return _Integer(__b); }

}
# 88 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstddef" 2 3
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/initializer_list" 2 3
# 51 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/initializer_list" 3


namespace std
{



template<class _Ep>
class __attribute__ ((__type_visibility__("default"))) initializer_list
{
    const _Ep* __begin_;
    size_t __size_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    initializer_list(const _Ep* __b, size_t __s) noexcept
        : __begin_(__b),
          __size_(__s)
        {}
public:
    typedef _Ep value_type;
    typedef const _Ep& reference;
    typedef const _Ep& const_reference;
    typedef size_t size_type;

    typedef const _Ep* iterator;
    typedef const _Ep* const_iterator;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    initializer_list() noexcept : __begin_(nullptr), __size_(0) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    size_t size() const noexcept {return __size_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    const _Ep* begin() const noexcept {return __begin_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    const _Ep* end() const noexcept {return __begin_ + __size_;}
};

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
const _Ep*
begin(initializer_list<_Ep> __il) noexcept
{
    return __il.begin();
}

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
const _Ep*
end(initializer_list<_Ep> __il) noexcept
{
    return __il.end();
}



}
# 640 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstring" 1 3
# 61 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstring" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string.h" 1 3
# 59 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string.h" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/string.h" 1 3 4
# 69 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/string.h" 3 4
extern "C" {
void *memchr(const void *__s, int __c, size_t __n);
int memcmp(const void *__s1, const void *__s2, size_t __n);
void *memcpy(void *__dst, const void *__src, size_t __n);
void *memmove(void *__dst, const void *__src, size_t __len);
void *memset(void *__b, int __c, size_t __len);
char *strcat(char *__s1, const char *__s2);
char *strchr(const char *__s, int __c);
int strcmp(const char *__s1, const char *__s2);
int strcoll(const char *__s1, const char *__s2);
char *strcpy(char *__dst, const char *__src);
size_t strcspn(const char *__s, const char *__charset);
char *strerror(int __errnum) __asm("_" "strerror" );
size_t strlen(const char *__s);
char *strncat(char *__s1, const char *__s2, size_t __n);
int strncmp(const char *__s1, const char *__s2, size_t __n);
char *strncpy(char *__dst, const char *__src, size_t __n);
char *strpbrk(const char *__s, const char *__charset);
char *strrchr(const char *__s, int __c);
size_t strspn(const char *__s, const char *__charset);
char *strstr(const char *__big, const char *__little);
char *strtok(char *__str, const char *__sep);
size_t strxfrm(char *__s1, const char *__s2, size_t __n);
}
# 103 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/string.h" 3 4
extern "C" {
char *strtok_r(char *__str, const char *__sep, char **__lasts);
}
# 115 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/string.h" 3 4
extern "C" {
int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
char *strdup(const char *__s1);
void *memccpy(void *__dst, const void *__src, int __c, size_t __n);
}
# 129 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/string.h" 3 4
extern "C" {
char *stpcpy(char *__dst, const char *__src);
char *stpncpy(char *__dst, const char *__src, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
char *strndup(const char *__s1, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
size_t strnlen(const char *__s1, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
char *strsignal(int __sig);
}
# 154 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/string.h" 3 4
extern "C" {
void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len) __attribute__((availability(macosx,introduced=10.7)));
void memset_pattern4(void *__b, const void *__pattern4, size_t __len) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern8(void *__b, const void *__pattern8, size_t __len) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern16(void *__b, const void *__pattern16, size_t __len) __attribute__((availability(macosx,introduced=10.5)));

char *strcasestr(const char *__big, const char *__little);
char *strnstr(const char *__big, const char *__little, size_t __len);
size_t strlcat(char *__dst, const char *__source, size_t __size);
size_t strlcpy(char *__dst, const char *__source, size_t __size);
void strmode(int __mode, char *__bp);
char *strsep(char **__stringp, const char *__delim);


void swab(const void * , void * , ssize_t);

__attribute__((availability(macosx,introduced=10.12.1))) __attribute__((availability(ios,introduced=10.1)))
__attribute__((availability(tvos,introduced=10.0.1))) __attribute__((availability(watchos,introduced=3.1)))
int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len);
}







# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/strings.h" 1 3 4
# 67 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/strings.h" 3 4
extern "C" {


int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}



extern "C" {
int ffsl(long) __attribute__((availability(macosx,introduced=10.5)));
int ffsll(long long) __attribute__((availability(macosx,introduced=10.9)));
int fls(int) __attribute__((availability(macosx,introduced=10.5)));
int flsl(long) __attribute__((availability(macosx,introduced=10.5)));
int flsll(long long) __attribute__((availability(macosx,introduced=10.9)));
}


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string.h" 1 3 4
# 93 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/strings.h" 2 3 4
# 181 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/string.h" 2 3 4
# 62 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string.h" 2 3
# 72 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string.h" 3
extern "C++" {
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char* __libcpp_strchr(const char* __s, int __c) {return (char*)strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strchr(const char* __s, int __c) {return __libcpp_strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strchr( char* __s, int __c) {return __libcpp_strchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char* __libcpp_strpbrk(const char* __s1, const char* __s2) {return (char*)strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strpbrk(const char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strpbrk( char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char* __libcpp_strrchr(const char* __s, int __c) {return (char*)strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strrchr(const char* __s, int __c) {return __libcpp_strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strrchr( char* __s, int __c) {return __libcpp_strrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void* __libcpp_memchr(const void* __s, int __c, size_t __n) {return (void*)memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
const void* memchr(const void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
      void* memchr( void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char* __libcpp_strstr(const char* __s1, const char* __s2) {return (char*)strstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strstr(const char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strstr( char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
}
# 62 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstring" 2 3
# 65 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstring" 3


namespace std {inline namespace __1 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;
using ::memchr;
using ::strchr;
using ::strcspn;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;

using ::strtok;

using ::memset;
using ::strerror;
using ::strlen;

} }
# 642 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility" 1 3
# 198 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__tuple" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__tuple" 3



namespace std {inline namespace __1 {

template <class _Tp> class __attribute__ ((__type_visibility__("default"))) tuple_size;


template <class _Tp, class...>
using __enable_if_tuple_size_imp = _Tp;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const _Tp,
    typename enable_if<!is_volatile<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    volatile _Tp,
    typename enable_if<!is_const<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const volatile _Tp,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};







template <size_t _Ip, class _Tp> class __attribute__ ((__type_visibility__("default"))) tuple_element;

template <size_t _Ip, class _Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const _Tp>
{
public:
    typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, volatile _Tp>
{
public:
    typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const volatile _Tp>
{
public:
    typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <class _Tp> struct __tuple_like : false_type {};

template <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};





template <size_t...> struct __tuple_indices {};

template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
# 144 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__tuple" 3
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template
    __to_tuple_indices<_Sp>;







template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices
{
    static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
    typedef __make_indices_imp<_Ep, _Sp> type;
};


template <class ..._Tp> class __attribute__ ((__type_visibility__("default"))) tuple;

template <class... _Tp> struct __tuple_like<tuple<_Tp...> > : true_type {};

template <class ..._Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_size<tuple<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&&) noexcept;





template <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2> > : true_type {};

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) noexcept;


template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&&) noexcept;




template <class _Tp, size_t _Size> struct __attribute__ ((__type_visibility__("default"))) array;

template <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size> > : true_type {};

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp&
get(array<_Tp, _Size>&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
get(const array<_Tp, _Size>&) noexcept;


template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp&&
get(array<_Tp, _Size>&&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&&
get(const array<_Tp, _Size>&&) noexcept;






template <class ..._Tp> struct __tuple_types {};
# 284 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__tuple" 3
template <size_t _Ip, class ..._Types>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, __tuple_types<_Types...>>
{
public:
    static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
    typedef __type_pack_element<_Ip, _Types...> type;
};


template <class ..._Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_size<__tuple_types<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <class... _Tp> struct __tuple_like<__tuple_types<_Tp...> > : true_type {};

template <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile>
struct __apply_cv_mf;
template <>
struct __apply_cv_mf<false, false, false> {
  template <class _Tp> using __apply = _Tp;
};
template <>
struct __apply_cv_mf<false, true, false> {
  template <class _Tp> using __apply = const _Tp;
};
template <>
struct __apply_cv_mf<false, false, true> {
  template <class _Tp> using __apply = volatile _Tp;
};
template <>
struct __apply_cv_mf<false, true, true> {
  template <class _Tp> using __apply = const volatile _Tp;
};
template <>
struct __apply_cv_mf<true, false, false> {
  template <class _Tp> using __apply = _Tp&;
};
template <>
struct __apply_cv_mf<true, true, false> {
  template <class _Tp> using __apply = const _Tp&;
};
template <>
struct __apply_cv_mf<true, false, true> {
  template <class _Tp> using __apply = volatile _Tp&;
};
template <>
struct __apply_cv_mf<true, true, true> {
  template <class _Tp> using __apply = const volatile _Tp&;
};
template <class _Tp, class _RawTp = typename remove_reference<_Tp>::type>
using __apply_cv_t = __apply_cv_mf<
    is_lvalue_reference<_Tp>::value,
    is_const<_RawTp>::value,
    is_volatile<_RawTp>::value>;
# 348 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__tuple" 3
template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;

template <template <class...> class _Tuple, class ..._Types, size_t ..._Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {

  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__type_pack_element<_Idx, _Types...>>...
    >;
};

template <class _Vt, size_t _Np, size_t ..._Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t>
  using __value_type = _Vt;
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__value_type<_Idx>>...
    >;
};

template <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value,
          size_t _Sp = 0,
          bool _SameSize = (_Ep == tuple_size<typename remove_reference<_Tp>::type>::value)>
struct __make_tuple_types
{
    static_assert(_Sp <= _Ep, "__make_tuple_types input error");
    using _RawTp = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
    using type = typename _Maker::template __apply_quals<_Tp>;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <bool ..._Preds>
struct __all_dummy;

template <bool ..._Pred>
using __all = is_same<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>>;

struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait,
            class ..._LArgs, class ..._RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
    -> __all<typename enable_if<_Trait<_LArgs, _RArgs>::value, bool>::type{true}...>;
  template <template <class...> class>
  static auto __do_test(...) -> false_type;

  template <class _FromArgs, class _ToArgs>
  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __convertible = decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __assignable = decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_convertible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__convertible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_constructible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_assignable
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__assignable<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up&>::type
    >
{};


template <size_t _Ip, class ..._Tp>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, tuple<_Tp...> >
{
public:
    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};


template <size_t _Ip, class ..._Tp>
using tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;


template <bool _IsTuple, class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp : false_type {};

template <class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>
    : integral_constant<bool, _SizeTrait::value == _Expected> {};

template <class _Tuple, size_t _ExpectedSize,
          class _RawTuple = typename __uncvref<_Tuple>::type>
using __tuple_like_with_size = __tuple_like_with_size_imp<
                                   __tuple_like<_RawTuple>::value,
                                   tuple_size<_RawTuple>, _ExpectedSize
                              >;

struct __attribute__ ((__visibility__("default"))) __check_tuple_constructor_fail {
    template <class ...>
    static constexpr bool __enable_default() { return false; }
    template <class ...>
    static constexpr bool __enable_explicit() { return false; }
    template <class ...>
    static constexpr bool __enable_implicit() { return false; }
    template <class ...>
    static constexpr bool __enable_assign() { return false; }
};




template <bool _CanCopy, bool _CanMove>
struct __sfinae_ctor_base {};
template <>
struct __sfinae_ctor_base<false, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<true, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<false, true> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};

template <bool _CanCopy, bool _CanMove>
struct __sfinae_assign_base {};
template <>
struct __sfinae_assign_base<false, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<true, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<false, true> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = default;
};


} }
# 199 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility" 2 3




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdint" 1 3
# 145 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdint" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdint.h" 1 3
# 106 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdint.h" 3
# 119 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdint.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdint.h" 1 3 4
# 63 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdint.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdint.h" 1 3 4
# 23 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdint.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_uint8_t.h" 3 4
typedef unsigned char uint8_t;
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_uint16_t.h" 3 4
typedef unsigned short uint16_t;
# 25 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_uint32_t.h" 3 4
typedef unsigned int uint32_t;
# 26 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_uint64_t.h" 3 4
typedef unsigned long long uint64_t;
# 27 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdint.h" 2 3 4


typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 58 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdint.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_intmax_t.h" 3 4
typedef long int intmax_t;
# 59 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_uintmax_t.h" 3 4
typedef long unsigned int uintmax_t;
# 60 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdint.h" 2 3 4
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdint.h" 2 3 4
# 120 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdint.h" 2 3
# 146 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdint" 2 3
# 149 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdint" 3


namespace std {inline namespace __1 {

using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;

using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;

using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;

using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;

using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;

using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;

using::intptr_t;
using::uintptr_t;

using::intmax_t;
using::uintmax_t;

} }
# 204 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__debug" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__debug" 3
# 54 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__debug" 3
class __attribute__ ((__visibility__("default"))) __libcpp_debug_exception;


namespace std {inline namespace __1 {

struct __attribute__ ((__type_visibility__("default"))) __libcpp_debug_info {
  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
  __libcpp_debug_info()
      : __file_(nullptr), __line_(-1), __pred_(nullptr), __msg_(nullptr) {}
  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
  __libcpp_debug_info(const char* __f, int __l, const char* __p, const char* __m)
    : __file_(__f), __line_(__l), __pred_(__p), __msg_(__m) {}
  const char* __file_;
  int __line_;
  const char* __pred_;
  const char* __msg_;
};


typedef void(*__libcpp_debug_function_type)(__libcpp_debug_info const&);



extern __libcpp_debug_function_type __libcpp_debug_function;


[[noreturn]] __attribute__ ((__visibility__("default")))
void __libcpp_abort_debug_function(__libcpp_debug_info const&);



 [[noreturn]] __attribute__ ((__visibility__("default")))
void __libcpp_throw_debug_function(__libcpp_debug_info const&);



__attribute__ ((__visibility__("default")))
bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);
# 299 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__debug" 3
} }
# 205 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility" 2 3
# 208 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility" 3


namespace std {inline namespace __1 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

}




template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
    for(; __first1 != __last1; ++__first1, (void) ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}


template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value)
{
    std::__1::swap_ranges(__a, __a + _Np, __b);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr

typename conditional
<
    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,
    const _Tp&,
    _Tp&&
>::type



move_if_noexcept(_Tp& __x) noexcept
{
    return std::__1::move(__x);
}


template <class _Tp> constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }
template <class _Tp> void as_const(const _Tp&&) = delete;


struct __attribute__ ((__type_visibility__("default"))) piecewise_construct_t { };



constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
# 311 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility" 3
template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) pair



{
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;


    pair(pair const&) = default;
    pair(pair&&) = default;
# 348 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility" 3
    template <bool _Val>
    using _EnableB = typename enable_if<_Val, bool>::type;

    struct _CheckArgs {
      template <class _U1, class _U2>
      static constexpr bool __enable_default() {
          return is_default_constructible<_U1>::value
              && is_default_constructible<_U2>::value;
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_explicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && (!is_convertible<_U1, first_type>::value
                  || !is_convertible<_U2, second_type>::value);
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_implicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && is_convertible<_U1, first_type>::value
              && is_convertible<_U2, second_type>::value;
      }
    };

    template <bool _MaybeEnable>
    using _CheckArgsDep = typename conditional<
      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;

    struct _CheckTupleLikeConstructor {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, pair>::value
               && !__tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_assign() {
            return __tuple_assignable<_Tuple, pair>::value;
        }
    };

    template <class _Tuple>
    using _CheckTLC = typename conditional<
        __tuple_like_with_size<_Tuple, 2>::value
            && !is_same<typename decay<_Tuple>::type, pair>::value,
        _CheckTupleLikeConstructor,
        __check_tuple_constructor_fail
    >::type;

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::template __enable_default<_T1, _T2>()
    > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    pair() : first(), second() {}

    template <bool _Dummy = true, _EnableB<
             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    explicit pair(_T1 const& __t1, _T2 const& __t2)
        : first(__t1), second(__t2) {}

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    pair(_T1 const& __t1, _T2 const& __t2)
        : first(__t1), second(__t2) {}

    template<class _U1, class _U2, _EnableB<
             _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    explicit pair(_U1&& __u1, _U2&& __u2)
        : first(std::__1::forward<_U1>(__u1)), second(std::__1::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    pair(_U1&& __u1, _U2&& __u2)
        : first(std::__1::forward<_U1>(__u1)), second(std::__1::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    explicit pair(pair<_U1, _U2> const& __p)
        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    pair(pair<_U1, _U2> const& __p)
        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    explicit pair(pair<_U1, _U2>&&__p)
        : first(std::__1::forward<_U1>(__p.first)), second(std::__1::forward<_U2>(__p.second)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    pair(pair<_U1, _U2>&& __p)
        : first(std::__1::forward<_U1>(__p.first)), second(std::__1::forward<_U2>(__p.second)) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    explicit pair(_Tuple&& __p)
        : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
          second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    pair(_Tuple&& __p)
        : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
          second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

    template <class... _Args1, class... _Args2>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair(piecewise_construct_t __pc,
         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
        : pair(__pc, __first_args, __second_args,
                typename __make_tuple_indices<sizeof...(_Args1)>::type(),
                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair& operator=(typename conditional<
                        is_copy_assignable<first_type>::value &&
                        is_copy_assignable<second_type>::value,
                    pair, __nat>::type const& __p)
        noexcept(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::value)

    {
        first = __p.first;
        second = __p.second;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair& operator=(typename conditional<
                        is_move_assignable<first_type>::value &&
                        is_move_assignable<second_type>::value,
                    pair, __nat>::type&& __p)
        noexcept(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::value)

    {
        first = std::__1::forward<first_type>(__p.first);
        second = std::__1::forward<second_type>(__p.second);
        return *this;
    }

    template <class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()
     > = false>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair& operator=(_Tuple&& __p) {
        first = std::__1::get<0>(std::__1::forward<_Tuple>(__p));
        second = std::__1::get<1>(std::__1::forward<_Tuple>(__p));
        return *this;
    }


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void
    swap(pair& __p) noexcept(__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::value)

    {
        using std::__1::swap;
        swap(first, __p.first);
        swap(second, __p.second);
    }
private:


    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        pair(piecewise_construct_t,
             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
             __tuple_indices<_I1...>, __tuple_indices<_I2...>);

};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                     noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value))

{
    __x.swap(__y);
}



template <class _Tp>
struct __make_pair_return_impl
{
    typedef _Tp type;
};

template <class _Tp>
struct __make_pair_return_impl<reference_wrapper<_Tp>>
{
    typedef _Tp& type;
};

template <class _Tp>
struct __make_pair_return
{
    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>
make_pair(_T1&& __t1, _T2&& __t2)
{
    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>
               (std::__1::forward<_T1>(__t1), std::__1::forward<_T2>(__t2));
}
# 652 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility" 3
template <class _T1, class _T2>
  class __attribute__ ((__type_visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <size_t _Ip, class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, pair<_T1, _T2> >
{
    static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
public:
    typedef _T1 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
public:
    typedef _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _T1&
    get(pair<_T1, _T2>& __p) noexcept {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    const _T1&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.first;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _T1&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<_T1>(__p.first);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    const _T1&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<const _T1>(__p.first);}

};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _T2&
    get(pair<_T1, _T2>& __p) noexcept {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    const _T2&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.second;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _T2&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<_T2>(__p.second);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    const _T2&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<const _T2>(__p.second);}

};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}


template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__1::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__1::move(__p));
}



template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 & get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 const & get(pair<_T1, _T2> const& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 && get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<0>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 const && get(pair<_T1, _T2> const&& __p) noexcept
{
    return __get_pair<0>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 & get(pair<_T2, _T1>& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 const & get(pair<_T2, _T1> const& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 && get(pair<_T2, _T1>&& __p) noexcept
{
    return __get_pair<1>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 const && get(pair<_T2, _T1> const&& __p) noexcept
{
    return __get_pair<1>::get(std::__1::move(__p));
}





template<class _Tp, _Tp... _Ip>
struct __attribute__ ((__type_visibility__("default"))) integer_sequence
{
    typedef _Tp value_type;
    static_assert( is_integral<_Tp>::value,
                  "std::integer_sequence can only be instantiated with an integral type" );
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    size_t
    size() noexcept { return sizeof...(_Ip); }
};

template<size_t... _Ip>
    using index_sequence = integer_sequence<size_t, _Ip...>;



template <class _Tp, _Tp _Ep>
using __make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Ep>;
# 875 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility" 3
template<class _Tp, _Tp _Np>
    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;

template<size_t _Np>
    using make_index_sequence = make_integer_sequence<size_t, _Np>;

template<class... _Tp>
    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;




template<class _T1, class _T2 = _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_T1 exchange(_T1& __obj, _T2 && __new_value)
{
    _T1 __old_value = std::__1::move(__obj);
    __obj = std::__1::forward<_T2>(__new_value);
    return __old_value;
}




struct __attribute__ ((__visibility__("default"))) in_place_t {
    explicit in_place_t() = default;
};

inline

constexpr in_place_t in_place{};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) in_place_type_t {
    explicit in_place_type_t() = default;
};
template <class _Tp>

inline

constexpr in_place_type_t<_Tp> in_place_type{};

template <size_t _Idx>
struct __attribute__ ((__visibility__("default"))) in_place_index_t {
    explicit in_place_index_t() = default;
};
template <size_t _Idx>

inline

constexpr in_place_index_t<_Idx> in_place_index{};

template <class _Tp> struct __is_inplace_type_imp : false_type {};
template <class _Tp> struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {};

template <class _Tp>
using __is_inplace_type = __is_inplace_type_imp<__uncvref_t<_Tp>>;

template <class _Tp> struct __is_inplace_index_imp : false_type {};
template <size_t _Idx> struct __is_inplace_index_imp<in_place_index_t<_Idx>> : true_type {};

template <class _Tp>
using __is_inplace_index = __is_inplace_index_imp<__uncvref_t<_Tp>>;



template <class _Arg, class _Result>
struct __attribute__ ((__type_visibility__("default"))) unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};

template <class _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::memcpy(&__r, __p, sizeof(__r));
    return __r;
}




template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    inline _Size operator()(const void* __key, _Size __len)
         __attribute__((__no_sanitize__("unsigned-integer-overflow")));
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= __data[2] << 16;
    case 2:
        __h ^= __data[1] << 8;
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    inline _Size operator()(const void* __key, _Size __len) __attribute__((__no_sanitize__("unsigned-integer-overflow")));

 private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  static _Size __hash_len_16(_Size __u, _Size __v)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char* __s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)
        __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                         __loadword<_Size>(__s + 8),
                                         __loadword<_Size>(__s + 16),
                                         __loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }


  static _Size __hash_len_33_to_64(const char *__s, size_t __len)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }



  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y = __loadword<_Size>(__s + __len - 16) +
              __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                          __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);


  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

struct _PairT {
  size_t first;
  size_t second;
};

__attribute__ ((__visibility__("hidden"), __always_inline__))
inline size_t __hash_combine(size_t __lhs, size_t __rhs) noexcept {
    typedef __scalar_hash<_PairT> _HashT;
    const _PairT __p = {__lhs, __rhs};
    return _HashT()(__p);
}

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp* __v) const noexcept
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};


template <>
struct __attribute__ ((__type_visibility__("default"))) hash<bool>
    : public unary_function<bool, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(bool __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char>
    : public unary_function<char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<signed char>
    : public unary_function<signed char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(signed char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned char __v) const noexcept {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char16_t __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char32_t __v) const noexcept {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(wchar_t __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<short>
    : public unary_function<short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<int>
    : public unary_function<int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long>
    : public unary_function<long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<__int128_t>
    : public __scalar_hash<__int128_t>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<__uint128_t>
    : public __scalar_hash<__uint128_t>
{
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(float __v) const noexcept
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(double __v) const noexcept
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long double __v) const noexcept
    {

        if (__v == 0)
            return 0;
# 1509 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility" 3
        union
        {
            long double __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__s.__a = 0;
        __u.__s.__b = 0;
        __u.__t = __v;
        return __u.__s.__a ^ __u.__s.__b;



    }
};



template <class _Tp, bool = is_enum<_Tp>::value>
struct __attribute__ ((__type_visibility__("default"))) __enum_hash
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        typedef typename underlying_type<_Tp>::type type;
        return hash<type>{}(static_cast<type>(__v));
    }
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) __enum_hash<_Tp, false> {
    __enum_hash() = delete;
    __enum_hash(__enum_hash const&) = delete;
    __enum_hash& operator=(__enum_hash const&) = delete;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash : public __enum_hash<_Tp>
{
};




template <>
struct __attribute__ ((__type_visibility__("default"))) hash<nullptr_t>
  : public unary_function<nullptr_t, size_t>
{
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  size_t operator()(nullptr_t) const noexcept {
    return 662607004ull;
  }
};



template <class _Key, class _Hash>
using __check_hash_requirements = integral_constant<bool,
    is_copy_constructible<_Hash>::value &&
    is_move_constructible<_Hash>::value &&
    __invokable_r<size_t, _Hash, _Key const&>::value
>;

template <class _Key, class _Hash = std::hash<_Key> >
using __has_enabled_hash = integral_constant<bool,
    __check_hash_requirements<_Key, _Hash>::value &&
    is_default_constructible<_Hash>::value
>;


template <class _Type, class>
using __enable_hash_helper_imp = _Type;

template <class _Type, class ..._Keys>
using __enable_hash_helper = __enable_hash_helper_imp<_Type,
  typename enable_if<__all<__has_enabled_hash<_Keys>::value...>::value>::type
>;







} }
# 643 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 1 3
# 644 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/typeinfo" 1 3
# 61 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/typeinfo" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/exception" 1 3
# 82 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/exception" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdlib" 1 3
# 86 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdlib" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdlib.h" 1 3
# 92 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdlib.h" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 1 3 4
# 65 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/wait.h" 1 3 4
# 79 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;






# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_pid_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_pid_t.h" 3 4
typedef __darwin_pid_t pid_t;
# 90 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_id_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_id_t.h" 3 4
typedef __darwin_id_t id_t;
# 91 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/wait.h" 2 3 4
# 109 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 1 3 4
# 73 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 2 3 4








# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/signal.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/signal.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/signal.h" 1 3 4
# 39 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/signal.h" 2 3 4
# 83 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 2 3 4
# 146 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 29 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/_mcontext.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/_mcontext.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/_mcontext.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/machine/_structs.h" 1 3 4
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/machine/_structs.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 1 3 4
# 46 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 92 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 150 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 194 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 213 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 229 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_ymm_reg
{
 char __ymm_reg[32];
};
# 245 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_zmm_reg
{
 char __zmm_reg[64];
};
# 259 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_opmask_reg
{
 char __opmask_reg[8];
};
# 281 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};


struct __darwin_i386_avx512_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
};
# 575 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 595 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 627 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 682 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};


struct __darwin_x86_avx512_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
 struct __darwin_ymm_reg __fpu_zmmh8;
 struct __darwin_ymm_reg __fpu_zmmh9;
 struct __darwin_ymm_reg __fpu_zmmh10;
 struct __darwin_ymm_reg __fpu_zmmh11;
 struct __darwin_ymm_reg __fpu_zmmh12;
 struct __darwin_ymm_reg __fpu_zmmh13;
 struct __darwin_ymm_reg __fpu_zmmh14;
 struct __darwin_ymm_reg __fpu_zmmh15;
 struct __darwin_zmm_reg __fpu_zmm16;
 struct __darwin_zmm_reg __fpu_zmm17;
 struct __darwin_zmm_reg __fpu_zmm18;
 struct __darwin_zmm_reg __fpu_zmm19;
 struct __darwin_zmm_reg __fpu_zmm20;
 struct __darwin_zmm_reg __fpu_zmm21;
 struct __darwin_zmm_reg __fpu_zmm22;
 struct __darwin_zmm_reg __fpu_zmm23;
 struct __darwin_zmm_reg __fpu_zmm24;
 struct __darwin_zmm_reg __fpu_zmm25;
 struct __darwin_zmm_reg __fpu_zmm26;
 struct __darwin_zmm_reg __fpu_zmm27;
 struct __darwin_zmm_reg __fpu_zmm28;
 struct __darwin_zmm_reg __fpu_zmm29;
 struct __darwin_zmm_reg __fpu_zmm30;
 struct __darwin_zmm_reg __fpu_zmm31;
};
# 1140 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 1160 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 1188 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_cpmu_state64
{
 __uint64_t __ctrs[16];
};
# 34 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/mach/machine/_structs.h" 2 3 4
# 35 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/_mcontext.h" 2 3 4




struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};



struct __darwin_mcontext_avx512_32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx512_state __fs;
};
# 97 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/_mcontext.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};



struct __darwin_mcontext_avx512_64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx512_state64 __fs;
};
# 156 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/_mcontext.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/_mcontext.h" 2 3 4
# 147 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;
# 149 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 42 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_sigaltstack.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 151 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_ucontext.h" 1 3 4
# 39 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_ucontext.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 40 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_ucontext.h" 2 3 4


struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};


typedef struct __darwin_ucontext ucontext_t;
# 152 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_sigset_t.h" 3 4
typedef __darwin_sigset_t sigset_t;
# 155 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_uid_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_uid_t.h" 3 4
typedef __darwin_uid_t uid_t;
# 157 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 2 3 4

union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 269 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 331 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 348 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 3 4
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 367 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 389 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/signal.h" 3 4
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
# 110 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/resource.h" 1 3 4
# 80 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/resource.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_timeval.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_timeval.h" 3 4
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/resource.h" 2 3 4








typedef __uint64_t rlim_t;
# 152 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 163 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/resource.h" 3 4
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 193 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/resource.h" 3 4
typedef void *rusage_info_t;

struct rusage_info_v0 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
};

struct rusage_info_v3 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
};

struct rusage_info_v4 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;

 uint64_t ri_unused[2];
};

typedef struct rusage_info_v4 rusage_info_current;
# 365 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 393 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/resource.h" 3 4
struct proc_rlimit_control_wakeupmon {
 uint32_t wm_flags;
 int32_t wm_rate;
};
# 424 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/resource.h" 3 4
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int) __attribute__((availability(macosx,introduced=10.5)));

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) __attribute__((availability(macosx,introduced=10.5)));

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );
}
# 111 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/wait.h" 2 3 4
# 186 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/endian.h" 1 3 4
# 35 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/endian.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/endian.h" 1 3 4
# 99 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/endian.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_endian.h" 1 3 4
# 130 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 66 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((__uint16_t)((_data << 8) | (_data >> 8)));
}

static inline
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{

    return __builtin_bswap32(_data);




}


static inline
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    return __builtin_bswap64(_data);
}
# 67 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 131 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_endian.h" 2 3 4
# 100 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/endian.h" 2 3 4
# 36 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/endian.h" 2 3 4
# 187 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/wait.h" 2 3 4







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
    w_Coredump:1,
    w_Retcode:8,
    w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
    w_Stopsig:8,
    w_Filler:16;






 } w_S;
};
# 247 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/wait.h" 3 4
extern "C" {
pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 66 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/alloca.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/alloca.h" 3 4
extern "C" {
void *alloca(size_t);
}
# 68 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 2 3 4
# 80 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 2 3 4

typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
# 117 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 135 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 3 4
extern "C" {
void abort(void) __attribute__((noreturn));
int abs(int) __attribute__((const));
int atexit(void (* _Nonnull)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (* _Nonnull __compar)(const void *, const void *));
void *calloc(size_t __count, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1,2)));
div_t div(int, int) __attribute__((const));
void exit(int) __attribute__((noreturn));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((const));
ldiv_t ldiv(long, long) __attribute__((const));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1)));
int mblen(const char *__s, size_t __n);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
int posix_memalign(void **__memptr, size_t __alignment, size_t __size) __attribute__((availability(macosx,introduced=10.6)));
void qsort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));
int rand(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
void *realloc(void *__ptr, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
void srand(unsigned) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *__str, char **__endptr, int __base);
long double
  strtold(const char *, char **);

long long
  strtoll(const char *__str, char **__endptr, int __base);

unsigned long
  strtoul(const char *__str, char **__endptr, int __base);

unsigned long long
  strtoull(const char *__str, char **__endptr, int __base);
# 192 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 3 4
__attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead.")))
__attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,unavailable)))
__attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)))
int system(const char *) __asm("_" "system" );



size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((noreturn));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
long nrand48(unsigned short[3]) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
int posix_openpt(int);
char *ptsname(int);


int ptsname_r(int fildes, char *buffer, size_t buflen) __attribute__((availability(macos,introduced=10.13.4))) __attribute__((availability(ios,introduced=11.3))) __attribute__((availability(tvos,introduced=11.3))) __attribute__((availability(watchos,introduced=4.3)));


int putenv(char *) __asm("_" "putenv" );
long random(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
int rand_r(unsigned *) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char * __name, const char * __value, int __overwrite) __asm("_" "setenv" );

void setkey(const char *) __asm("_" "setkey" );



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" );
# 266 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_dev_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_dev_t.h" 3 4
typedef __darwin_dev_t dev_t;
# 267 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_mode_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_mode_t.h" 3 4
typedef __darwin_mode_t mode_t;
# 268 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/stdlib.h" 2 3 4


uint32_t arc4random(void);
void arc4random_addrandom(unsigned char * , int )
    __attribute__((availability(macosx,introduced=10.0))) __attribute__((availability(macosx,deprecated=10.12,message="use arc4random_stir")))
    __attribute__((availability(ios,introduced=2.0))) __attribute__((availability(ios,deprecated=10.0,message="use arc4random_stir")))
    __attribute__((availability(tvos,introduced=2.0))) __attribute__((availability(tvos,deprecated=10.0,message="use arc4random_stir")))
    __attribute__((availability(watchos,introduced=1.0))) __attribute__((availability(watchos,deprecated=3.0,message="use arc4random_stir")));
void arc4random_buf(void * __buf, size_t __nbytes) __attribute__((availability(macosx,introduced=10.7)));
void arc4random_stir(void);
uint32_t
  arc4random_uniform(uint32_t __upper_bound) __attribute__((availability(macosx,introduced=10.7)));

int atexit_b(void (^ _Nonnull)(void)) __attribute__((availability(macosx,introduced=10.6)));
void *bsearch_b(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (^ _Nonnull __compar)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));



char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((availability(macosx,introduced=10.0,deprecated=10.5,message="Use posix_spawn APIs instead."))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);

int heapsort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));

int heapsort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

int mergesort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));

int mergesort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* _Nonnull __compar)(void *, const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void qsort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void qsort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* _Nonnull __compar)(void *, const void *, const void *));
int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
void setprogname(const char *);
int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *__ptr, size_t __size) __attribute__((alloc_size(2)));

long long
  strtoq(const char *__str, char **__endptr, int __base);
unsigned long long
  strtouq(const char *__str, char **__endptr, int __base);

extern char *suboptarg;
void *valloc(size_t) __attribute__((alloc_size(1)));






}
# 95 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdlib.h" 2 3



extern "C++" {
# 111 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdlib.h" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long abs( long __x) noexcept {return labs(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long abs(long long __x) noexcept {return llabs(__x);}


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) ldiv_t div( long __x, long __y) noexcept {return ldiv(__x, __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) lldiv_t div(long long __x, long long __y) noexcept {return lldiv(__x, __y);}



}
# 87 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdlib" 2 3
# 90 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdlib" 3








namespace std {inline namespace __1 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::abort;
using ::atexit;
using ::exit;
using ::_Exit;

using ::getenv;
using ::system;

using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbtowc;
using ::wctomb;
using ::mbstowcs;
using ::wcstombs;
# 162 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdlib" 3
} }
# 83 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/exception" 2 3
# 91 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/exception" 3


namespace std
{


class __attribute__ ((__visibility__("default"))) exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception() noexcept {}
    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_exception
    : public exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bad_exception() noexcept {}
    virtual ~bad_exception() noexcept;
    virtual const char* what() const noexcept;
};
# 124 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/exception" 3
typedef void (*terminate_handler)();
__attribute__ ((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) noexcept;
__attribute__ ((__visibility__("default"))) terminate_handler get_terminate() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void terminate() noexcept;

__attribute__ ((__visibility__("default"))) bool uncaught_exception() noexcept;
__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) int uncaught_exceptions() noexcept;

class __attribute__ ((__visibility__("default"))) exception_ptr;

__attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);



class __attribute__ ((__visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr() noexcept : __ptr_() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr(nullptr_t) noexcept : __ptr_() {}

    exception_ptr(const exception_ptr&) noexcept;
    exception_ptr& operator=(const exception_ptr&) noexcept;
    ~exception_ptr() noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit operator bool() const noexcept
    {return __ptr_ != nullptr;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return __x.__ptr_ == __y.__ptr_;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return !(__x == __y);}

    friend __attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
    friend __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template<class _Ep>
exception_ptr
make_exception_ptr(_Ep __e) noexcept
{

    try
    {
        throw __e;
    }
    catch (...)
    {
        return current_exception();
    }




}
# 234 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/exception" 3
class __attribute__ ((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() noexcept;


    virtual ~nested_exception() noexcept;


    [[noreturn]] void rethrow_nested() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr nested_ptr() const noexcept {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};


template <class _Tp, class _Up, bool>
struct __throw_with_nested;

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, true> {
    [[noreturn]] static inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void

    __do_throw(_Tp&& __t)



    {
        throw __nested<_Up>(std::__1::forward<_Tp>(__t));
    }
};

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, false> {
    [[noreturn]] static inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void

    __do_throw(_Tp&& __t)



    {
        throw std::__1::forward<_Tp>(__t);
    }
};


template <class _Tp>
[[noreturn]]
void

throw_with_nested(_Tp&& __t)



{

    typedef typename decay<_Tp>::type _Up;
    static_assert( is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
    __throw_with_nested<_Tp, _Up,
        is_class<_Up>::value &&
        !is_base_of<nested_exception, _Up>::value &&
        !__libcpp_is_final<_Up>::value>::
            __do_throw(std::__1::forward<_Tp>(__t));




}

template <class _From, class _To>
struct __can_dynamic_cast : public bool_constant<(is_polymorphic<_From>::value && (!is_base_of<_To, _From>::value || is_convertible<const _From*, const _To*>::value))> {};




template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep& __e,
                  typename enable_if< __can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(std::__1::addressof(__e));
    if (__nep)
        __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep&,
                  typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
}

}
# 62 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/typeinfo" 2 3
# 70 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/typeinfo" 3
# 80 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/typeinfo" 3
namespace std
{


class __attribute__ ((__visibility__("default"))) type_info
{
    type_info& operator=(const type_info&);
    type_info(const type_info&);







protected:
# 104 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/typeinfo" 3
    const char *__type_name;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit type_info(const char* __n) : __type_name(__n) {}


public:
    __attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
    virtual ~type_info();
# 154 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/typeinfo" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* name() const noexcept
    { return __type_name; }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool before(const type_info& __arg) const noexcept
    { return __type_name < __arg.__type_name; }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t hash_code() const noexcept
    { return reinterpret_cast<size_t>(__type_name); }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const type_info& __arg) const noexcept
    { return __type_name == __arg.__type_name; }


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }
};

class __attribute__ ((__visibility__("default"))) bad_cast
    : public exception
{
public:
    bad_cast() noexcept;
    virtual ~bad_cast() noexcept;
    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_typeid
    : public exception
{
public:
    bad_typeid() noexcept;
    virtual ~bad_typeid() noexcept;
    virtual const char* what() const noexcept;
};



}

namespace std {inline namespace __1 {
[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __throw_bad_cast()
{

    throw bad_cast();



}
} }
# 645 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/new" 1 3
# 101 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/new" 3
# 114 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/new" 3
namespace std
{


struct __attribute__ ((__visibility__("default"))) nothrow_t {};
extern __attribute__ ((__visibility__("default"))) const nothrow_t nothrow;

class __attribute__ ((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    virtual ~bad_alloc() noexcept;
    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() noexcept;
    virtual ~bad_array_new_length() noexcept;
    virtual const char* what() const noexcept;
};

typedef void (*new_handler)();
__attribute__ ((__visibility__("default"))) new_handler set_new_handler(new_handler) noexcept;
__attribute__ ((__visibility__("default"))) new_handler get_new_handler() noexcept;



[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_bad_alloc();



class __attribute__ ((__visibility__("default"))) __attribute__((unavailable))
    bad_array_length : public bad_alloc {
public:
    bad_array_length() noexcept;
    virtual ~bad_array_length() noexcept;
    virtual const char* what() const noexcept;
};







enum class __attribute__ ((__type_visibility__("default"))) align_val_t : size_t { };





}
# 179 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/new" 3
__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz) ;
__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete(void* __p, std::size_t __sz) noexcept;


__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz) ;
__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete[](void* __p, std::size_t __sz) noexcept;



__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t) ;
__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete(void* __p, std::size_t __sz, std::align_val_t) noexcept;


__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t) ;
__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete[](void* __p, std::size_t __sz, std::align_val_t) noexcept;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new (std::size_t, void* __p) noexcept {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new[](std::size_t, void* __p) noexcept {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete (void*, void*) noexcept {}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete[](void*, void*) noexcept {}



namespace std {inline namespace __1 {

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void *__allocate(size_t __size) {



  return __builtin_operator_new(__size);

}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void __libcpp_deallocate(void *__ptr) {



  __builtin_operator_delete(__ptr);

}


[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__attribute__((unavailable))

void __throw_bad_array_length()
{

    throw bad_array_length();



}


} }
# 648 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/limits" 1 3
# 117 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/limits" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 121 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/limits" 2 3


namespace std {inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return type();}

    static constexpr const int digits = 0;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const bool is_signed = false;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 0;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return type();}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return type();}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = false;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min
{
    static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};

template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false>
{
    static constexpr const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = type(-1) < type(0);
    static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static constexpr const int digits10 = digits * 3 / 10;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = !std::__1::is_signed<_Tp>::value;



    static constexpr const bool traps = true;



    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = false;
    static constexpr const int digits = 1;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = false;
    static constexpr const type __max = true;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 24;
    static constexpr const int digits10 = 6;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return 1.17549435e-38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return 3.40282347e+38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return 1.19209290e-7F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return 0.5F;}

    static constexpr const int min_exponent = (-125);
    static constexpr const int min_exponent10 = (-37);
    static constexpr const int max_exponent = 128;
    static constexpr const int max_exponent10 = 38;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return 1.40129846e-45F;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return 2.2250738585072014e-308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return 1.7976931348623157e+308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return 0.5;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 64;
    static constexpr const int digits10 = 18;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return 3.36210314311209350626e-4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return 1.18973149535723176502e+4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return 1.08420217248550443401e-19L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return 0.5;}

    static constexpr const int min_exponent = (-16381);
    static constexpr const int min_exponent10 = (-4931);
    static constexpr const int max_exponent = 16384;
    static constexpr const int max_exponent10 = 4932;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return 3.64519953188247460253e-4951L;}




    static constexpr const bool is_iec559 = true;

    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 650 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iterator" 1 3
# 427 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iterator" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__functional_base" 1 3
# 23 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__functional_base" 3


namespace std {inline namespace __1 {

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__ ((__type_visibility__("default"))) binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};

template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};


template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) less : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) less<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<_Tp>
{
};



template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef _Rp result_type;
};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};





template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
{
    typedef _Rp result_type;
};

template <class _Tp, class ..._Args>
struct __invoke_return
{
    typedef decltype(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_Args>()...)) type;
};
# 312 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__functional_base" 3
template <class _Ret>
struct __invoke_void_return_wrapper
{

    template <class ..._Args>
    static _Ret __call(_Args&&... __args) {
        return __invoke(std::__1::forward<_Args>(__args)...);
    }
# 341 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__functional_base" 3
};

template <>
struct __invoke_void_return_wrapper<void>
{

    template <class ..._Args>
    static void __call(_Args&&... __args) {
        __invoke(std::__1::forward<_Args>(__args)...);
    }
# 372 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__functional_base" 3
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) reference_wrapper
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type* __f_;

public:

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference_wrapper(type& __f) noexcept
        : __f_(std::__1::addressof(__f)) {}

    private: reference_wrapper(type&&); public:



    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator type& () const noexcept {return *__f_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) type& get() const noexcept {return *__f_;}



    template <class... _ArgTypes>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename __invoke_of<type&, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return __invoke(get(), std::__1::forward<_ArgTypes>(__args)...);
    }
# 510 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__functional_base" 3
};


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(_Tp& __t) noexcept
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept
{
    return ref(__t.get());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(const _Tp& __t) noexcept
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept
{
    return cref(__t.get());
}


template <class _Tp> void ref(const _Tp&&) = delete;
template <class _Tp> void cref(const _Tp&&) = delete;



template <class _Tp, class, class = void>
struct __is_transparent : false_type {};

template <class _Tp, class _Up>
struct __is_transparent<_Tp, _Up,
                        typename __void_t<typename _Tp::is_transparent>::type>
   : true_type {};




struct __attribute__ ((__type_visibility__("default"))) allocator_arg_t { };




constexpr allocator_arg_t allocator_arg = allocator_arg_t();




template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};


template <class _Tp, class _Alloc>
constexpr size_t uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;






template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor_imp
{
    typedef typename __uncvref<_Alloc>::type _RawAlloc;
    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
    static const bool __ic =
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
    static const int value = __ua ? 2 - __ic : 0;
};

template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor
    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
    {};

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
{
    new (__storage) _Tp (std::__1::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (allocator_arg, __a, std::__1::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (std::__1::forward<_Args>(__args)..., __a);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)
{
    __user_alloc_construct_impl(
             __uses_alloc_ctor<_Tp, _Allocator>(),
             __storage, __a, std::__1::forward<_Args>(__args)...
        );
}


} }
# 428 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iterator" 2 3
# 439 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iterator" 3


namespace std {inline namespace __1 {

struct __attribute__ ((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};






template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_const<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;
};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

template <class _Tp>
struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};

template <class _Tp>
struct __is_exactly_input_iterator
    : public integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};

template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__ ((__type_visibility__("default"))) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}

template <class _BiDirIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
   __i += __n;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
void advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n)
{
    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_InputIter
next(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1,
     typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0)
{
    std::__1::advance(__x, __n);
    return __x;
}

template <class _BidiretionalIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_BidiretionalIter
prev(_BidiretionalIter __x,
     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,
     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)
{
    std::__1::advance(__x, -__n);
    return __x;
}


template <class _Tp, class = void>
struct __is_stashing_iterator : false_type {};

template <class _Tp>
struct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>
  : true_type {};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
private:
                _Iter __t;

    static_assert(!__is_stashing_iterator<_Iter>::value,
      "The specified iterator type cannot be used with reverse_iterator; "
      "Using stashing iterators with reverse_iterator causes undefined behavior");

protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reverse_iterator() : __t(), current() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)
            { __t = current = __u.base(); return *this; }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _Iter base() const {return current;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reference operator*() const {_Iter __tmp = current; return *--__tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    pointer operator->() const {return std::__1::addressof(operator*());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reverse_iterator& operator++() {--current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reverse_iterator operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reverse_iterator& operator--() {++current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reverse_iterator operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reverse_iterator operator+ (difference_type __n) const {return reverse_iterator(current - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reverse_iterator operator- (difference_type __n) const {return reverse_iterator(current + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reference operator[](difference_type __n) const {return *(*this + __n);}
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
-> decltype(__y.base() - __x.base())
{
    return __y.base() - __x.base();
}
# 762 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}


template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
reverse_iterator<_Iter> make_reverse_iterator(_Iter __i)
{
    return reverse_iterator<_Iter>(__i);
}


template <class _Container>
class __attribute__ ((__type_visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit back_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_back(std::__1::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit front_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_front(std::__1::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator(_Container& __x, typename _Container::iterator __i)
        : container(std::__1::addressof(__x)), iter(__i) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator=(typename _Container::value_type&& __value_)
        {iter = container->insert(iter, std::__1::move(__value_)); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
insert_iterator<_Container>
inserter(_Container& __x, typename _Container::iterator __i)
{
    return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__ ((__type_visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr istream_iterator() : __in_stream_(0), __value_() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator(istream_type& __s) : __in_stream_(std::__1::addressof(__s))
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp& operator*() const {return __value_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp* operator->() const {return std::__1::addressof((operator*()));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const istream_iterator& __x, const istream_iterator& __y)
        {return __x.__in_stream_ == __y.__in_stream_;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s) noexcept
        : __out_stream_(std::__1::addressof(__s)), __delim_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter) noexcept
        : __out_stream_(std::__1::addressof(__s)), __delim_(__delimiter) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++(int) {return *this;}
};

template<class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const {return __keep_;}
    };

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = 0;
        return __sbuf_ == 0;
    }
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr istreambuf_iterator() noexcept : __sbuf_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(istream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(const __proxy& __p) noexcept
        : __sbuf_(__p.__sbuf_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    streambuf_type* __sbuf_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(ostream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool failed() const noexcept {return __sbuf_ == 0;}





    template <class _Ch, class _Tr>
    friend
    __attribute__ ((__visibility__("hidden")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);

};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef iterator_type pointer;

    typedef typename iterator_traits<iterator_type>::reference __reference;
    typedef typename conditional<
            is_reference<__reference>::value,
            typename remove_reference<__reference>::type&&,
            __reference
        >::type reference;




    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    move_iterator() : __i() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    explicit move_iterator(_Iter __x) : __i(__x) {}
    template <class _Up>
      __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr _Iter base() const {return __i;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reference operator*() const { return static_cast<reference>(*__i); }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    pointer operator->() const { return __i;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    move_iterator& operator++() {++__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    move_iterator operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    move_iterator& operator--() {--__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    move_iterator operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    move_iterator operator+ (difference_type __n) const {return move_iterator(__i + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    move_iterator operator- (difference_type __n) const {return move_iterator(__i - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
-> decltype(__x.base() - __y.base())
{
    return __x.base() - __y.base();
}
# 1181 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}



template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;


template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base());







template <class _Iter>
__attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) noexcept;

template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) move_backward(_B1, _B1, _B2);



template <class _Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);
# 1278 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iterator" 3
template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
private:
    iterator_type __i;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter() noexcept

                : __i{}

    {



    }
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(const __wrap_iter<_Up>& __u,
        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) noexcept
        : __i(__u.base())
    {



    }
# 1331 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iterator" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const noexcept
    {




        return *__i;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const noexcept
    {




        return (pointer)std::__1::addressof(*__i);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator++() noexcept
    {




        ++__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator++(int) noexcept
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator--() noexcept
    {




        --__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator--(int) noexcept
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator+ (difference_type __n) const noexcept
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator+=(difference_type __n) noexcept
    {




        __i += __n;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator- (difference_type __n) const noexcept
        {return *this + (-__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator-=(difference_type __n) noexcept
        {*this += -__n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const noexcept
    {




        return __i[__n];
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator_type base() const noexcept {return __i;}

private:






    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(iterator_type __x) noexcept : __i(__x) {}


    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class __attribute__ ((__type_visibility__("default"))) vector;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;


    template <class _Iter1, class _Iter2>
    friend
    auto
    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
    -> decltype(__x.base() - __y.base());







    template <class _Iter1>
    friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) noexcept;

    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);


    template <class _Tp>
    friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
# 1481 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iterator" 3
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{




    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__y < __x);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__y < __x);
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base())
{




    return __x.base() - __y.base();
}
# 1594 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) noexcept
{
    __x += __n;
    return __x;
}

template <class _Iter>
struct __libcpp_is_trivial_iterator
    : public bool_constant<(is_pointer<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
    : public bool_constant<(__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >
    : public bool_constant<(__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
    : public bool_constant<(__libcpp_is_trivial_iterator<_Iter>::value)> {};


template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}



template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto
begin(_Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto
begin(const _Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto
end(_Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto
end(const _Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}



template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
reverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array + _Np);
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
reverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array);
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
reverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.end());
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
reverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.begin());
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto cbegin(const _Cp& __c) -> decltype(std::__1::begin(__c))
{
    return std::__1::begin(__c);
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto cend(const _Cp& __c) -> decltype(std::__1::end(__c))
{
    return std::__1::end(__c);
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto rbegin(_Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto rbegin(const _Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto rend(_Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto rend(const _Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto crbegin(const _Cp& __c) -> decltype(std::__1::rbegin(__c))
{
    return std::__1::rbegin(__c);
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
auto crend(const _Cp& __c) -> decltype(std::__1::rend(__c))
{
    return std::__1::rend(__c);
}
# 1797 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iterator" 3
template <class _Cont>
constexpr auto size(const _Cont& __c) -> decltype(__c.size()) { return __c.size(); }

template <class _Tp, size_t _Sz>
constexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }

template <class _Cont>
constexpr auto empty(const _Cont& __c) -> decltype(__c.empty()) { return __c.empty(); }

template <class _Tp, size_t _Sz>
constexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }

template <class _Ep>
constexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }

template <class _Cont> constexpr
auto data(_Cont& __c) -> decltype(__c.data()) { return __c.data(); }

template <class _Cont> constexpr
auto data(const _Cont& __c) -> decltype(__c.data()) { return __c.data(); }

template <class _Tp, size_t _Sz>
constexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }

template <class _Ep>
constexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }



} }
# 651 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/tuple" 1 3
# 147 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/tuple" 3


namespace std {inline namespace __1 {






template <size_t _Ip, class _Hp,
          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
         >
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    noexcept(__is_nothrow_swappable<_Hp>::value)
{
    swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool>
class __tuple_leaf
{
    _Hp __value_;

    template <class _Tp>
    static constexpr bool __can_bind_reference() {
        using _RawTp = typename remove_reference<_Tp>::type;
        using _RawHp = typename remove_reference<_Hp>::type;
        using _CheckLValueArg = integral_constant<bool,
            is_lvalue_reference<_Tp>::value
        || is_same<_RawTp, reference_wrapper<_RawHp>>::value
        || is_same<_RawTp, reference_wrapper<typename remove_const<_RawHp>::type>>::value
        >;
        return !is_reference<_Hp>::value
            || (is_lvalue_reference<_Hp>::value && _CheckLValueArg::value)
            || (is_rvalue_reference<_Hp>::value && !is_lvalue_reference<_Tp>::value);
    }

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) : __value_()
       {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
            : __value_()
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : __value_(allocator_arg_t(), __a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : __value_(__a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Tp,
              class = typename enable_if<
                  __lazy_and<
                      __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>
                    , is_constructible<_Hp, _Tp>
                    >::value
                >::type
            >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : __value_(std::__1::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp>(),
       "Attempted to construct a reference element in a tuple with an rvalue");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : __value_(std::__1::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp>(),
       "Attempted to construct a reference element in a tuple with an rvalue");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : __value_(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t))
        {static_assert(!is_reference<_Hp>::value,
            "Attempted to uses-allocator construct a reference element in a tuple");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : __value_(std::__1::forward<_Tp>(__t), __a)
        {static_assert(!is_reference<_Hp>::value,
           "Attempted to uses-allocator construct a reference element in a tuple");}

    __tuple_leaf(const __tuple_leaf& __t) = default;
    __tuple_leaf(__tuple_leaf&& __t) = default;

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf&
        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp>::value))
        {
            __value_ = std::__1::forward<_Tp>(__t);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr _Hp& get() noexcept {return __value_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr const _Hp& get() const noexcept {return __value_;}
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true>
    : private _Hp
{

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : _Hp(allocator_arg_t(), __a) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : _Hp(__a) {}

    template <class _Tp,
              class = typename enable_if<
                  __lazy_and<
                        __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>
                      , is_constructible<_Hp, _Tp>
                    >::value
                >::type
            >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : _Hp(std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : _Hp(std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : _Hp(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : _Hp(std::__1::forward<_Tp>(__t), __a) {}

    __tuple_leaf(__tuple_leaf const &) = default;
    __tuple_leaf(__tuple_leaf &&) = default;

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf&
        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp>::value))
        {
            _Hp::operator=(std::__1::forward<_Tp>(__t));
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int
    swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr _Hp& get() noexcept {return static_cast<_Hp&>(*this);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr const _Hp& get() const noexcept {return static_cast<const _Hp&>(*this);}
};

template <class ..._Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
void __swallow(_Tp&&...) noexcept {}

template <class ..._Tp>
struct __lazy_all : __all<_Tp::value...> {};

template <class _Tp>
struct __all_default_constructible;

template <class ..._Tp>
struct __all_default_constructible<__tuple_types<_Tp...>>
    : __all<is_default_constructible<_Tp>::value...>
{ };



template<class _Indx, class ..._Tp> struct __tuple_impl;

template<size_t ..._Indx, class ..._Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>...
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr __tuple_impl()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    template <size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        explicit
        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u)
                     noexcept((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value && __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :

            __tuple_leaf<_Uf, _Tf>(std::__1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>()...
            {}

    template <class _Alloc, size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit
        __tuple_impl(allocator_arg_t, const _Alloc& __a,
                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u) :
            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
            std::__1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
            {}

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        __tuple_impl(_Tuple&& __t) noexcept((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

            : __tuple_leaf<_Indx, _Tp>(std::__1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...
            {}

    template <class _Alloc, class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
                                       std::__1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...
            {}

    template <class _Tuple>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,
            __tuple_impl&
        >::type
        operator=(_Tuple&& __t) noexcept((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

        {
            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...);
            return *this;
        }

    __tuple_impl(const __tuple_impl&) = default;
    __tuple_impl(__tuple_impl&&) = default;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tuple_impl&
    operator=(const __tuple_impl& __t) noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tuple_impl&
    operator=(__tuple_impl&& __t) noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__1::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(__tuple_impl& __t)
        noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
    }
};



template <class ..._Tp>
class __attribute__ ((__type_visibility__("default"))) tuple
{
    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;

    _BaseT __base_;




    static constexpr bool _EnableImplicitReducedArityExtension = false;


    template <class ..._Args>
    struct _PackExpandsToThisTuple : false_type {};

    template <class _Arg>
    struct _PackExpandsToThisTuple<_Arg>
        : is_same<typename __uncvref<_Arg>::type, tuple> {};

    template <bool _MaybeEnable, class _Dummy = void>
    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};

    template <class _Dummy>
    struct _CheckArgsConstructor<true, _Dummy>
    {
        template <class ..._Args>
        static constexpr bool __enable_default() {
            return __all<is_default_constructible<_Args>::value...>::value;
        }

        template <class ..._Args>
        static constexpr bool __enable_explicit() {
            return
                __tuple_constructible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                !__tuple_convertible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __all_default_constructible<
                    typename __make_tuple_types<tuple, sizeof...(_Tp),
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value;
        }

        template <class ..._Args>
        static constexpr bool __enable_implicit() {
            return
                __tuple_convertible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __all_default_constructible<
                    typename __make_tuple_types<tuple, sizeof...(_Tp),
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value;
        }
    };

    template <bool _MaybeEnable,
              bool = sizeof...(_Tp) == 1,
              class _Dummy = void>
    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};

    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, false, _Dummy>
    {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_convertible<_Tuple, tuple>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, tuple>::value
               && !__tuple_convertible<_Tuple, tuple>::value;
        }
    };

    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, true, _Dummy>
    {



        template <class _Tuple>
        using _PreferTupleLikeConstructor = __lazy_or<


            is_same<typename __uncvref<_Tuple>::type, tuple>,
            __lazy_and<
                __lazy_not<is_constructible<_Tp..., _Tuple>>,
                __lazy_not<is_convertible<_Tuple, _Tp...>>
            >
        >;

        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __lazy_and<
                __tuple_convertible<_Tuple, tuple>,
                _PreferTupleLikeConstructor<_Tuple>
            >::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __lazy_and<
                __tuple_constructible<_Tuple, tuple>,
                _PreferTupleLikeConstructor<_Tuple>,
                __lazy_not<__tuple_convertible<_Tuple, tuple>>
            >::value;
        }
    };

    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) noexcept;
public:

    template <bool _Dummy = true, class = typename enable_if<
        _CheckArgsConstructor<_Dummy>::template __enable_default<_Tp...>()
    >::type>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr tuple()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    tuple(tuple const&) = default;
    tuple(tuple&&) = default;

    template <class _AllocArgT, class _Alloc, bool _Dummy = true, class = typename enable_if<
        __lazy_and<
            is_same<allocator_arg_t, _AllocArgT>,
            __lazy_all<__dependent_type<is_default_constructible<_Tp>, _Dummy>...>
       >::value
    >::type>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    tuple(_AllocArgT, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}

    template <bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_implicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_explicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    explicit tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_implicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_explicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      explicit
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class ..._Up,
              bool _PackIsTuple = _PackExpandsToThisTuple<_Up...>::value,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp)
                             && !_PackIsTuple
                         >::template __enable_implicit<_Up...>() ||
                        _CheckArgsConstructor<
                            _EnableImplicitReducedArityExtension
                            && sizeof...(_Up) < sizeof...(_Tp)
                            && !_PackIsTuple
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        tuple(_Up&&... __u)
            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up... >::value ))
# 738 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/tuple" 3
            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) <= sizeof...(_Tp)
                             && !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_explicit<_Up...>() ||
                         _CheckArgsConstructor<
                            !_EnableImplicitReducedArityExtension
                            && sizeof...(_Up) < sizeof...(_Tp)
                            && !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        explicit
        tuple(_Up&&... __u)
            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up... >::value ))
# 771 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/tuple" 3
            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp) &&
                             !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
            : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp) &&
                             !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_explicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit
        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
            : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                             && !_PackExpandsToThisTuple<_Tuple>::value
                         >::template __enable_implicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple>::value))
            : __base_(std::__1::forward<_Tuple>(__t)) {}

    template <class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                             && !_PackExpandsToThisTuple<_Tuple>::value
                         >::template __enable_explicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        explicit
        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple>::value))
            : __base_(std::__1::forward<_Tuple>(__t)) {}

    template <class _Alloc, class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                         >::template __enable_implicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __base_(allocator_arg_t(), __a, std::__1::forward<_Tuple>(__t)) {}

    template <class _Alloc, class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                         >::template __enable_explicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit
        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __base_(allocator_arg_t(), __a, std::__1::forward<_Tuple>(__t)) {}

    using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;
    using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    tuple& operator=(typename conditional<_CanCopyAssign::value, tuple, __nat>::type const& __t)
        noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
    {
        __base_.operator=(__t.__base_);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    tuple& operator=(typename conditional<_CanMoveAssign::value, tuple, __nat>::type&& __t)
        noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
    {
        __base_.operator=(static_cast<_BaseT&&>(__t.__base_));
        return *this;
    }

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_assignable<_Tuple, tuple>::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple&
        operator=(_Tuple&& __t) noexcept((is_nothrow_assignable<_BaseT&, _Tuple>::value))
        {
            __base_.operator=(std::__1::forward<_Tuple>(__t));
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(tuple& __t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        {__base_.swap(__t.__base_);}
};

template <>
class __attribute__ ((__type_visibility__("default"))) tuple<>
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr tuple() noexcept {}
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(allocator_arg_t, const _Alloc&) noexcept {}
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept {}
    template <class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(array<_Up, 0>) noexcept {}
    template <class _Alloc, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) noexcept {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(tuple&) noexcept {}
};





template <class _Alloc, class ..._Args>
tuple(allocator_arg_t, const _Alloc&, tuple<_Args...> const&) -> tuple<_Args...>;
template <class _Alloc, class ..._Args>
tuple(allocator_arg_t, const _Alloc&, tuple<_Args...>&&) -> tuple<_Args...>;


template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __all<__is_swappable<_Tp>::value...>::value,
    void
>::type
swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
                 noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {__t.swap(__u);}



template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<type&&>(
             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const type&&>(
             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}



namespace __find_detail {

static constexpr size_t __not_found = -1;
static constexpr size_t __ambiguous = __not_found - 1;

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
    return !__matches ? __res :
        (__res == __not_found ? __curr_i : __ambiguous);
}

template <size_t _Nx>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
  return __i == _Nx ? __not_found :
      __find_idx_return(__i, __find_idx(__i + 1, __matches), __matches[__i]);
}

template <class _T1, class ..._Args>
struct __find_exactly_one_checked {
  static constexpr bool __matches[] = {is_same<_T1, _Args>::value...};
    static constexpr size_t value = __find_detail::__find_idx(0, __matches);
    static_assert (value != __not_found, "type not found in type list" );
    static_assert(value != __ambiguous,"type occurs more than once in type list");
};

template <class _T1>
struct __find_exactly_one_checked<_T1> {
    static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
};

}

template <typename _T1, typename... _Args>
struct __find_exactly_one_t
    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {
};

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1& get(tuple<_Args...>& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__1::move(__tup));
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__1::move(__tup));
}





template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
tuple<_Tp&...>
tie(_Tp&... __t) noexcept
{
    return tuple<_Tp&...>(__t...);
}

template <class _Up>
struct __ignore_t
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    const __ignore_t& operator=(_Tp&&) const {return *this;}
};

namespace {
  constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
}

template <class _Tp>
struct __make_tuple_return_impl
{
    typedef _Tp type;
};

template <class _Tp>
struct __make_tuple_return_impl<reference_wrapper<_Tp> >
{
    typedef _Tp& type;
};

template <class _Tp>
struct __make_tuple_return
{
    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;
};

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
tuple<typename __make_tuple_return<_Tp>::type...>
make_tuple(_Tp&&... __t)
{
    return tuple<typename __make_tuple_return<_Tp>::type...>(std::__1::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
tuple<_Tp&&...>
forward_as_tuple(_Tp&&... __t) noexcept
{
    return tuple<_Tp&&...>(std::__1::forward<_Tp>(__t)...);
}

template <size_t _Ip>
struct __tuple_equal
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        return __tuple_equal<_Ip - 1>()(__x, __y) && std::__1::get<_Ip-1>(__x) == std::__1::get<_Ip-1>(__y);
    }
};

template <>
struct __tuple_equal<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return true;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x == __y);
}

template <size_t _Ip>
struct __tuple_less
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        const size_t __idx = tuple_size<_Tp>::value - _Ip;
        if (std::__1::get<__idx>(__x) < std::__1::get<__idx>(__y))
            return true;
        if (std::__1::get<__idx>(__y) < std::__1::get<__idx>(__x))
            return false;
        return __tuple_less<_Ip-1>()(__x, __y);
    }
};

template <>
struct __tuple_less<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return false;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __tuple_less<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __y < __x;
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x < __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__y < __x);
}



template <class _Tp, class _Up> struct __tuple_cat_type;

template <class ..._Ttypes, class ..._Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
{
    typedef tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
struct __tuple_cat_return_1
{
};

template <class ..._Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
{
    typedef typename __tuple_cat_type<tuple<_Types...>,
            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type
                                                                           type;
};

template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
                 typename __tuple_cat_type<
                     tuple<_Types...>,
                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type
                 >::type,
                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,
                 _Tuple1, _Tuples...>
{
};

template <class ..._Tuples> struct __tuple_cat_return;

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,
                                                                     _Tuples...>
{
};

template <>
struct __tuple_cat_return<>
{
    typedef tuple<> type;
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
tuple<>
tuple_cat()
{
    return tuple<>();
}

template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref_imp;

template <class ..._Types, size_t ..._I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
{
    typedef typename remove_reference<_Tuple0>::type _T0;
    typedef tuple<_Types..., typename __apply_cv<_Tuple0,
                          typename tuple_element<_I0, _T0>::type>::type&&...> type;
};

template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
         tuple<_Types..., typename __apply_cv<_Tuple0,
               typename tuple_element<_I0,
                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,
         typename __make_tuple_indices<tuple_size<typename
                                 remove_reference<_Tuple1>::type>::value>::type,
         _Tuple1, _Tuples...>
{
};

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<tuple<>,
               typename __make_tuple_indices<
                        tuple_size<typename remove_reference<_Tuple0>::type>::value
               >::type, _Tuple0, _Tuples...>
{
};

template <class _Types, class _I0, class _J0>
struct __tuple_cat;

template <class ..._Types, size_t ..._I0, size_t ..._J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
{
    template <class _Tuple0>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
    {
        return forward_as_tuple(std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
                                      std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...);
    }

    template <class _Tuple0, class _Tuple1, class ..._Tuples>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
    {
        typedef typename remove_reference<_Tuple0>::type _T0;
        typedef typename remove_reference<_Tuple1>::type _T1;
        return __tuple_cat<
           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,
           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,
           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()
                           (forward_as_tuple(
                              std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
                              std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...
                            ),
                            std::__1::forward<_Tuple1>(__t1),
                            std::__1::forward<_Tuples>(__tpls)...);
    }
};

template <class _Tuple0, class... _Tuples>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
{
    typedef typename remove_reference<_Tuple0>::type _T0;
    return __tuple_cat<tuple<>, __tuple_indices<>,
                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
                  (tuple<>(), std::__1::forward<_Tuple0>(__t0),
                                            std::__1::forward<_Tuples>(__tpls)...);
}

template <class ..._Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<tuple<_Tp...>, _Alloc>
    : true_type {};

template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_T1, _T2>::pair(piecewise_construct_t,
                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
    : first(std::__1::forward<_Args1>(std::__1::get<_I1>( __first_args))...),
      second(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...)
{
}


template <class _Tp>
constexpr size_t tuple_size_v = tuple_size<_Tp>::value;



template <class _Fn, class _Tuple, size_t ..._Id>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,
                                            __tuple_indices<_Id...>)
noexcept(noexcept(std::__1::__invoke_constexpr( std::__1::forward<_Fn>(__f), std::__1::get<_Id>(std::__1::forward<_Tuple>(__t))...))) { return std::__1::__invoke_constexpr( std::__1::forward<_Fn>(__f), std::__1::get<_Id>(std::__1::forward<_Tuple>(__t))...); }





template <class _Fn, class _Tuple>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr decltype(auto) apply(_Fn && __f, _Tuple && __t)
noexcept(noexcept(std::__1::__apply_tuple_impl( std::__1::forward<_Fn>(__f), std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{}))) { return std::__1::__apply_tuple_impl( std::__1::forward<_Fn>(__f), std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{}); }





template <class _Tp, class _Tuple, size_t... _Idx>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
noexcept(noexcept(_Tp(std::__1::get<_Idx>(std::__1::forward<_Tuple>(__t))...))) { return _Tp(std::__1::get<_Idx>(std::__1::forward<_Tuple>(__t))...); }



template <class _Tp, class _Tuple>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _Tp make_from_tuple(_Tuple&& __t)
noexcept(noexcept(std::__1::__make_from_tuple_impl<_Tp>(std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{}))) { return std::__1::__make_from_tuple_impl<_Tp>(std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{}); }
# 1415 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/tuple" 3
} }
# 654 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdexcept" 1 3
# 54 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdexcept" 3


namespace std {inline namespace __1 {

class __attribute__ ((__visibility__("hidden"))) __libcpp_refstring
{
    const char* __imp_;

    bool __uses_refcount() const;
public:
    explicit __libcpp_refstring(const char* __msg);
    __libcpp_refstring(const __libcpp_refstring& __s) noexcept;
    __libcpp_refstring& operator=(const __libcpp_refstring& __s) noexcept;
    ~__libcpp_refstring();

    const char* c_str() const noexcept {return __imp_;}
};

} }

namespace std
{

class __attribute__ ((__visibility__("default"))) logic_error
    : public exception
{
private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;

    virtual ~logic_error() noexcept;

    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) runtime_error
    : public exception
{
private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;

    virtual ~runtime_error() noexcept;

    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const char* __s) : logic_error(__s) {}

    virtual ~domain_error() noexcept;
};

class __attribute__ ((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const char* __s) : logic_error(__s) {}

    virtual ~invalid_argument() noexcept;
};

class __attribute__ ((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const char* __s) : logic_error(__s) {}

    virtual ~length_error() noexcept;
};

class __attribute__ ((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const char* __s) : logic_error(__s) {}

    virtual ~out_of_range() noexcept;
};

class __attribute__ ((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const char* __s) : runtime_error(__s) {}

    virtual ~range_error() noexcept;
};

class __attribute__ ((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~overflow_error() noexcept;
};

class __attribute__ ((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~underflow_error() noexcept;
};

}

namespace std {inline namespace __1 {


[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_runtime_error(const char*);

[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __throw_logic_error(const char*__msg)
{

    throw logic_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __throw_domain_error(const char*__msg)
{

    throw domain_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __throw_invalid_argument(const char*__msg)
{

    throw invalid_argument(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __throw_length_error(const char*__msg)
{

    throw length_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __throw_out_of_range(const char*__msg)
{

    throw out_of_range(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __throw_range_error(const char*__msg)
{

    throw range_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __throw_overflow_error(const char*__msg)
{

    throw overflow_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __throw_underflow_error(const char*__msg)
{

    throw underflow_error(__msg);




}

} }
# 655 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 2 3 4
# 75 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn)) __attribute__((__disable_tail_calls__));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 3
# 657 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/atomic" 1 3
# 550 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/atomic" 3
# 579 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/atomic" 3
namespace std {inline namespace __1 {

typedef enum memory_order
{
    memory_order_relaxed, memory_order_consume, memory_order_acquire,
    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
} memory_order;
# 856 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/atomic" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
kill_dependency(_Tp __y) noexcept
{
    return __y;
}
# 890 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/atomic" 3
template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base
{
    mutable _Atomic(_Tp) __a_;


  static constexpr bool is_always_lock_free = __atomic_always_lock_free(sizeof(__a_), 0);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is_lock_free() const volatile noexcept
    {

    return __c11_atomic_is_lock_free(sizeof(_Tp));



    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is_lock_free() const noexcept
        {return static_cast<__atomic_base const volatile*>(this)->is_lock_free();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {__c11_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {__c11_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp load(memory_order __m = memory_order_seq_cst) const noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    operator _Tp() const volatile noexcept {return load();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    operator _Tp() const noexcept {return load();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))

    __atomic_base() noexcept = default;




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr __atomic_base(_Tp __d) noexcept : __a_(__d) {}

    __atomic_base(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) volatile = delete;






};


template <class _Tp, bool __b>
constexpr bool __atomic_base<_Tp, __b>::is_always_lock_free;




template <class _Tp>
struct __atomic_base<_Tp, true>
    : public __atomic_base<_Tp, false>
{
    typedef __atomic_base<_Tp, false> __base;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __atomic_base() noexcept = default;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr __atomic_base(_Tp __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator++(int) volatile noexcept {return fetch_add(_Tp(1));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator++(int) noexcept {return fetch_add(_Tp(1));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator--(int) volatile noexcept {return fetch_sub(_Tp(1));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator--(int) noexcept {return fetch_sub(_Tp(1));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator++() volatile noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator++() noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator--() volatile noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator--() noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator+=(_Tp __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator+=(_Tp __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator-=(_Tp __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator-=(_Tp __op) noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator&=(_Tp __op) volatile noexcept {return fetch_and(__op) & __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator&=(_Tp __op) noexcept {return fetch_and(__op) & __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator|=(_Tp __op) volatile noexcept {return fetch_or(__op) | __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator|=(_Tp __op) noexcept {return fetch_or(__op) | __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator^=(_Tp __op) volatile noexcept {return fetch_xor(__op) ^ __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator^=(_Tp __op) noexcept {return fetch_xor(__op) ^ __op;}
};



template <class _Tp>
struct atomic
    : public __atomic_base<_Tp>
{
    typedef __atomic_base<_Tp> __base;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    atomic() noexcept = default;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr atomic(_Tp __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator=(_Tp __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator=(_Tp __d) noexcept
        {__base::store(__d); return __d;}
};



template <class _Tp>
struct atomic<_Tp*>
    : public __atomic_base<_Tp*>
{
    typedef __atomic_base<_Tp*> __base;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    atomic() noexcept = default;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr atomic(_Tp* __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator=(_Tp* __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator=(_Tp* __d) noexcept
        {__base::store(__d); return __d;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile noexcept
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile noexcept
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator++(int) volatile noexcept {return fetch_add(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator++(int) noexcept {return fetch_add(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator--(int) volatile noexcept {return fetch_sub(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator--(int) noexcept {return fetch_sub(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator++() volatile noexcept {return fetch_add(1) + 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator++() noexcept {return fetch_add(1) + 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator--() volatile noexcept {return fetch_sub(1) - 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator--() noexcept {return fetch_sub(1) - 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator+=(ptrdiff_t __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator+=(ptrdiff_t __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator-=(ptrdiff_t __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator-=(ptrdiff_t __op) noexcept {return fetch_sub(__op) - __op;}
};



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_is_lock_free(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_is_lock_free(const atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_init(volatile atomic<_Tp>* __o, _Tp __d) noexcept
{
    __c11_atomic_init(&__o->__a_, __d);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_init(atomic<_Tp>* __o, _Tp __d) noexcept
{
    __c11_atomic_init(&__o->__a_, __d);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_store(volatile atomic<_Tp>* __o, _Tp __d) noexcept
{
    __o->store(__d);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_store(atomic<_Tp>* __o, _Tp __d) noexcept
{
    __o->store(__d);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_load(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->load();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_load(const atomic<_Tp>* __o) noexcept
{
    return __o->load();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_exchange(volatile atomic<_Tp>* __o, _Tp __d) noexcept
{
    return __o->exchange(__d);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_exchange(atomic<_Tp>* __o, _Tp __d) noexcept
{
    return __o->exchange(__d);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_exchange_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_exchange_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_weak(atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_strong(atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, _Tp* __e,
                                      _Tp __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, _Tp* __e, _Tp __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
                                        _Tp* __e, _Tp __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, _Tp* __e,
                                        _Tp __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_add(volatile atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_add(atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_add(__op);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
                          memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_add_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_sub(volatile atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_sub(atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_sub(__op);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
                          memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_sub_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_and(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_and(__op);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_or(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_or(__op);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_xor(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_xor(__op);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}



typedef struct atomic_flag
{
    _Atomic(bool) __a_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __c11_atomic_exchange(&__a_, true, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool test_and_set(memory_order __m = memory_order_seq_cst) noexcept
        {return __c11_atomic_exchange(&__a_, true, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear(memory_order __m = memory_order_seq_cst) volatile noexcept
        {__c11_atomic_store(&__a_, false, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear(memory_order __m = memory_order_seq_cst) noexcept
        {__c11_atomic_store(&__a_, false, __m);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))

    atomic_flag() noexcept = default;




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    atomic_flag(bool __b) noexcept : __a_(__b) {}


    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;






} atomic_flag;

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_flag_test_and_set(volatile atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_flag_test_and_set(atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_flag_clear(volatile atomic_flag* __o) noexcept
{
    __o->clear();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_flag_clear(atomic_flag* __o) noexcept
{
    __o->clear();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_thread_fence(memory_order __m) noexcept
{
    __c11_atomic_thread_fence(__m);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_signal_fence(memory_order __m) noexcept
{
    __c11_atomic_signal_fence(__m);
}



typedef atomic<bool> atomic_bool;
typedef atomic<char> atomic_char;
typedef atomic<signed char> atomic_schar;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<short> atomic_short;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<int> atomic_int;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<long> atomic_long;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long long> atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;
typedef atomic<char16_t> atomic_char16_t;
typedef atomic<char32_t> atomic_char32_t;
typedef atomic<wchar_t> atomic_wchar_t;

typedef atomic<int_least8_t> atomic_int_least8_t;
typedef atomic<uint_least8_t> atomic_uint_least8_t;
typedef atomic<int_least16_t> atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t> atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t> atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;

typedef atomic<int_fast8_t> atomic_int_fast8_t;
typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
typedef atomic<int_fast16_t> atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t> atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t> atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;

typedef atomic< int8_t> atomic_int8_t;
typedef atomic<uint8_t> atomic_uint8_t;
typedef atomic< int16_t> atomic_int16_t;
typedef atomic<uint16_t> atomic_uint16_t;
typedef atomic< int32_t> atomic_int32_t;
typedef atomic<uint32_t> atomic_uint32_t;
typedef atomic< int64_t> atomic_int64_t;
typedef atomic<uint64_t> atomic_uint64_t;

typedef atomic<intptr_t> atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t> atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t> atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;




} }
# 659 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 2 3
# 663 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 667 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 2 3


namespace std {inline namespace __1 {

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ValueType __libcpp_relaxed_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 0);



}

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ValueType __libcpp_acquire_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 2);



}



template <class _Tp> class allocator;

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<void>
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<const void>
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};



template <class _Tp, class = void>
struct __has_element_type : false_type {};

template <class _Tp>
struct __has_element_type<_Tp,
              typename __void_t<typename _Tp::element_type>::type> : true_type {};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef typename _Ptr::element_type type;
};



template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
{
    typedef typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
{
    typedef _Tp type;
};
# 807 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template <class _Tp, class = void>
struct __has_difference_type : false_type {};

template <class _Tp>
struct __has_difference_type<_Tp,
            typename __void_t<typename _Tp::difference_type>::type> : true_type {};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{

    typedef typename _Tp::template rebind<_Up> type;



};



template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
{

    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
{
    typedef _Sp<_Up, _Args...> type;
};
# 937 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template <class _Ptr>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;


    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;





private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;


    template <class _Up> using rebind = _Up*;




private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) noexcept
        {return std::__1::addressof(__r);}
};

template <class _From, class _To>
struct __rebind_pointer {

    typedef typename pointer_traits<_From>::template rebind<_To> type;



};



template <class _Tp, class = void>
struct __has_pointer_type : false_type {};

template <class _Tp>
struct __has_pointer_type<_Tp,
          typename __void_t<typename _Tp::pointer>::type> : true_type {};

namespace __pointer_type_imp
{

template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
struct __pointer_type
{
    typedef typename _Dp::pointer type;
};

template <class _Tp, class _Dp>
struct __pointer_type<_Tp, _Dp, false>
{
    typedef _Tp* type;
};

}

template <class _Tp, class _Dp>
struct __pointer_type
{
    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
};

template <class _Tp, class = void>
struct __has_const_pointer : false_type {};

template <class _Tp>
struct __has_const_pointer<_Tp,
            typename __void_t<typename _Tp::const_pointer>::type> : true_type {};

template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer
{
    typedef typename _Alloc::const_pointer type;
};

template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false>
{

    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;



};

template <class _Tp, class = void>
struct __has_void_pointer : false_type {};

template <class _Tp>
struct __has_void_pointer<_Tp,
               typename __void_t<typename _Tp::void_pointer>::type> : true_type {};

template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer
{
    typedef typename _Alloc::void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false>
{

    typedef typename pointer_traits<_Ptr>::template rebind<void> type;



};

template <class _Tp, class = void>
struct __has_const_void_pointer : false_type {};

template <class _Tp>
struct __has_const_void_pointer<_Tp,
            typename __void_t<typename _Tp::const_void_pointer>::type> : true_type {};

template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer
{
    typedef typename _Alloc::const_void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false>
{

    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;



};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
__to_raw_pointer(_Tp* __p) noexcept
{
    return __p;
}

template <class _Pointer>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename pointer_traits<_Pointer>::element_type*
__to_raw_pointer(_Pointer __p) noexcept
{
    return std::__1::__to_raw_pointer(__p.operator->());
}

template <class _Tp, class = void>
struct __has_size_type : false_type {};

template <class _Tp>
struct __has_size_type<_Tp,
               typename __void_t<typename _Tp::size_type>::type> : true_type {};

template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type
{
    typedef typename make_unsigned<_DiffType>::type type;
};

template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true>
{
    typedef typename _Alloc::size_type type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_copy_assignment : false_type {};

template <class _Tp>
struct __has_propagate_on_container_copy_assignment<_Tp,
    typename __void_t<typename _Tp::propagate_on_container_copy_assignment>::type>
        : true_type {};

template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_copy_assignment type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_move_assignment : false_type {};

template <class _Tp>
struct __has_propagate_on_container_move_assignment<_Tp,
           typename __void_t<typename _Tp::propagate_on_container_move_assignment>::type>
               : true_type {};

template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_move_assignment type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_swap : false_type {};

template <class _Tp>
struct __has_propagate_on_container_swap<_Tp,
           typename __void_t<typename _Tp::propagate_on_container_swap>::type>
               : true_type {};

template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_swap type;
};

template <class _Tp, class = void>
struct __has_is_always_equal : false_type {};

template <class _Tp>
struct __has_is_always_equal<_Tp,
           typename __void_t<typename _Tp::is_always_equal>::type>
               : true_type {};

template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal
{
    typedef typename std::__1::is_empty<_Alloc>::type type;
};

template <class _Alloc>
struct __is_always_equal<_Alloc, true>
{
    typedef typename _Alloc::is_always_equal type;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __has_rebind_other
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, false>
{
    static const bool value = false;
};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind
{
    typedef typename _Tp::template rebind<_Up>::other type;
};



template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>
{
    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;
};

template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>
{
    typedef _Alloc<_Up, _Args...> type;
};
# 1302 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto
__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
    -> decltype(__a.allocate(__sz, __p), true_type());

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto
__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
    -> false_type;

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint
    : integral_constant<bool,
        is_same<
            decltype(__has_allocate_hint_test(declval<_Alloc>(),
                                          declval<_SizeType>(),
                                          declval<_ConstVoidPtr>())),
            true_type>::value>
{
};
# 1335 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template <class _Alloc, class _Tp, class ..._Args>
decltype(std::__1::declval<_Alloc>().construct(std::__1::declval<_Tp*>(),
                                           std::__1::declval<_Args>()...),
                                           true_type())
__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);

template <class _Alloc, class _Pointer, class ..._Args>
false_type
__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);

template <class _Alloc, class _Pointer, class ..._Args>
struct __has_construct
    : integral_constant<bool,
        is_same<
            decltype(__has_construct_test(declval<_Alloc>(),
                                          declval<_Pointer>(),
                                          declval<_Args>()...)),
            true_type>::value>
{
};

template <class _Alloc, class _Pointer>
auto
__has_destroy_test(_Alloc&& __a, _Pointer&& __p)
    -> decltype(__a.destroy(__p), true_type());

template <class _Alloc, class _Pointer>
auto
__has_destroy_test(const _Alloc& __a, _Pointer&& __p)
    -> false_type;

template <class _Alloc, class _Pointer>
struct __has_destroy
    : integral_constant<bool,
        is_same<
            decltype(__has_destroy_test(declval<_Alloc>(),
                                        declval<_Pointer>())),
            true_type>::value>
{
};

template <class _Alloc>
auto
__has_max_size_test(_Alloc&& __a)
    -> decltype(__a.max_size(), true_type());

template <class _Alloc>
auto
__has_max_size_test(const volatile _Alloc& __a)
    -> false_type;

template <class _Alloc>
struct __has_max_size
    : integral_constant<bool,
        is_same<
            decltype(__has_max_size_test(declval<_Alloc&>())),
            true_type>::value>
{
};

template <class _Alloc>
auto
__has_select_on_container_copy_construction_test(_Alloc&& __a)
    -> decltype(__a.select_on_container_copy_construction(), true_type());

template <class _Alloc>
auto
__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)
    -> false_type;

template <class _Alloc>
struct __has_select_on_container_copy_construction
    : integral_constant<bool,
        is_same<
            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),
            true_type>::value>
{
};
# 1454 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type
{
    typedef typename pointer_traits<_Ptr>::difference_type type;
};

template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true>
{
    typedef typename _Alloc::difference_type type;
};

template <class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) allocator_traits
{
    typedef _Alloc allocator_type;
    typedef typename allocator_type::value_type value_type;

    typedef typename __pointer_type<value_type, allocator_type>::type pointer;
    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;

    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
    typedef typename __size_type<allocator_type, difference_type>::type size_type;

    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type
                     propagate_on_container_copy_assignment;
    typedef typename __propagate_on_container_move_assignment<allocator_type>::type
                     propagate_on_container_move_assignment;
    typedef typename __propagate_on_container_swap<allocator_type>::type
                     propagate_on_container_swap;
    typedef typename __is_always_equal<allocator_type>::type
                     is_always_equal;


    template <class _Tp> using rebind_alloc =
                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;
    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;







    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n)
        {return __a.allocate(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
        {return __allocate(__a, __n, __hint,
            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept
        {__a.deallocate(__p, __n);}


    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)
            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),
                         __a, __p, std::__1::forward<_Args>(__args)...);}
# 1547 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void destroy(allocator_type& __a, _Tp* __p)
            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type max_size(const allocator_type& __a) noexcept
        {return __max_size(__has_max_size<const allocator_type>(), __a);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(const allocator_type& __a)
            {return __select_on_container_copy_construction(
                __has_select_on_container_copy_construction<const allocator_type>(),
                __a);}

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)
        {
            for (; __begin1 != __end1; ++__begin1, ++__begin2)
                construct(__a, std::__1::__to_raw_pointer(__begin2), std::__1::move_if_noexcept(*__begin1));
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            if (_Np > 0)
            {
                std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
                __begin2 += _Np;
            }
        }

    template <class _Iter, class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)
        {
            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)
                construct(__a, std::__1::__to_raw_pointer(__begin2), *__begin1);
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
        {
            typedef typename remove_const<_Tp>::type _Vp;
            ptrdiff_t _Np = __end1 - __begin1;
            if (_Np > 0)
            {
                std::__1::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));
                __begin2 += _Np;
            }
        }

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)
        {
            while (__end1 != __begin1)
            {
                construct(__a, std::__1::__to_raw_pointer(__end2-1), std::__1::move_if_noexcept(*--__end1));
                --__end2;
            }
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            __end2 -= _Np;
            if (_Np > 0)
                std::__1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
        }

private:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer __allocate(allocator_type& __a, size_type __n,
        const_void_pointer __hint, true_type)
        {return __a.allocate(__n, __hint);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer __allocate(allocator_type& __a, size_type __n,
        const_void_pointer, false_type)
        {return __a.allocate(__n);}


    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)
            {__a.construct(__p, std::__1::forward<_Args>(__args)...);}
    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)
            {
                ::new ((void*)__p) _Tp(std::__1::forward<_Args>(__args)...);
            }


    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(true_type, allocator_type& __a, _Tp* __p)
            {__a.destroy(__p);}
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(false_type, allocator_type&, _Tp* __p)
            {
                __p->~_Tp();
            }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(true_type, const allocator_type& __a)
            {return __a.max_size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(false_type, const allocator_type&)
            {return numeric_limits<size_type>::max() / sizeof(value_type);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        __select_on_container_copy_construction(true_type, const allocator_type& __a)
            {return __a.select_on_container_copy_construction();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        __select_on_container_copy_construction(false_type, const allocator_type& __a)
            {return __a;}
};

template <class _Traits, class _Tp>
struct __rebind_alloc_helper
{

    typedef typename _Traits::template rebind_alloc<_Tp> type;



};



template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;
    typedef _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() noexcept {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) noexcept {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer address(reference __x) const noexcept
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const noexcept
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {
        if (__n > max_size())
            __throw_length_error("allocator<T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) noexcept
        {std::__1::__libcpp_deallocate((void*)__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const noexcept
        {return size_type(~0) / sizeof(_Tp);}

    template <class _Up, class... _Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(_Up* __p, _Args&&... __args)
        {
            ::new((void*)__p) _Up(std::__1::forward<_Args>(__args)...);
        }
# 1814 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator<const _Tp>
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef const _Tp& reference;
    typedef const _Tp& const_reference;
    typedef const _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() noexcept {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) noexcept {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const noexcept
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
    {
        if (__n > max_size())
            __throw_length_error("allocator<const T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) noexcept
        {std::__1::__libcpp_deallocate((void*) const_cast<_Tp *>(__p));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const noexcept
        {return size_type(~0) / sizeof(_Tp);}

    template <class _Up, class... _Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(_Up* __p, _Args&&... __args)
        {
            ::new((void*)__p) _Up(std::__1::forward<_Args>(__args)...);
        }
# 1910 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return true;}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return false;}

template <class _OutputIterator, class _Tp>
class __attribute__ ((__type_visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp,
                      ptrdiff_t,
                      _Tp*,
                      raw_storage_iterator<_OutputIterator, _Tp>&>
{
private:
    _OutputIterator __x_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator=(const _Tp& __element)
        {::new(&*__x_) _Tp(__element); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator=(_Tp&& __element)
        {::new(&*__x_) _Tp(std::__1::move(__element)); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator++() {++__x_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator operator++(int)
        {raw_storage_iterator __t(*this); ++__x_; return __t;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _OutputIterator base() const { return __x_; }

};

template <class _Tp>
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) noexcept
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {
        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void return_temporary_buffer(_Tp* __p) noexcept {::operator delete(__p);}
# 2034 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template <class _Tp, int _Idx,
          bool _CanBeEmptyBase =
              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;


  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr __compressed_pair_elem() : __value_() {}

  template <class _Up, class = typename enable_if<
      !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_(std::__1::forward<_Up>(__u)){};

  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_(std::__1::forward<_Args>(std::__1::get<_Indexes>(__args))...) {}






  __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __get() noexcept { return __value_; }
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  const_reference __get() const noexcept { return __value_; }

private:
  _Tp __value_;
};

template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp __value_type;


  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr __compressed_pair_elem() = default;

  template <class _Up, class = typename enable_if<
        !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_type(std::__1::forward<_Up>(__u)){};

  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_type(std::__1::forward<_Args>(std::__1::get<_Indexes>(__args))...) {}







  __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __get() noexcept { return *this; }
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  const_reference __get() const noexcept { return *this; }
};


struct __second_tag {};

template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                          private __compressed_pair_elem<_T2, 1> {
  typedef __compressed_pair_elem<_T1, 0> _Base1;
  typedef __compressed_pair_elem<_T2, 1> _Base2;





  static_assert((!is_same<_T1, _T2>::value),
    "__compressed_pair cannot be instantated when T1 and T2 are the same type; "
    "The current implementation is NOT ABI-compatible with the previous "
    "implementation for this configuration");

public:

  template <bool _Dummy = true,
      class = typename enable_if<
          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
          __dependent_type<is_default_constructible<_T2>, _Dummy>::value
      >::type
  >
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  constexpr __compressed_pair() {}

  template <class _Tp, typename enable_if<!is_same<typename decay<_Tp>::type,
                                                   __compressed_pair>::value,
                                          bool>::type = true>
  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr explicit
  __compressed_pair(_Tp&& __t)
      : _Base1(std::forward<_Tp>(__t)), _Base2() {}

  template <class _Tp>
  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
  __compressed_pair(__second_tag, _Tp&& __t)
      : _Base1(), _Base2(std::forward<_Tp>(__t)) {}

  template <class _U1, class _U2>
  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
  __compressed_pair(_U1&& __t1, _U2&& __t2)
      : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}

  template <class... _Args1, class... _Args2>
  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                    tuple<_Args2...> __second_args)
      : _Base1(__pc, std::__1::move(__first_args),
               typename __make_tuple_indices<sizeof...(_Args1)>::type()),
        _Base2(__pc, std::__1::move(__second_args),
               typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}
# 2178 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  typename _Base1::reference first() noexcept {
    return static_cast<_Base1&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  typename _Base1::const_reference first() const noexcept {
    return static_cast<_Base1 const&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  typename _Base2::reference second() noexcept {
    return static_cast<_Base2&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  typename _Base2::const_reference second() const noexcept {
    return static_cast<_Base2 const&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  void swap(__compressed_pair& __x)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value)

  {
    using std::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) {

  __x.swap(__y);
}



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete {
    static_assert(!is_function<_Tp>::value,
                  "default_delete cannot be instantiated for function types");

  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr default_delete() noexcept = default;



  template <class _Up>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  default_delete(const default_delete<_Up>&,
                 typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =
                     0) noexcept {}

  __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete incomplete type");
    delete __ptr;
  }
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible
      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};

public:

  __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr default_delete() noexcept = default;




  template <class _Up>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  default_delete(const default_delete<_Up[]>&,
                 typename _EnableIfConvertible<_Up>::type* = 0) noexcept {}

  template <class _Up>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  typename _EnableIfConvertible<_Up>::type
  operator()(_Up* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete void type");
    delete[] __ptr;
  }
};




template <class _Deleter>
struct __unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};


template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__ ((__type_visibility__("default"))) unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;

  static_assert(!is_rvalue_reference<deleter_type>::value,
                "the specified deleter type cannot be an rvalue reference");

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  struct __nat { int __for_bool_; };


  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible = typename enable_if<
      is_convertible<typename _UPtr::pointer, pointer>::value &&
      !is_array<_Up>::value
  >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) {}
# 2416 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }
# 2505 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  ~unique_ptr() { reset(); }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  typename add_lvalue_reference<_Tp>::type
  operator*() const {
    return *__ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  pointer operator->() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  pointer get() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  void reset(pointer __p = pointer()) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};


template <class _Tp, class _Dp>
class __attribute__ ((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};

  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<bool,
          is_same<_FromElem*, pointer>::value ||
            (is_same<pointer, element_type*>::value &&
             is_convertible<_FromElem(*)[], element_type(*)[]>::value)
      >
  {};


  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _Pp>
  using _EnableIfPointerConvertible = typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type;

  template <class _UPtr, class _Up,
        class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible = typename enable_if<
      is_array<_Up>::value &&
      is_same<pointer, element_type*>::value &&
      is_same<typename _UPtr::pointer, _ElemT*>::value &&
      is_convertible<_ElemT(*)[], element_type(*)[]>::value
    >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  explicit unique_ptr(_Pp __p) noexcept
      : __ptr_(__p) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, __d) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) {
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr&
  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }
# 2785 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
public:
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  ~unique_ptr() { reset(); }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  typename add_lvalue_reference<_Tp>::type
  operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  pointer get() const noexcept {
    return __ptr_.first();
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp>
  __attribute__ ((__visibility__("hidden"), __always_inline__))
  typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type
  reset(_Pp __p) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  void reset(nullptr_t = nullptr) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"), __always_inline__))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }

};

template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<
    __is_swappable<_Dp>::value,
    void
>::type
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) noexcept {__x.swap(__y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return __x < nullptr;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(nullptr < __x);
}
# 3009 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template<class _Tp>
struct __unique_if
{
    typedef unique_ptr<_Tp> __unique_single;
};

template<class _Tp>
struct __unique_if<_Tp[]>
{
    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;
};

template<class _Tp, size_t _Np>
struct __unique_if<_Tp[_Np]>
{
    typedef void __unique_array_known_bound;
};

template<class _Tp, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __unique_if<_Tp>::__unique_single
make_unique(_Args&&... __args)
{
    return unique_ptr<_Tp>(new _Tp(std::__1::forward<_Args>(__args)...));
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique(size_t __n)
{
    typedef typename remove_extent<_Tp>::type _Up;
    return unique_ptr<_Tp>(new _Up[__n]());
}

template<class _Tp, class... _Args>
    typename __unique_if<_Tp>::__unique_array_known_bound
    make_unique(_Args&&...) = delete;



template <class _Tp, class _Dp>



struct __attribute__ ((__type_visibility__("default"))) hash<__enable_hash_helper<
    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer>>

{
    typedef unique_ptr<_Tp, _Dp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const
    {
        typedef typename argument_type::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

struct __destruct_n
{
private:
    size_t __size_;

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp* __p, false_type) noexcept
        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp*, true_type) noexcept
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(false_type) noexcept
        {++__size_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(true_type) noexcept
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, false_type) noexcept
        {__size_ = __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t, true_type) noexcept
        {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __destruct_n(size_t __s) noexcept
        : __size_(__s) {}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(_Tp*) noexcept
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, _Tp*) noexcept
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) noexcept
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

template <class _Alloc>
class __allocator_destructor
{
    typedef allocator_traits<_Alloc> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __allocator_destructor(_Alloc& __a, size_type __s)
             noexcept
        : __alloc_(__a), __s_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()(pointer __p) noexcept
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __f != __l; ++__f, (void) ++__r)
            ::new (static_cast<void*>(std::__1::addressof(*__r))) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)
            ::new (static_cast<void*>(std::__1::addressof(*__r))) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __f != __l; ++__f)
            ::new (static_cast<void*>(std::__1::addressof(*__f))) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __n > 0; ++__f, (void) --__n)
            ::new (static_cast<void*>(std::__1::addressof(*__f))) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

    return __f;
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void destroy_at(_Tp* __loc) {
    ((void)0);
    __loc->~_Tp();
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void destroy(_ForwardIterator __first, _ForwardIterator __last) {
    for (; __first != __last; ++__first)
        std::__1::destroy_at(std::__1::addressof(*__first));
}

template <class _ForwardIterator, class _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {
    for (; __n > 0; (void)++__first, --__n)
        std::__1::destroy_at(std::__1::addressof(*__first));
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __idx != __last; ++__idx)
        ::new((void*)std::__1::addressof(*__idx)) _Vt;

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}

template <class _ForwardIterator, class _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __n > 0; (void)++__idx, --__n)
        ::new((void*)std::__1::addressof(*__idx)) _Vt;
    return __idx;

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}


template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __idx != __last; ++__idx)
        ::new((void*)std::__1::addressof(*__idx)) _Vt();

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}

template <class _ForwardIterator, class _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __n > 0; (void)++__idx, --__n)
        ::new((void*)std::__1::addressof(*__idx)) _Vt();
    return __idx;

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}


template <class _InputIt, class _ForwardIt>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {
    using _Vt = typename iterator_traits<_ForwardIt>::value_type;
    auto __idx = __first_res;

    try {

    for (; __first != __last; (void)++__idx, ++__first)
        ::new((void*)std::__1::addressof(*__idx)) _Vt(std::move(*__first));
    return __idx;

    } catch (...) {
        std::__1::destroy(__first_res, __idx);
        throw;
    }

}

template <class _InputIt, class _Size, class _ForwardIt>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIt, _ForwardIt>
uninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {
    using _Vt = typename iterator_traits<_ForwardIt>::value_type;
    auto __idx = __first_res;

    try {

    for (; __n > 0; ++__idx, (void)++__first, --__n)
        ::new((void*)std::__1::addressof(*__idx)) _Vt(std::move(*__first));
    return {__first, __idx};

    } catch (...) {
        std::__1::destroy(__first_res, __idx);
        throw;
    }

}
# 3374 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp
__libcpp_atomic_refcount_increment(_Tp& __t) noexcept
{

    return __atomic_add_fetch(&__t, 1, 0);



}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp
__libcpp_atomic_refcount_decrement(_Tp& __t) noexcept
{

    return __atomic_add_fetch(&__t, -1, 4);



}

class __attribute__ ((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    virtual ~bad_weak_ptr() noexcept;
    virtual const char* what() const noexcept;
};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __throw_bad_weak_ptr()
{

    throw bad_weak_ptr();



}

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) weak_ptr;

class __attribute__ ((__visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() noexcept = 0;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_count(long __refs = 0) noexcept
        : __shared_owners_(__refs) {}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __add_shared() noexcept {
      __libcpp_atomic_refcount_increment(__shared_owners_);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __release_shared() noexcept {
      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
        __on_zero_shared();
        return true;
      }
      return false;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const noexcept {
        return __libcpp_relaxed_load(&__shared_owners_) + 1;
    }
};

class __attribute__ ((__visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_weak_count(long __refs = 0) noexcept
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __add_shared() noexcept {
      __shared_count::__add_shared();
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __add_weak() noexcept {
      __libcpp_atomic_refcount_increment(__shared_weak_owners_);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __release_shared() noexcept {
      if (__shared_count::__release_shared())
        __release_weak();
    }

    void __release_weak() noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const noexcept {return __shared_count::use_count();}
    __shared_weak_count* lock() noexcept;






    virtual const void* __get_deleter(const type_info&) const noexcept;

private:
    virtual void __on_zero_shared_weak() noexcept = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)), std::__1::move(__a)) {}


    virtual const void* __get_deleter(const type_info&) const noexcept;


private:
    virtual void __on_zero_shared() noexcept;
    virtual void __on_zero_shared_weak() noexcept;
};



template <class _Tp, class _Dp, class _Alloc>
const void*
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const noexcept
{
    return __t == typeid(_Dp) ? std::__1::addressof(__data_.first().second()) : nullptr;
}



template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;

    _Al __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Tp, class _Alloc>
class __shared_ptr_emplace
    : public __shared_weak_count
{
    __compressed_pair<_Alloc, _Tp> __data_;
public:


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_emplace(_Alloc __a)
        : __data_(std::__1::move(__a)) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)
            : __data_(piecewise_construct, std::__1::forward_as_tuple(__a),
                   std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...)) {}
# 3598 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
private:
    virtual void __on_zero_shared() noexcept;
    virtual void __on_zero_shared_weak() noexcept;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* get() noexcept {return &__data_.second();}
};

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() noexcept
{
    __data_.second().~_Tp();
}

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
    _Al __a(__data_.first());
    __data_.first().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class __attribute__ ((__type_visibility__("default"))) allocator<__shared_ptr_dummy_rebind_allocator_type>
{
public:
    template <class _Other>
    struct rebind
    {
        typedef allocator<_Other> other;
    };
};

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this;

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) shared_ptr
{
public:
    typedef _Tp element_type;


    typedef weak_ptr<_Tp> weak_type;

private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr shared_ptr() noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr shared_ptr(nullptr_t) noexcept;
    template<class _Yp>
        explicit shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp>
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp, class _Alloc>
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> __attribute__ ((__visibility__("hidden"), __always_inline__)) shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr(const shared_ptr& __r) noexcept;
    template<class _Yp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())
                       noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr(shared_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"), __always_inline__)) shared_ptr(shared_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())
                       noexcept;

    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());
# 3698 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       !is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
# 3737 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
    ~shared_ptr();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr& operator=(const shared_ptr& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator=(const shared_ptr<_Yp>& __r) noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr& operator=(shared_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr<_Tp>&
        >::type
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator=(shared_ptr<_Yp>&& __r);
# 3784 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
    template <class _Yp, class _Dp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type

        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator=(unique_ptr<_Yp, _Dp>&& __r);





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(shared_ptr& __r) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void reset() noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        reset(_Yp* __p);
    template<class _Yp, class _Dp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        reset(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* get() const noexcept {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename add_lvalue_reference<element_type>::type operator*() const noexcept
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* operator->() const noexcept {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const noexcept {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool unique() const noexcept {return use_count() == 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit operator bool() const noexcept {return get() != 0;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(shared_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(weak_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool
    __owner_equivalent(const shared_ptr& __p) const
        {return __cntrl_ == __p.__cntrl_;}


    template <class _Dp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        _Dp* __get_deleter() const noexcept
            {return static_cast<_Dp*>(__cntrl_
                    ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))
                      : nullptr);}




    template<class ..._Args>
        static
        shared_ptr<_Tp>
        make_shared(_Args&& ...__args);

    template<class _Alloc, class ..._Args>
        static
        shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _Args&& ...__args);
# 3906 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
private:
    template <class _Yp, bool = is_function<_Yp>::value>
        struct __shared_ptr_default_allocator
        {
            typedef allocator<_Yp> type;
        };

    template <class _Yp>
        struct __shared_ptr_default_allocator<_Yp, true>
        {
            typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
        };

    template <class _Yp, class _OrigPtr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if<is_convertible<_OrigPtr*,
                                          const enable_shared_from_this<_Yp>*
        >::value,
            void>::type
        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,
                           _OrigPtr* __ptr) noexcept
        {
            typedef typename remove_cv<_Yp>::type _RawYp;
            if (__e && __e->__weak_this_.expired())
            {
                __e->__weak_this_ = shared_ptr<_RawYp>(*this,
                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
            }
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __enable_weak_this(...) noexcept {}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
};


template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr() noexcept
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr(nullptr_t) noexcept
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{
    unique_ptr<_Yp> __hold(__p);
    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, _AllocT > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), _AllocT());
    __hold.release();
    __enable_weak_this(__p, __p);
}

template<class _Tp>
template<class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{

    try
    {

        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
        __enable_weak_this(__p, __p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
    : __ptr_(0)
{

    try
    {

        typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
        typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{

    try
    {

        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(static_cast<void*>(std::__1::addressof(*__hold2.get())))
            _CntrlBlk(__p, __d, __a);
        __cntrl_ = std::__1::addressof(*__hold2.release());
        __enable_weak_this(__p, __p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(0)
{

    try
    {

        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(static_cast<void*>(std::__1::addressof(*__hold2.get())))
            _CntrlBlk(__p, __d, __a);
        __cntrl_ = std::__1::addressof(*__hold2.release());

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) noexcept
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}



template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}
# 4156 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template<class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,



                            typename enable_if
                            <
                                !is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{

    if (__ptr_ == nullptr)
        __cntrl_ = nullptr;
    else

    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,



                            typename enable_if
                            <
                                is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{

    if (__ptr_ == nullptr)
        __cntrl_ = nullptr;
    else

    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*,
                                     reference_wrapper<typename remove_reference<_Dp>::type>,
                                     _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}



template<class _Tp>
template<class ..._Args>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_Args&& ...__args)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a2, std::__1::forward<_Args>(__args)...);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class ..._Args>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new(static_cast<void*>(std::__1::addressof(*__hold2.get())))
        _CntrlBlk(__a, std::__1::forward<_Args>(__args)...);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = std::__1::addressof(*__hold2.release());
    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
    return __r;
}
# 4408 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template<class _Tp>
shared_ptr<_Tp>::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(const shared_ptr& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}



template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(shared_ptr&& __r) noexcept
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}
# 4480 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template<class _Tp>
template <class _Yp, class _Dp>
inline
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                   typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}
# 4533 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template<class _Tp>
inline
void
shared_ptr<_Tp>::swap(shared_ptr& __r) noexcept
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline
void
shared_ptr<_Tp>::reset() noexcept
{
    shared_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
{
    shared_ptr(__p, __d).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
{
    shared_ptr(__p, __d, __a).swap(*this);
}



template<class _Tp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value,
    shared_ptr<_Tp>
>::type
make_shared(_Args&& ...__args)
{
    return shared_ptr<_Tp>::make_shared(std::__1::forward<_Args>(__args)...);
}

template<class _Tp, class _Alloc, class ..._Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value,
    shared_ptr<_Tp>
>::type
allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    return shared_ptr<_Tp>::allocate_shared(__a, std::__1::forward<_Args>(__args)...);
}
# 4683 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __x.get() == __y.get();
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x == __y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    typedef typename common_type<_Tp*, _Up*>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __y < __x;
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__y < __x);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x < __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return less<_Tp*>()(__x.get(), nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return less<_Tp*>()(nullptr, __x.get());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return nullptr < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return __x < nullptr;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    _Tp* __p = dynamic_cast<_Tp*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template<class _Tp, class _Up>
typename enable_if
<
    is_array<_Tp>::value == is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename remove_extent<_Tp>::type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}



template<class _Dp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Dp*
get_deleter(const shared_ptr<_Tp>& __p) noexcept
{
    return __p.template __get_deleter<_Dp>();
}



template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr weak_ptr() noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"), __always_inline__)) weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                        noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    weak_ptr(weak_ptr const& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"), __always_inline__)) weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    weak_ptr(weak_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"), __always_inline__)) weak_ptr(weak_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;

    ~weak_ptr();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    weak_ptr& operator=(weak_ptr const& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator=(weak_ptr<_Yp> const& __r) noexcept;



    __attribute__ ((__visibility__("hidden"), __always_inline__))
    weak_ptr& operator=(weak_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator=(weak_ptr<_Yp>&& __r) noexcept;



    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator=(shared_ptr<_Yp> const& __r) noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(weak_ptr& __r) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void reset() noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const noexcept
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool expired() const noexcept
        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const noexcept;
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const shared_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const weak_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
};

template<class _Tp>
inline
constexpr
weak_ptr<_Tp>::weak_ptr() noexcept
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
                         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}



template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}



template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}



template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr&& __r) noexcept
{
    weak_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) noexcept
{
    weak_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}



template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::swap(weak_ptr& __r) noexcept
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::reset() noexcept
{
    weak_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
{
    if (__cntrl_ == 0)
        __throw_bad_weak_ptr();
}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const noexcept
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}


template <class _Tp = void> struct owner_less;




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<shared_ptr<_Tp> >
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<weak_ptr<_Tp> >
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) owner_less<void>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( shared_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    typedef void is_transparent;
};


template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    enable_shared_from_this() noexcept {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this(enable_shared_from_this const&) noexcept {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept
        {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~enable_shared_from_this() {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    weak_ptr<_Tp> weak_from_this() noexcept
       { return __weak_this_; }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    weak_ptr<const _Tp> weak_from_this() const noexcept
        { return __weak_this_; }


    template <class _Up> friend class shared_ptr;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<shared_ptr<_Tp> >
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const noexcept
    {
        return hash<_Tp*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);




class __attribute__ ((__visibility__("default"))) __sp_mut
{
    void* __lx;
public:
    void lock() noexcept;
    void unlock() noexcept;

private:
    constexpr __sp_mut(void*) noexcept;
    __sp_mut(const __sp_mut&);
    __sp_mut& operator=(const __sp_mut&);

    friend __attribute__ ((__visibility__("default"))) __sp_mut& __get_sp_mut(const void*);
};

__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
__sp_mut& __get_sp_mut(const void*);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_is_lock_free(const shared_ptr<_Tp>*)
{
    return false;
}

template <class _Tp>
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
shared_ptr<_Tp>
atomic_load(const shared_ptr<_Tp>* __p)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    shared_ptr<_Tp> __q = *__p;
    __m.unlock();
    return __q;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
shared_ptr<_Tp>
atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
{
    return atomic_load(__p);
}

template <class _Tp>
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
void
atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
void
atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    atomic_store(__p, __r);
}

template <class _Tp>
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
shared_ptr<_Tp>
atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
shared_ptr<_Tp>
atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    return atomic_exchange(__p, __r);
}

template <class _Tp>
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    shared_ptr<_Tp> __temp;
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    if (__p->__owner_equivalent(*__v))
    {
        std::__1::swap(__temp, *__p);
        *__p = __w;
        __m.unlock();
        return true;
    }
    std::__1::swap(__temp, *__v);
    *__v = *__p;
    __m.unlock();
    return false;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                        shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                      shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_weak(__p, __v, __w);
}
# 5433 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
struct __attribute__ ((__visibility__("default"))) pointer_safety
{
    enum __lx
    {
        relaxed,
        preferred,
        strict
    };

    __lx __v_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer_safety() : __v_() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer_safety(__lx __v) : __v_(__v) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    operator int() const {return __v_;}
};
# 5460 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pointer_safety get_pointer_safety() noexcept {
  return pointer_safety::relaxed;
}




__attribute__ ((__visibility__("default"))) void declare_reachable(void* __p);
__attribute__ ((__visibility__("default"))) void declare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void undeclare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void* __undeclare_reachable(void* __p);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast<_Tp*>(__undeclare_reachable(__p));
}

__attribute__ ((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);


template <typename _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2)

    noexcept



{
    __swap_allocator(__a1, __a2,
      integral_constant<bool, std::__1::allocator_traits<_Alloc>::propagate_on_container_swap::value>());
}

template <typename _Alloc>
__attribute__ ((__visibility__("hidden"), __always_inline__))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)

    noexcept



{
    using std::__1::swap;
    swap(__a1, __a2);
}

template <typename _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __swap_allocator(_Alloc &, _Alloc &, false_type) noexcept {}

template <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >
struct __noexcept_move_assign_container : public integral_constant<bool,
    _Traits::propagate_on_container_move_assignment::value

        || _Traits::is_always_equal::value



    > {};



template <class _Tp, class _Alloc>
struct __temp_value {
    typedef allocator_traits<_Alloc> _Traits;

    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;
    _Alloc &__a;

    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }
    _Tp & get() { return *__addr(); }

    template<class... _Args>
    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)
    { _Traits::construct(__a, __addr(), std::__1::forward<_Args>(__args)...); }

    ~__temp_value() { _Traits::destroy(__a, __addr()); }
    };


} }
# 644 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 2 3
# 658 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 662 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 2 3


namespace std {inline namespace __1 {




template <class _T1, class _T2 = _T1>
struct __equal_to
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1, class _T2 = _T1>
struct __less
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _Predicate>
class __negate
{
private:
    _Predicate __p_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __negate() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __negate(_Predicate __p) : __p_(__p) {}

    template <class _T1>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x) {return !__p_(__x);}

    template <class _T1, class _T2>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}
};
# 790 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned __ctz(unsigned __x) {

    return static_cast<unsigned>(__builtin_ctz(__x));
# 804 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 3
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long __ctz(unsigned long __x) {

    return static_cast<unsigned long>(__builtin_ctzl(__x));




}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long __ctz(unsigned long long __x) {

    return static_cast<unsigned long long>(__builtin_ctzll(__x));
# 839 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 3
}


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned __clz(unsigned __x) {

    return static_cast<unsigned>(__builtin_clz(__x));
# 856 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 3
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long __clz(unsigned long __x) {

    return static_cast<unsigned long>(__builtin_clzl (__x));




}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long __clz(unsigned long long __x) {

    return static_cast<unsigned long long>(__builtin_clzll(__x));
# 889 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 3
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned __x) {

  return __builtin_popcount (__x);




}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long __x) {

  return __builtin_popcountl (__x);




}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long long __x) {

  return __builtin_popcountll(__x);




}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return true;
    return false;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Function>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f)
{
    for (; __first != __last; ++__first)
        __f(*__first);
    return __f;
}




template <class _InputIterator, class _Size, class _Function>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
for_each_n(_InputIterator __first, _Size __orig_n, _Function __f)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    while (__n > 0)
    {
         __f(*__first);
         ++__first;
         --__n;
    }
    return __first;
}




template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            break;
    return __first;
}



template<class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}



template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
           forward_iterator_tag, forward_iterator_tag)
{

    _ForwardIterator1 __r = __last1;
    if (__first2 == __last2)
        return __r;
    while (true)
    {
        while (true)
        {
            if (__first1 == __last1)
                return __r;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
            {
                __r = __first1;
                ++__first1;
                break;
            }
            if (++__m1 == __last1)
                return __r;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>
_BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,
           bidirectional_iterator_tag, bidirectional_iterator_tag)
{

    if (__first2 == __last2)
        return __last1;
    _BidirectionalIterator1 __l1 = __last1;
    _BidirectionalIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {

        while (true)
        {
            if (__first1 == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }

        _BidirectionalIterator1 __m1 = __l1;
        _BidirectionalIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;
            if (__m1 == __first1)
                return __last1;
            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
constexpr _RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{

    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __last1;
    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);
    _RandomAccessIterator1 __l1 = __last1;
    _RandomAccessIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {
        while (true)
        {
            if (__s == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }
        _RandomAccessIterator1 __m1 = __l1;
        _RandomAccessIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;

            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
constexpr _ForwardIterator1
__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1)
        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
            if (__pred(*__first1, *__j))
                return __first1;
    return __last1;
}


template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__first, *__i))
                return __first;
            __first = __i;
        }
    }
    return __last;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
}



template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            ++__r;
    return __r;
}



template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _BinaryPredicate __pred)
{
    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}




template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return true;
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__equal(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,
        input_iterator_tag, input_iterator_tag )
{
    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return __first1 == __last1 && __first2 == __last2;
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
      random_access_iterator_tag, random_access_iterator_tag )
{
    if ( std::__1::distance(__first1, __last1) != std::__1::distance(__first2, __last2))
        return false;
    return std::__1::equal<_RandomAccessIterator1, _RandomAccessIterator2,
                        typename add_lvalue_reference<_BinaryPredicate>::type>
                       (__first1, __last1, __first2, __pred );
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )
{
    return std::__1::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>
       (__first1, __last1, __first2, __last2, __pred,
        typename iterator_traits<_InputIterator1>::iterator_category(),
        typename iterator_traits<_InputIterator2>::iterator_category());
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),
        typename iterator_traits<_InputIterator1>::iterator_category(),
        typename iterator_traits<_InputIterator2>::iterator_category());
}




template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _BinaryPredicate __pred)
{

    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            goto __not_done;
    return true;
__not_done:

    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__1::distance(__first1, __last1);
    if (__l1 == _D1(1))
        return false;
    _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);


    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {

        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
            if (__pred(*__j, *__i))
                goto __next_iter;
        {

            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;

            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
__next_iter:;
    }
    return true;
}

template<class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
bool
__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                 _BinaryPredicate __pred,
                 forward_iterator_tag, forward_iterator_tag )
{

    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            goto __not_done;
    return __first1 == __last1 && __first2 == __last2;
__not_done:

    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__1::distance(__first1, __last1);

    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;
    _D2 __l2 = std::__1::distance(__first2, __last2);
    if (__l1 != __l2)
        return false;



    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {

        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
            if (__pred(*__j, *__i))
                goto __next_iter;
        {

            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;

            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
__next_iter:;
    }
    return true;
}

template<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
bool
__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,
               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,
               _BinaryPredicate __pred,
               random_access_iterator_tag, random_access_iterator_tag )
{
    if ( std::__1::distance(__first1, __last1) != std::__1::distance(__first2, __last2))
        return false;
    return std::__1::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,
                                 typename add_lvalue_reference<_BinaryPredicate>::type>
                                (__first1, __last1, __first2, __pred );
}

template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2,
               _BinaryPredicate __pred )
{
    return std::__1::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>
       (__first1, __last1, __first2, __last2, __pred,
        typename iterator_traits<_ForwardIterator1>::iterator_category(),
        typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template<class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::__is_permutation(__first1, __last1, __first2, __last2,
        __equal_to<__v1, __v2>(),
        typename iterator_traits<_ForwardIterator1>::iterator_category(),
        typename iterator_traits<_ForwardIterator2>::iterator_category());
}




template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
pair<_ForwardIterator1, _ForwardIterator1>
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
         forward_iterator_tag, forward_iterator_tag)
{
    if (__first2 == __last2)
        return make_pair(__first1, __first1);
    while (true)
    {

        while (true)
        {
            if (__first1 == __last1)
                return make_pair(__last1, __last1);
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
                return make_pair(__first1, __m1);
            if (++__m1 == __last1)
                return make_pair(__last1, __last1);
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
constexpr
pair<_RandomAccessIterator1, _RandomAccessIterator1>
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;
    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;

    const _D2 __len2 = __last2 - __first2;
    if (__len2 == 0)
        return make_pair(__first1, __first1);
    const _D1 __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return make_pair(__last1, __last1);
    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);

    while (true)
    {
        while (true)
        {
            if (__first1 == __s)
                return make_pair(__last1, __last1);
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _RandomAccessIterator1 __m1 = __first1;
        _RandomAccessIterator2 __m2 = __first2;
         while (true)
         {
             if (++__m2 == __last2)
                 return make_pair(__first1, __first1 + __len2);
             ++__m1;
             if (!__pred(*__m1, *__m2))
             {
                 ++__first1;
                 break;
             }
         }
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category())
            .first;
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
__search_n(_ForwardIterator __first, _ForwardIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)
{
    if (__count <= 0)
        return __first;
    while (true)
    {

        while (true)
        {
            if (__first == __last)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _ForwardIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
            if (++__m == __last)
                return __last;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>
_RandomAccessIterator
__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)
{
    if (__count <= 0)
        return __first;
    _Size __len = static_cast<_Size>(__last - __first);
    if (__len < __count)
        return __last;
    const _RandomAccessIterator __s = __last - (__count - 1);
    while (true)
    {

        while (true)
        {
            if (__first >= __s)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _RandomAccessIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
             ++__m;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last,
         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)
{
    return std::__1::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>
           (__first, __last, __convert_to_integral(__count), __value_, __pred,
           typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::search_n(__first, __last, __convert_to_integral(__count),
                           __value_, __equal_to<__v, _Tp>());
}


template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Iter
__unwrap_iter(_Iter __i)
{
    return __i;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(move_iterator<_Tp*> __i)
{
    return __i.base();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*> __i)
{
    return __i.base();
}
# 1806 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 3
template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = *__first;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = *--__last;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
    {
        __result -= __n;
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    }
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__copy_backward(__unwrap_iter(__first),
                                  __unwrap_iter(__last),
                                  __unwrap_iter(__result));
}



template<class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_input_iterator<_InputIterator>::value &&
   !__is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    return std::__1::copy(__first, __first + __n, __result);
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = std::__1::move(*__first);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = std::__1::move(*--__last);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
    {
        __result -= __n;
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    }
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}







template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}



template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __value_;
    return __first;
}

template <class _Tp, class _Size, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&
    !is_same<_Tp, bool>::value &&
    is_integral<_Up>::value && sizeof(_Up) == 1,
    _Tp*
>::type
__fill_n(_Tp* __first, _Size __n,_Up __value_)
{
    if (__n > 0)
        std::__1::memset(__first, (unsigned char)__value_, (size_t)(__n));
    return __first + __n;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
   return std::__1::__fill_n(__first, __convert_to_integral(__n), __value_);
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)
{
    std::__1::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    std::__1::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}



template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __gen();
    return __first;
}



template <class _ForwardIterator, class _Tp>
_ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    __first = std::__1::find(__first, __last, __value_);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value_))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _ForwardIterator, class _Predicate>
_ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::__1::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
                           (__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value_))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    __first = std::__1::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
                                 (__first, __last, __pred);
    if (__first != __last)
    {


        _ForwardIterator __i = __first;
        for (++__i; ++__i != __last;)
            if (!__pred(*__first, *__i))
                *++__first = std::__1::move(*__i);
        ++__first;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::unique(__first, __last, __equal_to<__v>());
}



template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(__t, *__first))
            {
                __t = *__first;
                *__result = __t;
                ++__result;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              forward_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        *__result = *__i;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(*__i, *__first))
            {
                *__result = *__first;
                ++__result;
                __i = __first;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
_ForwardIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, forward_iterator_tag)
{
    if (__first != __last)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!__pred(*__result, *__first))
                *++__result = *__first;
        ++__result;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
{
    return std::__1::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
                              (__first, __last, __result, __pred,
                               typename iterator_traits<_InputIterator>::iterator_category(),
                               typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::value_type __v;
    return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
}



template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        std::__1::iter_swap(__first, __last);
        ++__first;
    }
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            std::__1::iter_swap(__first, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    std::__1::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}



template <class _ForwardIterator>
_ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    value_type __tmp = std::__1::move(*__first);
    _ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, __first);
    *__lm1 = std::__1::move(__tmp);
    return __lm1;
}

template <class _BidirectionalIterator>
_BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    _BidirectionalIterator __lm1 = std::__1::prev(__last);
    value_type __tmp = std::__1::move(*__lm1);
    _BidirectionalIterator __fp1 = std::__1::move_backward(__first, __lm1, __last);
    *__first = std::__1::move(__tmp);
    return __fp1;
}

template <class _ForwardIterator>
_ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        swap(*__first, *__i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            swap(*__first, *__i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}

template<typename _Integral>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Integral
__algo_gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}

template<typename _RandomAccessIterator>
_RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;

    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = __last - __middle;
    if (__m1 == __m2)
    {
        std::__1::swap_ranges(__first, __middle, __middle);
        return __middle;
    }
    const difference_type __g = std::__1::__algo_gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(std::__1::move(*--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = std::__1::move(*__p2);
            __p1 = __p2;
            const difference_type __d = __last - __p2;
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::__1::move(__t);
    }
    return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::__1::forward_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_ForwardIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         std::__1::bidirectional_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         std::__1::random_access_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
        return std::__1::__rotate_gcd(__first, __middle, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    if (__first == __middle)
        return __last;
    if (__middle == __last)
        return __first;
    return std::__1::__rotate(__first, __middle, __last,
                           typename std::__1::iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::__1::copy(__first, __middle, std::__1::copy(__middle, __last, __result));
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__i, *__first))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::min_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b)
{
    return std::__1::min(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp
min(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__1::min_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp
min(initializer_list<_Tp> __t)
{
    return *std::__1::min_element(__t.begin(), __t.end(), __less<_Tp>());
}





template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}


template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::max_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b)
{
    return std::__1::max(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp
max(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__1::max_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp
max(initializer_list<_Tp> __t)
{
    return *std::__1::max_element(__t.begin(), __t.end(), __less<_Tp>());
}





template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
clamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
{
    ((void)0);
    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;

}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
clamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)
{
    return std::__1::clamp(__v, __lo, __hi, __less<_Tp>());
}




template <class _ForwardIterator, class _Compare>
constexpr
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last)
  {
      if (++__first != __last)
      {
          if (__comp(*__first, *__result.first))
              __result.first = __first;
          else
              __result.second = __first;
          while (++__first != __last)
          {
              _ForwardIterator __i = __first;
              if (++__first == __last)
              {
                  if (__comp(*__i, *__result.first))
                      __result.first = __i;
                  else if (!__comp(*__i, *__result.second))
                      __result.second = __i;
                  break;
              }
              else
              {
                  if (__comp(*__first, *__i))
                  {
                      if (__comp(*__first, *__result.first))
                          __result.first = __first;
                      if (!__comp(*__i, *__result.second))
                          __result.second = __i;
                  }
                  else
                  {
                      if (__comp(*__i, *__result.first))
                          __result.first = __i;
                      if (!__comp(*__first, *__result.second))
                          __result.second = __first;
                  }
              }
          }
      }
  }
  return __result;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::minmax_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b)
{
    return std::__1::minmax(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t, _Compare __comp)
{
    typedef typename initializer_list<_Tp>::const_iterator _Iter;
    _Iter __first = __t.begin();
    _Iter __last = __t.end();
    std::pair<_Tp, _Tp> __result(*__first, *__first);

    ++__first;
    if (__t.size() % 2 == 0)
    {
        if (__comp(*__first, __result.first))
            __result.first = *__first;
        else
            __result.second = *__first;
        ++__first;
    }

    while (__first != __last)
    {
        _Tp __prev = *__first++;
        if (__comp(*__first, __prev)) {
            if ( __comp(*__first, __result.first)) __result.first = *__first;
            if (!__comp(__prev, __result.second)) __result.second = __prev;
            }
        else {
            if ( __comp(__prev, __result.first)) __result.first = __prev;
            if (!__comp(*__first, __result.second)) __result.second = *__first;
            }

        __first++;
    }
    return __result;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t)
{
    return std::__1::minmax(__t, __less<_Tp>());
}







template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<_Xp, 0>
{
    static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<0, _Rp>
{
    static const size_t value = _Rp + 1;
};

template <class _UIntType, _UIntType _Xp>
struct __log2
{
    static const size_t value = __log2_imp<_Xp,
                                         sizeof(_UIntType) * 8 - 1>::value;
};

template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:

    typedef _UIntType result_type;

private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;

    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;





    static constexpr const _Working_result_type _Rp = _Engine::max() - _Engine::min()
                                                      + _Working_result_type(1);

    static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static constexpr const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static constexpr const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:

    __independent_bits_engine(_Engine& __e, size_t __w);


    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}

private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};

template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}

template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}

template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    const size_t _WRt = numeric_limits<result_type>::digits;
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < _WRt)
            _Sp <<= __w0_;
        else
            _Sp = 0;
        _Sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < _WRt - 1)
            _Sp <<= __w0_ + 1;
        else
            _Sp = 0;
        _Sp += __u & __mask1_;
    }
    return _Sp;
}



template<class _IntType = int>
class uniform_int_distribution
{
public:

    typedef _IntType result_type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}

        result_type a() const {return __a_;}
        result_type b() const {return __b_;}

        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:

    explicit uniform_int_distribution(result_type __a = 0,
                                      result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}
    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    void reset() {}


    template<class _URNG> result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}

    param_type param() const {return __p_;}
    void param(const param_type& __p) {__p_ = __p;}

    result_type min() const {return a();}
    result_type max() const {return b();}

    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};

template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
{
    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                                            uint32_t, uint64_t>::type _UIntType;
    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t _Dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (_Rp == 0)
        return static_cast<result_type>(_Eng(__g, _Dt)());
    size_t __w = _Dt - __clz(_Rp) - 1;
    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= _Rp);
    return static_cast<result_type>(__u + __p.a());
}
# 3209 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 3
template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"), __always_inline__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output,
                         _Distance __n,
                         _UniformRandomNumberGenerator & __g,
                         input_iterator_tag) {

  _Distance __k = 0;
  for (; __first != __last && __k < __n; ++__first, (void)++__k)
    __output[__k] = *__first;
  _Distance __sz = __k;
  for (; __first != __last; ++__first, (void)++__k) {
    _Distance __r = std::__1::uniform_int_distribution<_Distance>(0, __k)(__g);
    if (__r < __sz)
      __output[__r] = *__first;
  }
  return __output + std::__1::min(__n, __k);
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"), __always_inline__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output,
                         _Distance __n,
                         _UniformRandomNumberGenerator& __g,
                         forward_iterator_tag) {
  _Distance __unsampled_sz = std::__1::distance(__first, __last);
  for (__n = std::__1::min(__n, __unsampled_sz); __n != 0; ++__first) {
    _Distance __r =
        std::__1::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
    if (__r < __n) {
      *__output++ = *__first;
      --__n;
    }
  }
  return __output;
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"), __always_inline__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output,
                         _Distance __n, _UniformRandomNumberGenerator& __g) {
  typedef typename iterator_traits<_PopulationIterator>::iterator_category
        _PopCategory;
  typedef typename iterator_traits<_PopulationIterator>::difference_type
        _Difference;
  static_assert(__is_forward_iterator<_PopulationIterator>::value ||
                __is_random_access_iterator<_SampleIterator>::value,
                "SampleIterator must meet the requirements of RandomAccessIterator");
  typedef typename common_type<_Distance, _Difference>::type _CommonType;
  ((void)0);
  return std::__1::__sample(
      __first, __last, __output, _CommonType(__n),
      __g, _PopCategory());
}


template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_SampleIterator sample(_PopulationIterator __first,
                       _PopulationIterator __last, _SampleIterator __output,
                       _Distance __n, _UniformRandomNumberGenerator&& __g) {
    return std::__1::__sample(__first, __last, __output, __n, __g);
}


template<class _RandomAccessIterator, class _UniformRandomNumberGenerator>
    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

                 _UniformRandomNumberGenerator&& __g)



{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _InputIterator, class _Predicate>
bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    if ( __first == __last )
        return true;
    ++__first;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    for (_ForwardIterator __p = __first; ++__p != __last;)
    {
        if (__pred(*__p))
        {
            swap(*__first, *__p);
            ++__first;
        }
    }
    return __first;
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
            bidirectional_iterator_tag)
{
    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return __first;
        } while (!__pred(*__last));
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>
                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}



template<class _ForwardIterator, class _Predicate>
_ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}



template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{


    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }


        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);



    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

struct __return_temporary_buffer
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) const {std::__1::return_temporary_buffer(__p);}
};

template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    difference_type __len = std::__1::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{



    if (__len == 2)
    {
        swap(*__first, *__last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            swap(*__m, *__last);
            return __last;
        }
        swap(*__m, *__last);
        swap(*__first, *__m);
        return __m;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }

        *__first = std::__1::move(*__i);
        __i = ++__first;


        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }


    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:



    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));




    difference_type __len = std::__1::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Compare>
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__1::is_sorted_until(__first, __last, __comp) == __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}





template <class _Compare, class _ForwardIterator>
unsigned
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
{
    unsigned __r = 0;
    if (!__c(*__y, *__x))
    {
        if (!__c(*__z, *__y))
            return __r;

        swap(*__y, *__z);
        __r = 1;
        if (__c(*__y, *__x))
        {
            swap(*__x, *__y);
            __r = 2;
        }
        return __r;
    }
    if (__c(*__z, *__y))
    {
        swap(*__x, *__z);
        __r = 1;
        return __r;
    }
    swap(*__x, *__y);
    __r = 1;
    if (__c(*__z, *__y))
    {
        swap(*__y, *__z);
        __r = 2;
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _Compare __c)
{
    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
    if (__c(*__x4, *__x3))
    {
        swap(*__x3, *__x4);
        ++__r;
        if (__c(*__x3, *__x2))
        {
            swap(*__x2, *__x3);
            ++__r;
            if (__c(*__x2, *__x1))
            {
                swap(*__x1, *__x2);
                ++__r;
            }
        }
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)
{
    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
    if (__c(*__x5, *__x4))
    {
        swap(*__x4, *__x5);
        ++__r;
        if (__c(*__x4, *__x3))
        {
            swap(*__x3, *__x4);
            ++__r;
            if (__c(*__x3, *__x2))
            {
                swap(*__x2, *__x3);
                ++__r;
                if (__c(*__x2, *__x1))
                {
                    swap(*__x1, *__x2);
                    ++__r;
                }
            }
        }
    }
    return __r;
}


template <class _Compare, class _BirdirectionalIterator>
void
__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    _BirdirectionalIterator __lm1 = __last;
    for (--__lm1; __first != __lm1; ++__first)
    {
        _BirdirectionalIterator __i = std::__1::min_element<_BirdirectionalIterator,
                                                        typename add_lvalue_reference<_Compare>::type>
                                                       (__first, __last, __comp);
        if (__i != __first)
            swap(*__first, *__i);
    }
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first != __last)
    {
        _BirdirectionalIterator __i = __first;
        for (++__i; __i != __last; ++__i)
        {
            _BirdirectionalIterator __j = __i;
            value_type __t(std::__1::move(*__j));
            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                *__j = std::__1::move(*__k);
            *__j = std::__1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
        }
        __j = __i;
    }
}

template <class _Compare, class _RandomAccessIterator>
bool
__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    switch (__last - __first)
    {
    case 0:
    case 1:
        return true;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return true;
    case 3:
        std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
        return true;
    case 4:
        std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
        return true;
    case 5:
        std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
        return true;
    }
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    const unsigned __limit = 8;
    unsigned __count = 0;
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
            if (++__count == __limit)
                return ++__i == __last;
        }
        __j = __i;
    }
    return true;
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,
                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first1 != __last1)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
        value_type* __last2 = __first2;
        ::new(__last2) value_type(std::__1::move(*__first1));
        __d.__incr((value_type*)0);
        for (++__last2; ++__first1 != __last1; ++__last2)
        {
            value_type* __j2 = __last2;
            value_type* __i2 = __j2;
            if (__comp(*__first1, *--__i2))
            {
                ::new(__j2) value_type(std::__1::move(*__i2));
                __d.__incr((value_type*)0);
                for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                    *__j2 = std::__1::move(*__i2);
                *__j2 = std::__1::move(*__first1);
            }
            else
            {
                ::new(__j2) value_type(std::__1::move(*__first1));
                __d.__incr((value_type*)0);
            }
        }
        __h.release();
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;
    while (true)
    {
    __restart:
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
            return;
        case 4:
            std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
            return;
        case 5:
            std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
            return;
        }
        if (__len <= __limit)
        {
            std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first;
        _RandomAccessIterator __lm1 = __last;
        --__lm1;
        unsigned __n_swaps;
        {
        difference_type __delta;
        if (__len >= 1000)
        {
            __delta = __len/2;
            __m += __delta;
            __delta /= 2;
            __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
        }
        else
        {
            __delta = __len/2;
            __m += __delta;
            __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
        }
        }



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }



                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }

        ++__i;


        if (__i < __j)
        {


            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i > __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }


        if (__n_swaps == 0)
        {
            bool __fs = std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
            if (std::__1::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
            {
                if (__fs)
                    return;
                __last = __i;
                continue;
            }
            else
            {
                if (__fs)
                {
                    __first = ++__i;
                    continue;
                }
            }
        }

        if (__i - __first < __last - __i)
        {
            std::__1::__sort<_Compare>(__first, __i, __comp);

            __first = ++__i;
        }
        else
        {
            std::__1::__sort<_Compare>(__i+1, __last, __comp);

            __last = __i;
        }
    }
}


template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_Tp** __first, _Tp** __last)
{
    std::__1::sort((size_t*)__first, (size_t*)__last, __less<size_t>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)
{
    std::__1::sort(__first.base(), __last.base());
}

template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    std::__1::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
}

extern template __attribute__ ((__visibility__("default"))) void __sort<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&);



template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::lower_bound(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(__value_, *__m))
            __len = __l2;
        else
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::upper_bound(__first, __last, __value_,
                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else if (__comp(__value_, *__m))
        {
            __last = __m;
            __len = __l2;
        }
        else
        {
            _ForwardIterator __mp1 = __m;
            return pair<_ForwardIterator, _ForwardIterator>
                   (
                      __lower_bound<_Compare>(__first, __m, __value_, __comp),
                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)
                   );
        }
    }
    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::equal_range(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
    return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::binary_search(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
void __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2,
                          _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            std::__1::move(__first1, __last1, __result);
            return;
        }

        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }

}

template <class _Compare, class _BidirectionalIterator>
void
__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        typedef reverse_iterator<_BidirectionalIterator> _RBi;
        typedef reverse_iterator<value_type*> _Rv;
        __half_inplace_merge(_Rv(__p), _Rv(__buff),
                             _RBi(__middle), _RBi(__first),
                             _RBi(__last), __negate<_Compare>(__comp));
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {

        if (__len2 == 0)
            return;
        if (__len1 <= __buff_size || __len2 <= __buff_size)
            return __buffered_inplace_merge<_Compare>
                   (__first, __middle, __last, __comp, __len1, __len2, __buff);

        for (; true; ++__first, (void) --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
# 4607 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/algorithm" 3
        _BidirectionalIterator __m1;
        _BidirectionalIterator __m2;
        difference_type __len11;
        difference_type __len21;

        if (__len1 < __len2)
        {
            __len21 = __len2 / 2;
            __m2 = __middle;
            std::__1::advance(__m2, __len21);
            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
            __len11 = std::__1::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            {

                swap(*__first, *__middle);
                return;
            }

            __len11 = __len1 / 2;
            __m1 = __first;
            std::__1::advance(__m1, __len11);
            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
            __len21 = std::__1::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11;
        difference_type __len22 = __len2 - __len21;


        __middle = std::__1::rotate(__m1, __middle, __m2);


        if (__len11 + __len21 < __len12 + __len22)
        {
            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);

            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);

            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = std::__1::distance(__first, __middle);
    difference_type __len2 = std::__1::distance(__middle, __last);
    difference_type __buf_size = std::__1::min(__len1, __len2);
    pair<value_type*, ptrdiff_t> __buf = std::__1::get_temporary_buffer<value_type>(__buf_size);
    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);







    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
                                            __buf.first, __buf.second);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::__1::inplace_merge(__first, __middle, __last,
                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new (__result) value_type(std::__1::move(*__first2));
            __d.__incr((value_type*)0);
            ++__first2;
        }
        else
        {
            ::new (__result) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first1;
        }
    }
}

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result)
                *__result = std::__1::move(*__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, ++__result)
        *__result = std::__1::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new(__first2) value_type(std::__1::move(*__first1));
        return;
    case 2:
       __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
         if (__comp(*--__last1, *__first1))
        {
            ::new(__first2) value_type(std::__1::move(*__last1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__first1));
        }
        else
        {
            ::new(__first2) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __insertion_sort<_Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)0);
        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)0);
        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);





        return;
    }
    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__buf.first);
    }





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__1::is_heap_until(__first, __last, __comp) == __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
          typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        __len = (__len - 2) / 2;
        _RandomAccessIterator __ptr = __first + __len;
        if (__comp(*__ptr, *--__last))
        {
            value_type __t(std::__1::move(*__last));
            do
            {
                *__last = std::__1::move(*__ptr);
                __last = __ptr;
                if (__len == 0)
                    break;
                __len = (__len - 1) / 2;
                __ptr = __first + __len;
            } while (__comp(*__ptr, __t));
            *__last = std::__1::move(__t);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sift_down(_RandomAccessIterator __first, _RandomAccessIterator ,
            _Compare __comp,
            typename iterator_traits<_RandomAccessIterator>::difference_type __len,
            _RandomAccessIterator __start)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;


    difference_type __child = __start - __first;

    if (__len < 2 || (__len - 2) / 2 < __child)
        return;

    __child = 2 * __child + 1;
    _RandomAccessIterator __child_i = __first + __child;

    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

        ++__child_i;
        ++__child;
    }


    if (__comp(*__child_i, *__start))

        return;

    value_type __top(std::__1::move(*__start));
    do
    {

        *__start = std::__1::move(*__child_i);
        __start = __child_i;

        if ((__len - 2) / 2 < __child)
            break;


        __child = 2 * __child + 1;
        __child_i = __first + __child;

        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

            ++__child_i;
            ++__child;
        }


    } while (!__comp(*__child_i, __top));
    *__start = std::__1::move(__top);
}

template <class _Compare, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
           typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    if (__len > 1)
    {
        swap(*__first, *--__last);
        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __n = __last - __first;
    if (__n > 1)
    {

        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)
        {
            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __make_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)
        __pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    __make_heap<_Compare>(__first, __middle, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)
    {
        if (__comp(*__i, *__first))
        {
            swap(*__i, *__first);
            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);
        }
    }
    __sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::__1::partial_sort(__first, __middle, __last,
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator, class _RandomAccessIterator>
_RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    _RandomAccessIterator __r = __result_first;
    if (__r != __result_last)
    {
        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)
            *__r = *__first;
        __make_heap<_Compare>(__result_first, __r, __comp);
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
        for (; __first != __last; ++__first)
            if (__comp(*__first, *__result_first))
            {
                *__result_first = *__first;
                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);
            }
        __sort_heap<_Compare>(__result_first, __r, __comp);
    }
    return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);

}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::__1::partial_sort_copy(__first, __last, __result_first, __result_last,
                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
    __restart:
        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            __selection_sort<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }


                    if (__nth < __i)
                        return;


                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }
        ++__i;


        if (__i < __j)
        {

            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }

        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {

            if (__nth < __i)
            {

                __j = __m = __first;
                while (++__j != __i)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
            else
            {

                __j = __m = __i;
                while (++__j != __last)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
        }
not_sorted:

        if (__nth < __i)
        {

            __last = __i;
        }
        else
        {

            __first = ++__i;
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
    std::__1::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
           _Compare __comp)
{
    for (; __first2 != __last2; ++__first1)
    {
        if (__first1 == __last1 || __comp(*__first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
         _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::includes(__first1, __last1, __first2, __last2,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_union(_InputIterator1 __first1, _InputIterator1 __last1,
            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            if (!__comp(*__first1, *__first2))
                ++__first2;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_union(__first1, __last1, __first2, __last2, __result,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2)
    {
        if (__comp(*__first1, *__first2))
            ++__first1;
        else
        {
            if (!__comp(*__first2, *__first1))
            {
                *__result = *__first1;
                ++__result;
                ++__first1;
            }
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_intersection(__first1, __last1, __first2, __last2, __result,
                                  __less<typename iterator_traits<_InputIterator1>::value_type,
                                         typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (!__comp(*__first2, *__first1))
                ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_difference(__first1, __last1, __first2, __last2, __result,
                                __less<typename iterator_traits<_InputIterator1>::value_type,
                                       typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__result;
            }
            else
                ++__first1;
            ++__first2;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, (void) ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::lexicographical_compare(__first1, __last1, __first2, __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __next_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::next_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*--__j, *__i))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __prev_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::prev_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

} }
# 57 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__string" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdio" 1 3
# 100 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdio" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdio.h" 1 3
# 101 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdio" 2 3
# 104 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cstdio" 3


namespace std {inline namespace __1 {

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::fclose;
using ::fflush;
using ::setbuf;
using ::setvbuf;
using ::fprintf;
using ::fscanf;
using ::snprintf;
using ::sprintf;
using ::sscanf;
using ::vfprintf;
using ::vfscanf;
using ::vsscanf;
using ::vsnprintf;
using ::vsprintf;
using ::fgetc;
using ::fgets;
using ::fputc;
using ::fputs;
using ::getc;
using ::putc;
using ::ungetc;
using ::fread;
using ::fwrite;
using ::fgetpos;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::rewind;
using ::clearerr;
using ::feof;
using ::ferror;
using ::perror;


using ::fopen;
using ::freopen;
using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;



using ::getchar;



using ::scanf;
using ::vscanf;



using ::printf;
using ::putchar;
using ::puts;
using ::vprintf;


} }
# 58 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__string" 2 3
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__string" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 68 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__string" 2 3


namespace std {inline namespace __1 {



template <class _CharT>
struct __attribute__ ((__type_visibility__("default"))) char_traits
{
    typedef _CharT char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline void constexpr
        assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr
    size_t length(const char_type* __s);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type((-1));}
};

template <class _CharT>
constexpr int
char_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

template <class _CharT>
inline
constexpr size_t
char_traits<_CharT>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

template <class _CharT>
inline
constexpr const _CharT*
char_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

template <class _CharT>
_CharT*
char_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

template <class _CharT>
inline
_CharT*
char_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

template <class _CharT>
inline
_CharT*
char_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char>
{
    typedef char char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
            {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return (unsigned char)__c1 < (unsigned char)__c2;}

    static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    static inline size_t constexpr
    length(const char_type* __s) noexcept {return __builtin_strlen(__s);}
    static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}
    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            ((void)0);
            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);
        }
    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type((unsigned char)__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type((-1));}
};

inline constexpr
int
char_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0)
        return 0;

    return __builtin_memcmp(__s1, __s2, __n);
# 262 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__string" 3
}

inline constexpr
const char*
char_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    if (__n == 0)
        return __null;

    return __builtin_char_memchr(__s, to_int_type(__a), __n);
# 283 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__string" 3
}




template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    static constexpr
    size_t length(const char_type* __s) noexcept;
    static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}
    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            ((void)0);
            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);
        }
    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(((__darwin_wint_t)-1));}
};

inline constexpr
int
char_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0)
        return 0;

    return __builtin_wmemcmp(__s1, __s2, __n);
# 352 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__string" 3
}

inline constexpr
size_t
char_traits<wchar_t>::length(const char_type* __s) noexcept
{

    return __builtin_wcslen(__s);
# 368 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__string" 3
}

inline constexpr
const wchar_t*
char_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    if (__n == 0)
        return __null;

        return __builtin_wmemchr(__s, __a, __n);
# 389 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__string" 3
}




template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char16_t>
{
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr
    size_t length(const char_type* __s) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept;

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(0xFFFF);}
};

inline constexpr
int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline constexpr
size_t
char_traits<char16_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline constexpr
const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline
char16_t*
char_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char16_t*
char_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char16_t*
char_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char32_t>
{
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr
    size_t length(const char_type* __s) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept;

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(0xFFFFFFFF);}
};

inline constexpr
int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline constexpr
size_t
char_traits<char32_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline constexpr
const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline
char32_t*
char_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char32_t*
char_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char32_t*
char_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}






template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find(const _CharT *__p, _SizeT __sz,
             _CharT __c, _SizeT __pos) noexcept
{
    if (__pos >= __sz)
        return __npos;
    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);
    if (__r == 0)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _Traits>
inline constexpr const _CharT *
__search_substring(const _CharT *__first1, const _CharT *__last1,
                   const _CharT *__first2, const _CharT *__last2) {


  const ptrdiff_t __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __first1;

  ptrdiff_t __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;


  _CharT __f2 = *__first2;
  while (true) {
    __len1 = __last1 - __first1;

    if (__len1 < __len2)
      return __last1;


    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
    if (__first1 == 0)
      return __last1;






    if (_Traits::compare(__first1, __first2, __len2) == 0)
      return __first1;

    ++__first1;
  }
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find(const _CharT *__p, _SizeT __sz,
       const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos > __sz)
        return __npos;

    if (__n == 0)
        return __pos;

    const _CharT *__r = __search_substring<_CharT, _Traits>(
        __p + __pos, __p + __sz, __s, __s + __n);

    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}




template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz,
              _CharT __c, _SizeT __pos) noexcept
{
    if (__sz < 1)
        return __npos;
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
    {
        if (_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz,
        const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    __pos = std::__1::min(__pos, __sz);
    if (__n < __sz - __pos)
        __pos += __n;
    else
        __pos = __sz;
    const _CharT* __r = std::__1::__find_end(
                  __p, __p + __pos, __s, __s + __n, _Traits::eq,
                        random_access_iterator_tag(), random_access_iterator_tag());
    if (__n > 0 && __r == __p + __pos)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_first_of(const _CharT *__p, _SizeT __sz,
                const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos >= __sz || __n == 0)
        return __npos;
    const _CharT* __r = std::__1::__find_first_of_ce
        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_last_of(const _CharT *__p, _SizeT __sz,
               const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
    {
    if (__n != 0)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __p;)
        {
            const _CharT* __r = _Traits::find(__s, __n, *--__ps);
            if (__r)
                return static_cast<_SizeT>(__ps - __p);
        }
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                    const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (_Traits::find(__s, __n, *__ps) == 0)
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                          _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (!_Traits::eq(*__ps, __c))
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                   const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (_Traits::find(__s, __n, *--__ps) == 0)
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                         _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (!_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}

template<class _Ptr>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t __do_string_hash(_Ptr __p, _Ptr __e)
{
    typedef typename iterator_traits<_Ptr>::value_type value_type;
    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));
}

template <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >
struct __quoted_output_proxy
{
    _Iter __first;
    _Iter __last;
    _CharT __delim;
    _CharT __escape;

    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)
    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}

};

} }
# 170 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string_view" 2 3
# 178 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string_view" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 182 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string_view" 2 3


namespace std {inline namespace __1 {

template<class _CharT, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) basic_string_view {
public:

 typedef _Traits traits_type;
 typedef _CharT value_type;
 typedef const _CharT* pointer;
 typedef const _CharT* const_pointer;
 typedef const _CharT& reference;
 typedef const _CharT& const_reference;
 typedef const_pointer const_iterator;
 typedef const_iterator iterator;
 typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
 typedef const_reverse_iterator reverse_iterator;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 static constexpr const size_type npos = -1;

    static_assert(is_pod<value_type>::value, "Character type of basic_string_view must be a POD");
    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");


 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 basic_string_view() noexcept : __data (nullptr), __size(0) {}

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 basic_string_view(const basic_string_view&) noexcept = default;

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 basic_string_view& operator=(const basic_string_view&) noexcept = default;

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 basic_string_view(const _CharT* __s, size_type __len)
  : __data(__s), __size(__len)
 {



 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 basic_string_view(const _CharT* __s)
  : __data(__s), __size(_Traits::length(__s)) {}


 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_iterator begin() const noexcept { return cbegin(); }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_iterator end() const noexcept { return cend(); }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_iterator cbegin() const noexcept { return __data; }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_iterator cend() const noexcept { return __data + __size; }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_reverse_iterator rend() const noexcept { return const_reverse_iterator(cbegin()); }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }


 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type size() const noexcept { return __size; }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type length() const noexcept { return __size; }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type max_size() const noexcept { return numeric_limits<size_type>::max(); }

 constexpr bool __attribute__ ((__visibility__("hidden"), __always_inline__))
 empty() const noexcept { return __size == 0; }


 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_reference operator[](size_type __pos) const noexcept { return __data[__pos]; }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_reference at(size_type __pos) const
 {
  return __pos >= size()
   ? (__throw_out_of_range("string_view::at"), __data[0])
   : __data[__pos];
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_reference front() const
 {
  return ((void)0), __data[0];
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_reference back() const
 {
  return ((void)0), __data[__size-1];
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 const_pointer data() const noexcept { return __data; }


 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 void remove_prefix(size_type __n) noexcept
 {
  ((void)0);
  __data += __n;
  __size -= __n;
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 void remove_suffix(size_type __n) noexcept
 {
  ((void)0);
  __size -= __n;
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 void swap(basic_string_view& __other) noexcept
 {
  const value_type *__p = __data;
  __data = __other.__data;
  __other.__data = __p;

  size_type __sz = __size;
  __size = __other.__size;
  __other.__size = __sz;
 }

 __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const
 {
  if (__pos > size())
   __throw_out_of_range("string_view::copy");
  size_type __rlen = std::__1::min(__n, size() - __pos);
  _Traits::copy(__s, data() + __pos, __rlen);
  return __rlen;
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 basic_string_view substr(size_type __pos = 0, size_type __n = npos) const
 {
  return __pos > size()
   ? (__throw_out_of_range("string_view::substr"), basic_string_view())
   : basic_string_view(data() + __pos, std::__1::min(__n, size() - __pos));
 }

 constexpr int compare(basic_string_view __sv) const noexcept
 {
  size_type __rlen = std::__1::min( size(), __sv.size());
  int __retval = _Traits::compare(data(), __sv.data(), __rlen);
  if ( __retval == 0 )
   __retval = size() == __sv.size() ? 0 : ( size() < __sv.size() ? -1 : 1 );
  return __retval;
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 int compare(size_type __pos1, size_type __n1, basic_string_view __sv) const
 {
  return substr(__pos1, __n1).compare(__sv);
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 int compare( size_type __pos1, size_type __n1,
    basic_string_view __sv, size_type __pos2, size_type __n2) const
 {
  return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 int compare(const _CharT* __s) const noexcept
 {
  return compare(basic_string_view(__s));
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 int compare(size_type __pos1, size_type __n1, const _CharT* __s) const
 {
  return substr(__pos1, __n1).compare(basic_string_view(__s));
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 int compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const
 {
  return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
 }


 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find(basic_string_view __s, size_type __pos = 0) const noexcept
 {
  ((void)0);
  return __str_find<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find(_CharT __c, size_type __pos = 0) const noexcept
 {
  return __str_find<value_type, size_type, traits_type, npos>
   (data(), size(), __c, __pos);
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_find<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find(const _CharT* __s, size_type __pos = 0) const
 {
  ((void)0);
  return __str_find<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }


 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type rfind(basic_string_view __s, size_type __pos = npos) const noexcept
 {
  ((void)0);
  return __str_rfind<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type rfind(_CharT __c, size_type __pos = npos) const noexcept
 {
  return __str_rfind<value_type, size_type, traits_type, npos>
   (data(), size(), __c, __pos);
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_rfind<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type rfind(const _CharT* __s, size_type __pos=npos) const
 {
  ((void)0);
  return __str_rfind<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }


 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_first_of(basic_string_view __s, size_type __pos = 0) const noexcept
 {
  ((void)0);
  return __str_find_first_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept
 { return find(__c, __pos); }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_find_first_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_first_of(const _CharT* __s, size_type __pos=0) const
 {
  ((void)0);
  return __str_find_first_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }


 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_last_of(basic_string_view __s, size_type __pos=npos) const noexcept
 {
  ((void)0);
  return __str_find_last_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept
 { return rfind(__c, __pos); }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_find_last_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_last_of(const _CharT* __s, size_type __pos=npos) const
 {
  ((void)0);
  return __str_find_last_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }


 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_first_not_of(basic_string_view __s, size_type __pos=0) const noexcept
 {
  ((void)0);
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_first_not_of(_CharT __c, size_type __pos=0) const noexcept
 {
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __c, __pos);
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_first_not_of(const _CharT* __s, size_type __pos=0) const
 {
  ((void)0);
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }


 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const noexcept
 {
  ((void)0);
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s.data(), __pos, __s.size());
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_last_not_of(_CharT __c, size_type __pos=npos) const noexcept
 {
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __c, __pos);
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
 {
  ((void)0);
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, __n);
 }

 constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
 size_type find_last_not_of(const _CharT* __s, size_type __pos=npos) const
 {
  ((void)0);
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>
   (data(), size(), __s, __pos, traits_type::length(__s));
 }

private:
 const value_type* __data;
 size_type __size;
};




template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(basic_string_view<_CharT, _Traits> __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size()) return false;
 return __lhs.compare(__rhs) == 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size()) return false;
 return __lhs.compare(__rhs) == 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size()) return false;
 return __lhs.compare(__rhs) == 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size())
  return true;
 return __lhs.compare(__rhs) != 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size())
  return true;
 return __lhs.compare(__rhs) != 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 if ( __lhs.size() != __rhs.size())
  return true;
 return __lhs.compare(__rhs) != 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator<(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator<(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) < 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator> (basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) > 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator>(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 return __lhs.compare(__rhs) > 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator>(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) > 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) <= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator<=(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 return __lhs.compare(__rhs) <= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator<=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) <= 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) >= 0;
}


template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator>=(basic_string_view<_CharT, _Traits> __lhs,
    typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
 return __lhs.compare(__rhs) >= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator>=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
    basic_string_view<_CharT, _Traits> __rhs) noexcept
{
 return __lhs.compare(__rhs) >= 0;
}

typedef basic_string_view<char> string_view;
typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;
typedef basic_string_view<wchar_t> wstring_view;


template<class _CharT, class _Traits>
struct __attribute__ ((__type_visibility__("default"))) hash<basic_string_view<_CharT, _Traits> >
    : public unary_function<basic_string_view<_CharT, _Traits>, size_t>
{
    size_t operator()(const basic_string_view<_CharT, _Traits> __val) const noexcept;
};

template<class _CharT, class _Traits>
size_t
hash<basic_string_view<_CharT, _Traits> >::operator()(
        const basic_string_view<_CharT, _Traits> __val) const noexcept
{
    return __do_string_hash(__val.data(), __val.data() + __val.size());
}



inline namespace literals
{
  inline namespace string_view_literals
  {
    inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    basic_string_view<char> operator "" sv(const char *__str, size_t __len)
    {
        return basic_string_view<char> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    basic_string_view<wchar_t> operator "" sv(const wchar_t *__str, size_t __len)
    {
        return basic_string_view<wchar_t> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    basic_string_view<char16_t> operator "" sv(const char16_t *__str, size_t __len)
    {
        return basic_string_view<char16_t> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    basic_string_view<char32_t> operator "" sv(const char32_t *__str, size_t __len)
    {
        return basic_string_view<char32_t> (__str, __len);
    }
  }
}

} }
# 471 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 2 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cwchar" 1 3
# 107 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cwchar" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cwctype" 1 3
# 54 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cwctype" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cctype" 1 3
# 43 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cctype" 3


namespace std {inline namespace __1 {
# 104 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cctype" 3
using ::isalnum;
using ::isalpha;
using ::isblank;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;

} }
# 55 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cwctype" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/wctype.h" 1 3
# 52 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/wctype.h" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wctype.h" 1 3 4
# 36 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wctype.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_wctrans_t.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_wctrans_t.h" 3 4
typedef __darwin_wctrans_t wctrans_t;
# 37 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wctype.h" 2 3 4
# 49 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wctype.h" 3 4
inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}

inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
# 117 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/wctype.h" 3 4
extern "C" {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}
# 55 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/wctype.h" 2 3
# 56 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cwctype" 2 3
# 59 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cwctype" 3


namespace std {inline namespace __1 {

using ::wint_t;
using ::wctrans_t;
using ::wctype_t;
using ::iswalnum;
using ::iswalpha;
using ::iswblank;
using ::iswcntrl;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::iswctype;
using ::wctype;
using ::towlower;
using ::towupper;
using ::towctrans;
using ::wctrans;

} }
# 108 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cwchar" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/wchar.h" 1 3
# 109 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cwchar" 2 3
# 112 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cwchar" 3


namespace std {inline namespace __1 {

using ::mbstate_t;
using ::size_t;
using ::tm;
using ::wint_t;
using ::FILE;
using ::fwprintf;
using ::fwscanf;
using ::swprintf;
using ::vfwprintf;
using ::vswprintf;
using ::swscanf;
using ::vfwscanf;
using ::vswscanf;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::getwc;
using ::putwc;
using ::ungetwc;
using ::wcstod;
using ::wcstof;
using ::wcstold;
using ::wcstol;

using ::wcstoll;

using ::wcstoul;

using ::wcstoull;

using ::wcscpy;
using ::wcsncpy;
using ::wcscat;
using ::wcsncat;
using ::wcscmp;
using ::wcscoll;
using ::wcsncmp;
using ::wcsxfrm;
using ::wcschr;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsstr;
using ::wmemchr;
using ::wcscspn;
using ::wcslen;
using ::wcsspn;
using ::wcstok;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wcsftime;
using ::btowc;
using ::wctob;
using ::mbsinit;
using ::mbrlen;
using ::mbrtowc;
using ::wcrtomb;
using ::mbsrtowcs;
using ::wcsrtombs;


using ::getwchar;
using ::vwscanf;
using ::wscanf;



using ::putwchar;
using ::vwprintf;
using ::wprintf;


} }
# 475 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 2 3
# 491 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 495 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 2 3


namespace std {inline namespace __1 {



template <class _StateT>
class __attribute__ ((__type_visibility__("default"))) fpos
{
private:
    _StateT __st_;
    streamoff __off_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator streamoff() const {return __off_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _StateT state() const {return __st_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void state(_StateT __st) {__st_ = __st;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
};

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) - streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) == streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) != streamoff(__y);}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

extern template __attribute__ ((__visibility__("default"))) string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);

template <bool>
class __attribute__ ((__type_visibility__("default"))) __basic_string_common
{
protected:
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__basic_string_common<__b>::__throw_length_error() const
{
    std::__1::__throw_length_error("basic_string");
}

template <bool __b>
void
__basic_string_common<__b>::__throw_out_of_range() const
{
    std::__1::__throw_out_of_range("basic_string");
}

extern template class __attribute__ ((__visibility__("default"))) __basic_string_common<true>;
# 592 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 3
template <class _Iter, bool = __is_forward_iterator<_Iter>::value>
struct __libcpp_string_gets_noexcept_iterator_impl : public bool_constant<(( noexcept(++(declval<_Iter&>())) && is_nothrow_assignable<_Iter&, _Iter>::value && noexcept(declval<_Iter>() == declval<_Iter>()) && noexcept(*declval<_Iter>())))> {};






template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};



template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator
    : public bool_constant<(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value)> {};

template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view : public bool_constant<(( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value && !is_convertible<const _Tp&, const _CharT*>::value))> {};
# 629 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 3
template<class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_string
    : private __basic_string_common<true>
{
public:
    typedef basic_string __self;
    typedef basic_string_view<_CharT, _Traits> __self_view;
    typedef _Traits traits_type;
    typedef _CharT value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    static_assert(is_pod<value_type>::value, "Character type of basic_string must be a POD");
    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");




    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;

    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
# 696 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 3
    struct __long
    {
        size_type __cap_;
        size_type __size_;
        pointer __data_;
    };





    static const size_type __short_mask = 0x01;
    static const size_type __long_mask = 0x1ul;


    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        union
        {
            unsigned char __size_;
            value_type __lx;
        };
        value_type __data_[__min_cap];
    };



    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long __l;
            __short __s;
            __raw __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;

public:
    static const size_type npos = -1;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit basic_string(const allocator_type& __a)



        noexcept;


    basic_string(const basic_string& __str);
    basic_string(const basic_string& __str, const allocator_type& __a);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(basic_string&& __str)



        noexcept;


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(basic_string&& __str, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string(const _CharT* __s);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const _CharT* __s, const _Allocator& __a);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const _CharT* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(size_type __n, _CharT __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(size_type __n, _CharT __c, const _Allocator& __a);
    basic_string(const basic_string& __str, size_type __pos, size_type __n,
                 const _Allocator& __a = _Allocator());
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const basic_string& __str, size_type __pos,
                 const _Allocator& __a = _Allocator());
    template<class _Tp>
        inline __attribute__ ((__visibility__("hidden")))
        basic_string(const _Tp& __t, size_type __pos, size_type __n,
                     const allocator_type& __a = allocator_type(),
                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit
    basic_string(__self_view __sv);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(__self_view __sv, const _Allocator& __a);
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(initializer_list<_CharT> __il);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);


    inline ~basic_string();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    operator __self_view() const noexcept { return __self_view(data(), size()); }

    basic_string& operator=(const basic_string& __str);


    template <class = void>

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& operator=(__self_view __sv) {return assign(__sv);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& operator=(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
     __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator=(const value_type* __s) {return assign(__s);}
    basic_string& operator=(value_type __c);
# 849 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator begin() noexcept
        {return iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const noexcept
        {return const_iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator end() noexcept
        {return iterator(__get_pointer() + size());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const noexcept
        {return const_iterator(__get_pointer() + size());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const noexcept
        {return begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const noexcept
        {return end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type size() const noexcept
        {return __is_long() ? __get_long_size() : __get_short_size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type length() const noexcept {return size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type capacity() const noexcept
        {return (__is_long() ? __get_long_cap()
                             : static_cast<size_type>(__min_cap)) - 1;}

    void resize(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void resize(size_type __n) {resize(__n, value_type());}

    void reserve(size_type __res_arg = 0);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void shrink_to_fit() noexcept {reserve();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool empty() const noexcept {return size() == 0;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference operator[](size_type __pos) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_type __pos) noexcept;

    const_reference at(size_type __n) const;
    reference at(size_type __n);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(const basic_string& __str) {return append(__str);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(__self_view __sv) {return append(__sv);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(const value_type* __s) {return append(__s);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(value_type __c) {push_back(__c); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& append(const basic_string& __str);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }
    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);
    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >::type
                  append(const _Tp& __t, size_type __pos, size_type __n=npos);
    basic_string& append(const value_type* __s, size_type __n);
    basic_string& append(const value_type* __s);
    basic_string& append(size_type __n, value_type __c);
    template <class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
            __is_exactly_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            basic_string&
        >::type
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    append(_InputIterator __first, _InputIterator __last) {
      const basic_string __temp (__first, __last, __alloc());
      append(__temp.data(), __temp.size());
      return *this;
    }
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value
                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    append(_ForwardIterator __first, _ForwardIterator __last) {
      return __append_forward_unsafe(__first, __last);
    }


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}


    void push_back(value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void pop_back();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference front();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference front() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference back();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference back() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& assign(const basic_string& __str) { return *this = __str; }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& assign(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
        {*this = std::__1::move(__str); return *this;}

    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >::type
                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);
    basic_string& assign(const value_type* __s, size_type __n);
    basic_string& assign(const value_type* __s);
    basic_string& assign(size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
           __is_exactly_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            basic_string&
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value
                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& insert(size_type __pos1, const basic_string& __str);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }
    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >::type
                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
    basic_string& insert(size_type __pos, const value_type* __s);
    basic_string& insert(size_type __pos, size_type __n, value_type __c);
    iterator insert(const_iterator __pos, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const_iterator __pos, size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
           __is_exactly_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value
                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const_iterator __pos, initializer_list<value_type> __il)
                    {return insert(__pos, __il.begin(), __il.end());}


    basic_string& erase(size_type __pos = 0, size_type __n = npos);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __pos);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);
    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >::type
                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    typename enable_if
        <
            __is_input_iterator<_InputIterator>::value,
            basic_string&
        >::type
        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)
        {return replace(__i1, __i2, __il.begin(), __il.end());}


    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string substr(size_type __pos = 0, size_type __n = npos) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_string& __str)

        noexcept;





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_type* c_str() const noexcept {return data();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_type* data() const noexcept {return std::__1::__to_raw_pointer(__get_pointer());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    value_type* data() noexcept {return std::__1::__to_raw_pointer(__get_pointer());}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const noexcept {return __alloc();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find(const basic_string& __str, size_type __pos = 0) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find(__self_view __sv, size_type __pos = 0) const noexcept;
    size_type find(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find(const value_type* __s, size_type __pos = 0) const noexcept;
    size_type find(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type rfind(const basic_string& __str, size_type __pos = npos) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type rfind(__self_view __sv, size_type __pos = 0) const noexcept;
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type rfind(const value_type* __s, size_type __pos = npos) const noexcept;
    size_type rfind(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(__self_view __sv, size_type __pos = 0) const noexcept;
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(__self_view __sv, size_type __pos = 0) const noexcept;
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const noexcept;
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(__self_view __sv, size_type __pos = 0) const noexcept;
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(const basic_string& __str) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(__self_view __sv) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;
    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            int
        >::type
        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;
    int compare(const value_type* __s) const noexcept;
    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool __invariants() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __is_long() const noexcept
        {return bool(__r_.first().__s.__size_ & __short_mask);}
# 1232 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 3
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type& __alloc() noexcept
        {return __r_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const allocator_type& __alloc() const noexcept
        {return __r_.second();}
# 1260 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_short_size(size_type __s) noexcept



        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_short_size() const noexcept



        {return __r_.first().__s.__size_ >> 1;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_size(size_type __s) noexcept
        {__r_.first().__l.__size_ = __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_long_size() const noexcept
        {return __r_.first().__l.__size_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_size(size_type __s) noexcept
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_cap(size_type __s) noexcept
        {__r_.first().__l.__cap_ = __long_mask | __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_long_cap() const noexcept
        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_pointer(pointer __p) noexcept
        {__r_.first().__l.__data_ = __p;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_long_pointer() noexcept
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_long_pointer() const noexcept
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_short_pointer() noexcept
        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_short_pointer() const noexcept
        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_pointer() noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_pointer() const noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __zero() noexcept
        {
            size_type (&__a)[__n_words] = __r_.first().__r.__words;
            for (unsigned __i = 0; __i < __n_words; ++__i)
                __a[__i] = 0;
        }

    template <size_type __a> static
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        size_type __align_it(size_type __s) noexcept
            {return (__s + (__a-1)) & ~(__a-1);}
    enum {__alignment = 16};
    static __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __recommend(size_type __s) noexcept
        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :
                 __align_it<sizeof(value_type) < __alignment ?
                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}

    inline
    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    inline
    void __init(const value_type* __s, size_type __sz);
    inline
    void __init(size_type __n, value_type __c);

    template <class _InputIterator>
    inline
    typename enable_if
    <
        __is_exactly_input_iterator<_InputIterator>::value,
        void
    >::type
    __init(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator>
    inline
    typename enable_if
    <
        __is_forward_iterator<_ForwardIterator>::value,
        void
    >::type
    __init(_ForwardIterator __first, _ForwardIterator __last);

    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy, size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __erase_to_end(size_type __pos);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string& __str)
        {__copy_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string& __str, true_type)
        {
            if (__alloc() == __str.__alloc())
                __alloc() = __str.__alloc();
            else
            {
                if (!__str.__is_long())
                {
                    clear();
                    shrink_to_fit();
                    __alloc() = __str.__alloc();
                }
                else
                {
                    allocator_type __a = __str.__alloc();
                    pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());
                    clear();
                    shrink_to_fit();
                    __alloc() = std::__1::move(__a);
                    __set_long_pointer(__p);
                    __set_long_cap(__str.__get_long_cap());
                    __set_long_size(__str.size());
                }
            }
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string&, false_type) noexcept
        {}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign(basic_string& __str, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign(basic_string& __str, true_type)

        noexcept;





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void
    __move_assign_alloc(basic_string& __str)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


    {__move_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(basic_string& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(basic_string&, false_type)
        noexcept
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_iterators_past(size_type);

    friend basic_string operator+<>(const basic_string&, const basic_string&);
    friend basic_string operator+<>(const value_type*, const basic_string&);
    friend basic_string operator+<>(value_type, const basic_string&);
    friend basic_string operator+<>(const basic_string&, const value_type*);
    friend basic_string operator+<>(const basic_string&, value_type);
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()
{



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type



                                                                      )
{
# 1488 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)



        noexcept

: __r_(__second_tag(), __a)
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,
                                                       size_type __sz,
                                                       size_type __reserve)
{
    if (__reserve > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__reserve < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__reserve);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
{
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)
    : __r_(__second_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string& __str, const allocator_type& __a)
    : __r_(__second_tag(), __a)
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)



        noexcept

    : __r_(std::__1::move(__str.__r_))
{
    __str.__zero();





}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)
    : __r_(__second_tag(), __a)
{
    if (__str.__is_long() && __a != __str.__alloc())
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
    else
    {
        __r_.first().__r = __str.__r_.first().__r;
        __str.__zero();
    }





}



template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
{
    if (__n > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__n < __min_cap)
    {
        __set_short_size(__n);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__n);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__n);
    }
    traits_type::assign(std::__1::__to_raw_pointer(__p), __n, __c);
    traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c, const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str,
                                                        size_type __pos, size_type __n,
                                                        const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,
                                                        const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, __str_sz - __pos);



}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,
    typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)
    : __r_(__second_tag(), __a)
{
 __self_view __sv = __self_view(__t).substr(__pos, __n);
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)
{
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if
<
    __is_exactly_input_iterator<_InputIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
{
    __zero();

    try
    {

    for (; __first != __last; ++__first)
        push_back(*__first);

    }
    catch (...)
    {
        if (__is_long())
            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        throw;
    }

}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    for (; __first != __last; ++__first, (void) ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
{
    __init(__first, __last);



}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
                                                        const allocator_type& __a)
    : __r_(__second_tag(), __a)
{
    __init(__first, __last);



}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<_CharT> __il)
{
    __init(__il.begin(), __il.end());



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<_CharT> __il, const _Allocator& __a)
    : __r_(__second_tag(), __a)
{
    __init(__il.begin(), __il.end());



}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string()
{



    if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
     size_type __n_copy, size_type __n_del, size_type __n_add, const value_type* __p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap - 1)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    if (__n_add != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                     size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del,
                          __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    if (__cap >= __n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        traits_type::move(__p, __s, __n);
        traits_type::assign(__p[__n], value_type());
        __set_size(__n);
        __invalidate_iterators_past(__n);
    }
    else
    {
        size_type __sz = size();
        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
    traits_type::assign(__p, __n, __c);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
        __p = __get_long_pointer();
        __set_long_size(1);
    }
    else
    {
        __p = __get_short_pointer();
        __set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    __invalidate_iterators_past(1);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
{
    if (this != &__str)
    {
        __copy_assign_alloc(__str);
        assign(__str.data(), __str.size());
    }
    return *this;
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__alloc() != __str.__alloc())
        assign(__str);
    else
        __move_assign(__str, true_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)

    noexcept



{
    clear();
    shrink_to_fit();
    __r_.first() = __str.__r_.first();
    __move_assign_alloc(__str);
    __str.__zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__str, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}



template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_exactly_input_iterator <_InputIterator>::value
          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    const basic_string __temp(__first, __last, __alloc());
    assign(__temp.data(), __temp.size());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value
         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    pointer __p = __get_pointer();
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
 basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
{
    ((void)0);
    return assign(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            traits_type::copy(__p + __sz, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        traits_type::assign(std::__1::__to_raw_pointer(__p) + __sz, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
        __cap = __min_cap - 1;
        __sz = __get_short_size();
    }
    else
    {
        __cap = __get_long_cap() - 1;
        __sz = __get_long_size();
    }
    if (__sz == __cap)
    {
        __grow_by(__cap, 1, __sz, __sz, 0);
        __is_short = !__is_long();
    }
    pointer __p;
    if (__is_short)
    {
        __p = __get_short_pointer() + __sz;
        __set_short_size(__sz+1);
    }
    else
    {
        __p = __get_long_pointer() + __sz;
        __set_long_size(__sz+1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}

template <class _Tp>
bool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)
{
    return __first <= __p && __p < __last;
}

template <class _Tp1, class _Tp2>
bool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)
{
    return false;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(
    _ForwardIterator __first, _ForwardIterator __last)
{
    static_assert(__is_forward_iterator<_ForwardIterator>::value,
                  "function requires a ForwardIterator");
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
        _CharRef __tmp_ref = *__first;
        if (__ptr_in_range(std::__1::addressof(__tmp_ref), data(), data() + size()))
        {
            const basic_string __temp (__first, __last, __alloc());
            append(__temp.data(), __temp.size());
        }
        else
        {
            if (__cap - __sz < __n)
                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
            pointer __p = __get_pointer() + __sz;
            for (; __first != __last; ++__p, ++__first)
                traits_type::assign(*__p, *__first);
            traits_type::assign(*__p, value_type());
            __set_size(__sz + __n);
        }
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)
{
    return append(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
    typename enable_if
    <
        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        basic_string<_CharT, _Traits, _Allocator>&
    >::type
basic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __cap = capacity();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
            {
                if (__p + __pos <= __s && __s < __p + __sz)
                    __s += __n;
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
            }
            traits_type::move(__p + __pos, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        traits_type::assign(__p + __pos, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
   __is_exactly_input_iterator<_InputIterator>::value
        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
   typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
{





    const basic_string __temp(__first, __last, __alloc());
    return insert(__pos, __temp.data(), __temp.data() + __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value
        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
{





    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
        _CharRef __tmp_char = *__first;
        if (__ptr_in_range(std::__1::addressof(__tmp_char), data(), data() + size()))
        {
            const basic_string __temp(__first, __last, __alloc());
            return insert(__pos, __temp.data(), __temp.data() + __temp.size());
        }

        size_type __sz = size();
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __ip;
            if (__n_move != 0)
                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
        for (__p += __ip; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
    }
    return begin() + __ip;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)
{
    return insert(__pos1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __str.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
 basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,
                                                  size_type __pos2, size_type __n)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __sv.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
{
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap == __sz)
    {
        __grow_by(__cap, 1, __sz, __ip, 0, 1);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    else
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        size_type __n_move = __sz - __ip;
        if (__n_move != 0)
            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast<difference_type>(__ip);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
{





    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    if (__cap - __sz + __n1 >= __n2)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
            {
                if (__n1 > __n2)
                {
                    traits_type::move(__p + __pos, __s, __n2);
                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    goto __finish;
                }
                if (__p + __pos < __s && __s < __p + __sz)
                {
                    if (__p + __pos + __n1 <= __s)
                        __s += __n2 - __n1;
                    else
                    {
                        traits_type::move(__p + __pos, __s, __n1);
                        __pos += __n1;
                        __s += __n2;
                        __n2 -= __n1;
                        __n1 = 0;
                    }
                }
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
            }
        }
        traits_type::move(__p + __pos, __s, __n2);
__finish:


        __sz += __n2 - __n1;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    else
        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz + __n1 >= __n2)
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        }
    }
    else
    {
        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n2, __c);
    __sz += __n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
    __is_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
                                                   _InputIterator __j1, _InputIterator __j2)
{
    const basic_string __temp(__j1, __j2, __alloc());
    return this->replace(__i1, __i2, __temp);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)
{
    return replace(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if
<
 __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
 basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,
                                                   size_type __pos2, size_type __n2)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __sv.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
{
    ((void)0);
    return replace(__pos, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
                   __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        __n = std::__1::min(__n, __sz - __pos);
        size_type __n_move = __sz - __pos - __n;
        if (__n_move != 0)
            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
        __sz -= __n;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
{





    ((void)0);

    iterator __b = begin();
    size_type __r = static_cast<size_type>(__pos - __b);
    erase(__r, 1);
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
{





    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast<size_type>(__first - __b);
    erase(__r, static_cast<size_type>(__last - __first));
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::pop_back()
{
    ((void)0);
    size_type __sz;
    if (__is_long())
    {
        __sz = __get_long_size() - 1;
        __set_long_size(__sz);
        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
    }
    else
    {
        __sz = __get_short_size() - 1;
        __set_short_size(__sz);
        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
    }
    __invalidate_iterators_past(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::clear() noexcept
{
    __invalidate_all_iterators();
    if (__is_long())
    {
        traits_type::assign(*__get_long_pointer(), value_type());
        __set_long_size(0);
    }
    else
    {
        traits_type::assign(*__get_short_pointer(), value_type());
        __set_short_size(0);
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
{
    if (__is_long())
    {
        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
        __set_long_size(__pos);
    }
    else
    {
        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
        __set_short_size(__pos);
    }
    __invalidate_iterators_past(__pos);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__n > __sz)
        append(__n - __sz, __c);
    else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::max_size() const noexcept
{
    size_type __m = __alloc_traits::max_size(__alloc());



    return __m - __alignment;

}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)
{
    if (__res_arg > max_size())
        this->__throw_length_error();
    size_type __cap = capacity();
    size_type __sz = size();
    __res_arg = std::__1::max(__res_arg, __sz);
    __res_arg = __recommend(__res_arg);
    if (__res_arg != __cap)
    {
        pointer __new_data, __p;
        bool __was_long, __now_long;
        if (__res_arg == __min_cap - 1)
        {
            __was_long = true;
            __now_long = false;
            __new_data = __get_short_pointer();
            __p = __get_long_pointer();
        }
        else
        {
            if (__res_arg > __cap)
                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);
            else
            {

                try
                {

                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);

                }
                catch (...)
                {
                    return;
                }




            }
            __now_long = true;
            __was_long = __is_long();
            __p = __get_pointer();
        }
        traits_type::copy(std::__1::__to_raw_pointer(__new_data),
                          std::__1::__to_raw_pointer(__p), size()+1);
        if (__was_long)
            __alloc_traits::deallocate(__alloc(), __p, __cap+1);
        if (__now_long)
        {
            __set_long_cap(__res_arg+1);
            __set_long_size(__sz);
            __set_long_pointer(__new_data);
        }
        else
            __set_short_size(__sz);
        __invalidate_all_iterators();
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const noexcept
{
    ((void)0);
    return *(data() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) noexcept
{
    ((void)0);
    return *(__get_pointer() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::front()
{
    ((void)0);
    return *__get_pointer();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::front() const
{
    ((void)0);
    return *data();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::back()
{
    ((void)0);
    return *(__get_pointer() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::back() const
{
    ((void)0);
    return *(data() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n, __sz - __pos);
    traits_type::copy(__s, data() + __pos, __rlen);
    return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
{
    return basic_string(*this, __pos, __n, __alloc());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)

        noexcept




{







    ((void)0);



    std::__1::swap(__r_.first(), __str.__r_.first());
    __swap_allocator(__alloc(), __str.__alloc());
}



template <class _Traits>
struct __attribute__ ((__visibility__("hidden"))) __traits_eq
{
    typedef typename _Traits::char_type char_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const char_type& __x, const char_type& __y) noexcept
        {return _Traits::eq(__x, __y);}
};

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos,
                                                size_type __n) const noexcept
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos) const noexcept
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos,
                                                 size_type __n) const noexcept
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
                                                 size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos) const noexcept
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
                                                 size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos,
                                                         size_type __n) const noexcept
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
                                                         size_type __pos) const noexcept
{
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
                                                         size_type __pos) const noexcept
{
    return find(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos,
                                                        size_type __n) const noexcept
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
                                                        size_type __pos) const noexcept
{
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
                                                        size_type __pos) const noexcept
{
    return rfind(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos,
                                                             size_type __n) const noexcept
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
                                                             size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
                                                             size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos,
                                                            size_type __n) const noexcept
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
                                                            size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,
                                                size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
                                                            size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const noexcept
{
    size_t __lhs_sz = size();
    size_t __rhs_sz = __sv.size();
    int __result = traits_type::compare(data(), __sv.data(),
                                        std::__1::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
        return __result;
    if (__lhs_sz < __rhs_sz)
        return -1;
    if (__lhs_sz > __rhs_sz)
        return 1;
    return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const noexcept
{
    return compare(__self_view(__str));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (__pos1 > __sz || __n2 == npos)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n1, __sz - __pos1);
    int __r = traits_type::compare(data() + __pos1, __s, std::__1::min(__rlen, __n2));
    if (__r == 0)
    {
        if (__rlen < __n2)
            __r = -1;
        else if (__rlen > __n2)
            __r = 1;
    }
    return __r;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   __self_view __sv) const
{
    return compare(__pos1, __n1, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str) const
{
    return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if
<
 __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
 int
>::type
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp& __t,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    __self_view __sv = __t;
    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const noexcept
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s) const
{
    ((void)0);
    return compare(__pos1, __n1, __s, traits_type::length(__s));
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const
{
    if (size() > capacity())
        return false;
    if (capacity() < __min_cap - 1)
        return false;
    if (data() == 0)
        return false;
    if (data()[size()] != value_type(0))
        return false;
    return true;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    size_t __lhs_sz = __lhs.size();
    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
                                                        __rhs.data(),
                                                        __lhs_sz) == 0;
}

template<class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) noexcept
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
        return false;
    const char* __lp = __lhs.data();
    const char* __rp = __rhs.data();
    if (__lhs.__is_long())
        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        if (*__lp != *__rp)
            return false;
    return true;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __lhs_len = _Traits::length(__lhs);
    if (__lhs_len != __rhs.size()) return false;
    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __rhs_len = _Traits::length(__rhs);
    if (__rhs_len != __lhs.size()) return false;
    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__lhs == __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs.compare(__lhs) > 0;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs < __lhs;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__rhs < __lhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs < __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(&__lhs, 1, 1 + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs, __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
    __r.push_back(__rhs);
    return __r;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::__1::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    return std::__1::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    __rhs.insert(__rhs.begin(), __lhs);
    return std::__1::move(__rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)
{
    __lhs.push_back(__rhs);
    return std::__1::move(__lhs);
}





template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
     basic_string<_CharT, _Traits, _Allocator>& __rhs)
     noexcept(noexcept(__lhs.swap(__rhs)))
{
    __lhs.swap(__rhs);
}



typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;



__attribute__ ((__visibility__("default"))) int stoi (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const string& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) double stod (const string& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) long double stold(const string& __str, size_t* __idx = 0);

__attribute__ ((__visibility__("default"))) string to_string(int __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned __val);
__attribute__ ((__visibility__("default"))) string to_string(long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long __val);
__attribute__ ((__visibility__("default"))) string to_string(long long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long long __val);
__attribute__ ((__visibility__("default"))) string to_string(float __val);
__attribute__ ((__visibility__("default"))) string to_string(double __val);
__attribute__ ((__visibility__("default"))) string to_string(long double __val);

__attribute__ ((__visibility__("default"))) int stoi (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const wstring& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) double stod (const wstring& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) long double stold(const wstring& __str, size_t* __idx = 0);

__attribute__ ((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(float __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(double __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long double __val);

template<class _CharT, class _Traits, class _Allocator>
    const typename basic_string<_CharT, _Traits, _Allocator>::size_type
                   basic_string<_CharT, _Traits, _Allocator>::npos;

template<class _CharT, class _Traits, class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<basic_string<_CharT, _Traits, _Allocator> >
    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>
{
    size_t
        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const noexcept;
};

template<class _CharT, class _Traits, class _Allocator>
size_t
hash<basic_string<_CharT, _Traits, _Allocator> >::operator()(
        const basic_string<_CharT, _Traits, _Allocator>& __val) const noexcept
{
    return __do_string_hash(__val.data(), __val.data() + __val.size());
}

template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);
# 4002 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string" 3
extern template class __attribute__ ((__visibility__("default"))) basic_string<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_string<wchar_t>;



inline namespace literals
{
  inline namespace string_literals
  {
    inline __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string<char> operator "" s( const char *__str, size_t __len )
    {
        return basic_string<char> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string<wchar_t> operator "" s( const wchar_t *__str, size_t __len )
    {
        return basic_string<wchar_t> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string<char16_t> operator "" s( const char16_t *__str, size_t __len )
    {
        return basic_string<char16_t> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string<char32_t> operator "" s( const char32_t *__str, size_t __len )
    {
        return basic_string<char32_t> (__str, __len);
    }
  }
}


} }
# 16 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/mutex" 1 3
# 191 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/mutex" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__mutex_base" 1 3
# 15 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__mutex_base" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/chrono" 1 3
# 303 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/chrono" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ctime" 1 3
# 52 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ctime" 3


namespace std {inline namespace __1 {

using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;
using ::clock;
using ::difftime;
using ::mktime;
using ::time;

using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;

using ::strftime;

} }
# 304 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/chrono" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ratio" 1 3
# 83 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ratio" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/climits" 1 3
# 42 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/climits" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/limits.h" 1 3
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/limits.h" 3
# 58 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/limits.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/limits.h" 1 3 4
# 37 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/limits.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/limits.h" 1 3 4
# 64 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/limits.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/limits.h" 1 3 4





# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/limits.h" 1 3 4
# 40 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/limits.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/_limits.h" 1 3 4
# 41 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/i386/limits.h" 2 3 4
# 7 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/machine/limits.h" 2 3 4
# 65 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/limits.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/syslimits.h" 1 3 4
# 66 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/limits.h" 2 3 4
# 38 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/limits.h" 2 3 4
# 59 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/limits.h" 2 3
# 43 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/climits" 2 3
# 46 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/climits" 3
# 84 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ratio" 2 3
# 88 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ratio" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 92 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ratio" 2 3


namespace std {inline namespace __1 {



template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
    static const intmax_t value = _Xp;
};

template <>
struct __static_gcd<0, 0>
{
    static const intmax_t value = 1;
};



template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp>
struct __static_abs
{
    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp>
struct __static_sign
{
    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min - _Yp <= _Xp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs<_Xp>::value;
    static const intmax_t __a_y = __static_abs<_Yp>::value;

    static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
public:
    static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
public:
    static const intmax_t value = 0;
};

template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
public:
    static const intmax_t value = 0;
};

template <>
class __ll_mul<0, 0>
{
public:
    static const intmax_t value = 0;
};


template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;

    static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
public:
    static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1>
class __attribute__ ((__type_visibility__("default"))) ratio
{
    static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
    static_assert(_Den != 0, "ratio divide by 0");
    static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
    static constexpr const intmax_t __na = __static_abs<_Num>::value;
    static constexpr const intmax_t __da = __static_abs<_Den>::value;
    static constexpr const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
    static constexpr const intmax_t __gcd = __static_gcd<__na, __da>::value;
public:
    static constexpr const intmax_t num = __s * __na / __gcd;
    static constexpr const intmax_t den = __da / __gcd;

    typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::num;

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::den;

template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2>
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_multiply
                                    = typename __ratio_multiply<_R1, _R2>::type;
# 318 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_divide
                                      = typename __ratio_divide<_R1, _R2>::type;
# 345 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_add
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_add
                                         = typename __ratio_add<_R1, _R2>::type;
# 380 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_sub
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_subtract
                                    = typename __ratio_subtract<_R1, _R2>::type;
# 417 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_equal
    : public bool_constant<((_R1::num == _R2::num && _R1::den == _R2::den))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_not_equal
    : public bool_constant<((!ratio_equal<_R1, _R2>::value))> {};



template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
    static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
    static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
    static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
                                                        intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                            ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
                                intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
    static const bool value = _S1 < _S2;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
    static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less
    : public bool_constant<((__ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less_equal
    : public bool_constant<((!ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater
    : public bool_constant<((ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater_equal
    : public bool_constant<((!ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct __ratio_gcd
{
    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                  __static_lcm<_R1::den, _R2::den>::value> type;
};


template <class _R1, class _R2> constexpr bool ratio_equal_v
    = ratio_equal<_R1, _R2>::value;

template <class _R1, class _R2> constexpr bool ratio_not_equal_v
    = ratio_not_equal<_R1, _R2>::value;

template <class _R1, class _R2> constexpr bool ratio_less_v
    = ratio_less<_R1, _R2>::value;

template <class _R1, class _R2> constexpr bool ratio_less_equal_v
    = ratio_less_equal<_R1, _R2>::value;

template <class _R1, class _R2> constexpr bool ratio_greater_v
    = ratio_greater<_R1, _R2>::value;

template <class _R1, class _R2> constexpr bool ratio_greater_equal_v
    = ratio_greater_equal<_R1, _R2>::value;


} }
# 306 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/chrono" 2 3
# 310 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/chrono" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 314 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/chrono" 2 3


namespace std {inline namespace __1 {

namespace chrono
{

template <class _Rep, class _Period = ratio<1> > class __attribute__ ((__type_visibility__("default"))) duration;

template <class _Tp>
struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};

}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2> >
{
    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                             typename __ratio_gcd<_Period1, _Period2>::type> type;
};

namespace chrono {



template <class _FromDuration, class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)
                                                          / static_cast<_Ct>(_Period::den)));
    }
};

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
duration_cast(const duration<_Rep, _Period>& __fd)
{
    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) treat_as_floating_point : is_floating_point<_Rep> {};


template <class _Rep> constexpr bool treat_as_floating_point_v
    = treat_as_floating_point<_Rep>::value;


template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) duration_values
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr _Rep zero() {return _Rep(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr _Rep max() {return numeric_limits<_Rep>::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr _Rep min() {return numeric_limits<_Rep>::lowest();}
};


template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
floor(const duration<_Rep, _Period>& __d)
{
    _ToDuration __t = duration_cast<_ToDuration>(__d);
    if (__t > __d)
        __t = __t - _ToDuration{1};
    return __t;
}

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
ceil(const duration<_Rep, _Period>& __d)
{
    _ToDuration __t = duration_cast<_ToDuration>(__d);
    if (__t < __d)
        __t = __t + _ToDuration{1};
    return __t;
}

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
round(const duration<_Rep, _Period>& __d)
{
    _ToDuration __lower = floor<_ToDuration>(__d);
    _ToDuration __upper = __lower + _ToDuration{1};
    auto __lowerDiff = __d - __lower;
    auto __upperDiff = __upper - __d;
    if (__lowerDiff < __upperDiff)
        return __lower;
    if (__lowerDiff > __upperDiff)
        return __upper;
    return __lower.count() & 1 ? __upper : __lower;
}




template <class _Rep, class _Period>
class __attribute__ ((__type_visibility__("default"))) duration
{
    static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
    static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
    static_assert(_Period::num > 0, "duration period must be positive");

    template <class _R1, class _R2>
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);

        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
        struct __mul
        {
            static const intmax_t value = _Xp * _Yp;
        };

        template <intmax_t _Xp, intmax_t _Yp>
        struct __mul<_Xp, _Yp, true>
        {
            static const intmax_t value = 1;
        };

    public:
        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
        typedef ratio<__mul<__n1, __d2, !value>::value,
                      __mul<__n2, __d1, !value>::value> type;
    };

public:
    typedef _Rep rep;
    typedef typename _Period::type period;
private:
    rep __rep_;
public:

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr

        duration() = default;




    template <class _Rep2>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        explicit duration(const _Rep2& __r,
            typename enable_if
            <
               is_convertible<_Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<_Rep2>::value)
            >::type* = 0)
                : __rep_(__r) {}


    template <class _Rep2, class _Period2>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        duration(const duration<_Rep2, _Period2>& __d,
            typename enable_if
            <
                __no_overflow<_Period2, period>::value && (
                treat_as_floating_point<rep>::value ||
                (__no_overflow<_Period2, period>::type::den == 1 &&
                 !treat_as_floating_point<_Rep2>::value))
            >::type* = 0)
                : __rep_(std::__1::chrono::duration_cast<duration>(__d).count()) {}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr rep count() const {return __rep_;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr typename common_type<duration>::type operator+() const {return typename common_type<duration>::type(*this);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr typename common_type<duration>::type operator-() const {return typename common_type<duration>::type(-__rep_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr duration& operator++() {++__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr duration operator++(int) {return duration(__rep_++);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr duration& operator--() {--__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr duration operator--(int) {return duration(__rep_--);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr duration zero() {return duration(duration_values<rep>::zero());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr duration min() {return duration(duration_values<rep>::min());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr duration max() {return duration(duration_values<rep>::max());}
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;



template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() == _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() == __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
bool
operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
bool
operator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() < _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() < __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
bool
operator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
bool
operator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
bool
operator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
bool
operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
typename enable_if
<
    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
typename enable_if
<
    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
{
    return __d * __s;
}



template <class _Duration, class _Rep, bool = __is_duration<_Rep>::value>
struct __duration_divide_result
{
};

template <class _Duration, class _Rep2,
    bool = is_convertible<_Rep2,
                          typename common_type<typename _Duration::rep, _Rep2>::type>::value>
struct __duration_divide_imp
{
};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true>
{
    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;
};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>
    : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2>
{
};

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
typename common_type<_Rep1, _Rep2>::type
operator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
    return _Ct(__lhs).count() / _Ct(__rhs).count();
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}





template <class _Clock, class _Duration = typename _Clock::duration>
class __attribute__ ((__type_visibility__("default"))) time_point
{
    static_assert(__is_duration<_Duration>::value,
                  "Second template parameter of time_point must be a std::chrono::duration");
public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr time_point() : __d_(duration::zero()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr explicit time_point(const duration& __d) : __d_(__d) {}


    template <class _Duration2>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    time_point(const time_point<clock, _Duration2>& t,
        typename enable_if
        <
            is_convertible<_Duration2, duration>::value
        >::type* = 0)
            : __d_(t.time_since_epoch()) {}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr duration time_since_epoch() const {return __d_;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr time_point min() {return time_point(duration::min());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr time_point max() {return time_point(duration::max());}
};

}

template <class _Clock, class _Duration1, class _Duration2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::time_point<_Clock, _Duration1>,
                                         chrono::time_point<_Clock, _Duration2> >
{
    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>(std::__1::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}


template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
floor(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{floor<_ToDuration>(__t.time_since_epoch())};
}

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
ceil(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{ceil<_ToDuration>(__t.time_since_epoch())};
}

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
round(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{round<_ToDuration>(__t.time_since_epoch())};
}

template <class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename enable_if
<
    numeric_limits<_Rep>::is_signed,
    duration<_Rep, _Period>
>::type
abs(duration<_Rep, _Period> __d)
{
    return __d >= __d.zero() ? __d : -__d;
}




template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
    return _Tr (__lhs.time_since_epoch() + __rhs);
}



template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs + __lhs;
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;
    return _Ret(__lhs.time_since_epoch() -__rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename common_type<_Duration1, _Duration2>::type
operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}





class __attribute__ ((__visibility__("default"))) system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock> time_point;
    static constexpr const bool is_steady = false;

    static time_point now() noexcept;
    static time_t to_time_t (const time_point& __t) noexcept;
    static time_point from_time_t(time_t __t) noexcept;
};


class __attribute__ ((__visibility__("default"))) steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;
    static constexpr const bool is_steady = true;

    static time_point now() noexcept;
};

typedef steady_clock high_resolution_clock;




}



inline namespace literals
{
  inline namespace chrono_literals
  {

    constexpr chrono::hours operator"" h(unsigned long long __h)
    {
        return chrono::hours(static_cast<chrono::hours::rep>(__h));
    }

    constexpr chrono::duration<long double, ratio<3600,1>> operator"" h(long double __h)
    {
        return chrono::duration<long double, ratio<3600,1>>(__h);
    }


    constexpr chrono::minutes operator"" min(unsigned long long __m)
    {
        return chrono::minutes(static_cast<chrono::minutes::rep>(__m));
    }

    constexpr chrono::duration<long double, ratio<60,1>> operator"" min(long double __m)
    {
        return chrono::duration<long double, ratio<60,1>> (__m);
    }


    constexpr chrono::seconds operator"" s(unsigned long long __s)
    {
        return chrono::seconds(static_cast<chrono::seconds::rep>(__s));
    }

    constexpr chrono::duration<long double> operator"" s(long double __s)
    {
        return chrono::duration<long double> (__s);
    }


    constexpr chrono::milliseconds operator"" ms(unsigned long long __ms)
    {
        return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));
    }

    constexpr chrono::duration<long double, milli> operator"" ms(long double __ms)
    {
        return chrono::duration<long double, milli>(__ms);
    }


    constexpr chrono::microseconds operator"" us(unsigned long long __us)
    {
        return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));
    }

    constexpr chrono::duration<long double, micro> operator"" us(long double __us)
    {
        return chrono::duration<long double, micro> (__us);
    }


    constexpr chrono::nanoseconds operator"" ns(unsigned long long __ns)
    {
        return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));
    }

    constexpr chrono::duration<long double, nano> operator"" ns(long double __ns)
    {
        return chrono::duration<long double, nano> (__ns);
    }

}}

namespace chrono {
   using namespace literals::chrono_literals;
}



} }
# 16 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__mutex_base" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/system_error" 1 3
# 229 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/system_error" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cerrno" 1 3
# 27 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cerrno" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/errno.h" 1 3
# 30 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/errno.h" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/errno.h" 1 3 4
# 23 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/errno.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/errno.h" 1 3 4
# 79 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/errno.h" 3 4
extern "C" {
extern int * __error(void);

}
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/errno.h" 2 3 4
# 33 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/errno.h" 2 3
# 28 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cerrno" 2 3
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cerrno" 3
# 230 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/system_error" 2 3
# 236 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/system_error" 3


namespace std {inline namespace __1 {



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum
    : public false_type {};


template <class _Tp>
constexpr size_t is_error_code_enum_v = is_error_code_enum<_Tp>::value;




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum
    : public false_type {};


template <class _Tp>
constexpr size_t is_error_condition_enum_v = is_error_condition_enum<_Tp>::value;






enum class __attribute__ ((__type_visibility__("default"))) errc
{
    address_family_not_supported = 47,
    address_in_use = 48,
    address_not_available = 49,
    already_connected = 56,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 94,
    broken_pipe = 32,
    connection_aborted = 53,
    connection_already_in_progress = 37,
    connection_refused = 61,
    connection_reset = 54,
    cross_device_link = 18,
    destination_address_required = 39,
    device_or_resource_busy = 16,
    directory_not_empty = 66,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 63,
    function_not_supported = 78,
    host_unreachable = 65,
    identifier_removed = 90,
    illegal_byte_sequence = 92,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 40,
    network_down = 50,
    network_reset = 52,
    network_unreachable = 51,
    no_buffer_space = 55,
    no_child_process = 10,
    no_link = 97,
    no_lock_available = 77,

    no_message_available = 96,



    no_message = 91,
    no_protocol_option = 42,
    no_space_on_device = 28,

    no_stream_resources = 98,



    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 38,

    not_a_stream = 99,



    not_connected = 57,
    not_enough_memory = 12,
    not_supported = 45,
    operation_canceled = 89,
    operation_in_progress = 36,
    operation_not_permitted = 1,
    operation_not_supported = 102,
    operation_would_block = 35,
    owner_dead = 105,
    permission_denied = 13,
    protocol_error = 100,
    protocol_not_supported = 43,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 11,
    resource_unavailable_try_again = 35,
    result_out_of_range = 34,
    state_not_recoverable = 104,

    stream_timeout = 101,



    text_file_busy = 26,
    timed_out = 60,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 62,
    value_too_large = 84,
    wrong_protocol_type = 41
};


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc>
    : true_type { };







class __attribute__ ((__visibility__("default"))) error_condition;
class __attribute__ ((__visibility__("default"))) error_code;



class __attribute__ ((__visibility__("hidden"))) __do_message;

class __attribute__ ((__visibility__("default"))) error_category
{
public:
    virtual ~error_category() noexcept;





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr error_category() noexcept = default;

private:
    error_category(const error_category&);
    error_category& operator=(const error_category&);

public:
    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int __ev) const noexcept;
    virtual bool equivalent(int __code, const error_condition& __condition) const noexcept;
    virtual bool equivalent(const error_code& __code, int __condition) const noexcept;
    virtual string message(int __ev) const = 0;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const error_category& __rhs) const noexcept {return this == &__rhs;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const error_category& __rhs) const noexcept {return !(*this == __rhs);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator< (const error_category& __rhs) const noexcept {return this < &__rhs;}

    friend class __attribute__ ((__visibility__("hidden"))) __do_message;
};

class __attribute__ ((__visibility__("hidden"))) __do_message
    : public error_category
{
public:
    virtual string message(int ev) const;
};

__attribute__ ((__visibility__("default"))) const error_category& generic_category() noexcept;
__attribute__ ((__visibility__("default"))) const error_category& system_category() noexcept;

class __attribute__ ((__visibility__("default"))) error_condition
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition() noexcept : __val_(0), __cat_(&generic_category()) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        error_condition(_Ep __e,
              typename enable_if<is_error_condition_enum<_Ep>::value>::type* = 0
                                                                     ) noexcept
            {*this = make_error_condition(__e);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_error_condition_enum<_Ep>::value,
            error_condition&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_condition(__e); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &generic_category();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int value() const noexcept {return __val_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_category& category() const noexcept {return *__cat_;}
    string message() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit
        operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_condition
make_error_condition(errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}



class __attribute__ ((__visibility__("default"))) error_code
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_code() noexcept : __val_(0), __cat_(&system_category()) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_code(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        error_code(_Ep __e,
                   typename enable_if<is_error_code_enum<_Ep>::value>::type* = 0
                                                                     ) noexcept
            {*this = make_error_code(__e);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_error_code_enum<_Ep>::value,
            error_code&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_code(__e); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &system_category();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int value() const noexcept {return __val_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_category& category() const noexcept {return *__cat_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition default_error_condition() const noexcept
        {return __cat_->default_error_condition(__val_);}

    string message() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit
        operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_code
make_error_code(errc __e) noexcept
{
    return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_code& __x, const error_condition& __y) noexcept
{
    return __x.category().equivalent(__x.value(), __y)
        || __y.category().equivalent(__x, __y.value());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_condition& __x, const error_code& __y) noexcept
{
    return __y == __x;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_code& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_code& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_condition& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_condition& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_code>
    : public unary_function<error_code, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const error_code& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_condition>
    : public unary_function<error_condition, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const error_condition& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};



class __attribute__ ((__visibility__("default"))) system_error
    : public runtime_error
{
    error_code __ec_;
public:
    system_error(error_code __ec, const string& __what_arg);
    system_error(error_code __ec, const char* __what_arg);
    system_error(error_code __ec);
    system_error(int __ev, const error_category& __ecat, const string& __what_arg);
    system_error(int __ev, const error_category& __ecat, const char* __what_arg);
    system_error(int __ev, const error_category& __ecat);
    ~system_error() noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_code& code() const noexcept {return __ec_;}

private:
    static string __init(const error_code&, string);
};

[[noreturn]] __attribute__ ((__visibility__("default")))
void __throw_system_error(int ev, const char* what_arg);

} }
# 17 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__mutex_base" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__threading_support" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__threading_support" 3







# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 1 3 4
# 57 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/pthread_impl.h" 1 3 4
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/pthread_impl.h" 3 4
#pragma clang assume_nonnull begin
#pragma clang assume_nonnull end
# 58 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/sched.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/sched.h" 3 4
extern "C" {




struct sched_param { int sched_priority; char __opaque[4]; };


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 60 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 3 4
typedef __darwin_pthread_cond_t pthread_cond_t;
# 64 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 3 4
typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 65 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 3 4
typedef __darwin_pthread_key_t pthread_key_t;
# 66 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 3 4
typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 67 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 3 4
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 68 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 3 4
typedef __darwin_pthread_once_t pthread_once_t;
# 69 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 3 4
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 70 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 3 4
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 71 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_pthread/_pthread_t.h" 3 4
typedef __darwin_pthread_t pthread_t;
# 72 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/qos.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/qos.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/qos.h" 1 3 4
# 128 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/qos.h" 3 4
typedef enum : unsigned int { QOS_CLASS_USER_INTERACTIVE __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x21, QOS_CLASS_USER_INITIATED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x19, QOS_CLASS_DEFAULT __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x15, QOS_CLASS_UTILITY __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x11, QOS_CLASS_BACKGROUND __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x09, QOS_CLASS_UNSPECIFIED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x00, } qos_class_t;
# 157 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/qos.h" 3 4
extern "C" {
# 168 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
qos_class_t
qos_class_self(void);
# 190 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
qos_class_t
qos_class_main(void);

}
# 35 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/qos.h" 2 3 4




#pragma clang assume_nonnull begin

extern "C" {
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_attr_set_qos_class_np(pthread_attr_t *__attr,
  qos_class_t __qos_class, int __relative_priority);
# 112 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_attr_get_qos_class_np(pthread_attr_t * __attr,
  qos_class_t * _Nullable __qos_class,
  int * _Nullable __relative_priority);
# 153 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_set_qos_class_self_np(qos_class_t __qos_class,
  int __relative_priority);
# 184 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_get_qos_class_np(pthread_t __pthread,
  qos_class_t * _Nullable __qos_class,
  int * _Nullable __relative_priority);
# 211 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/qos.h" 3 4
typedef struct pthread_override_s* pthread_override_t;
# 263 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
  qos_class_t __qos_class, int __relative_priority);
# 291 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_override_qos_class_end_np(pthread_override_t __override);

}
#pragma clang assume_nonnull end
# 74 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_mach_port_t.h" 1 3 4
# 50 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_mach_port_t.h" 3 4
typedef __darwin_mach_port_t mach_port_t;
# 78 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 2 3 4
# 106 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 3 4
#pragma clang assume_nonnull begin

extern "C" {
# 215 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/pthread.h" 3 4
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void),
  void (* _Nullable)(void));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_destroy(pthread_attr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getguardsize(const pthread_attr_t * , size_t * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getinheritsched(const pthread_attr_t * , int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getschedparam(const pthread_attr_t * ,
  struct sched_param * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getschedpolicy(const pthread_attr_t * , int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getscope(const pthread_attr_t * , int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstack(const pthread_attr_t * ,
  void * _Nullable * _Nonnull , size_t * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstackaddr(const pthread_attr_t * ,
  void * _Nullable * _Nonnull );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstacksize(const pthread_attr_t * , size_t * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_init(pthread_attr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setdetachstate(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setguardsize(pthread_attr_t *, size_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setinheritsched(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setschedparam(pthread_attr_t * ,
  const struct sched_param * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setschedpolicy(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setscope(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstackaddr(pthread_attr_t *, void *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstacksize(pthread_attr_t *, size_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cancel(pthread_t) __asm("_" "pthread_cancel" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_broadcast(pthread_cond_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_destroy(pthread_cond_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_init(
  pthread_cond_t * ,
  const pthread_condattr_t * _Nullable )
  __asm("_" "pthread_cond_init" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_signal(pthread_cond_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_timedwait(
  pthread_cond_t * , pthread_mutex_t * ,
  const struct timespec * _Nullable )
  __asm("_" "pthread_cond_timedwait" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_wait(pthread_cond_t * ,
  pthread_mutex_t * ) __asm("_" "pthread_cond_wait" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_destroy(pthread_condattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_init(pthread_condattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_getpshared(const pthread_condattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_setpshared(pthread_condattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))

int pthread_create(pthread_t _Nullable * _Nonnull ,
  const pthread_attr_t * _Nullable ,
  void * _Nullable (* _Nonnull)(void * _Nullable),
  void * _Nullable );






__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_detach(pthread_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_equal(pthread_t _Nullable, pthread_t _Nullable);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void pthread_exit(void * _Nullable) __attribute__((noreturn));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_getconcurrency(void);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_getschedparam(pthread_t , int * _Nullable ,
  struct sched_param * _Nullable );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void* _Nullable pthread_getspecific(pthread_key_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_join(pthread_t , void * _Nullable * _Nullable)
  __asm("_" "pthread_join" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_key_create(pthread_key_t *, void (* _Nullable)(void *));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_key_delete(pthread_key_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_destroy(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_getprioceiling(const pthread_mutex_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_init(pthread_mutex_t * ,
  const pthread_mutexattr_t * _Nullable );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_lock(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_setprioceiling(pthread_mutex_t * , int,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_trylock(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_unlock(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_gettype(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_init(pthread_mutexattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);

__attribute__((availability(swift,unavailable,message="Use lazily initialized globals instead")))
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_once(pthread_once_t *, void (* _Nonnull)(void));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_init(pthread_rwlock_t * ,
  const pthread_rwlockattr_t * _Nullable )
  __asm("_" "pthread_rwlock_init" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_init(pthread_rwlockattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
pthread_t pthread_self(void);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setcancelstate(int , int * _Nullable)
  __asm("_" "pthread_setcancelstate" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setcanceltype(int , int * _Nullable)
  __asm("_" "pthread_setcanceltype" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setconcurrency(int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setschedparam(pthread_t, int, const struct sched_param *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setspecific(pthread_key_t , const void * _Nullable);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void pthread_testcancel(void) __asm("_" "pthread_testcancel" );




__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_is_threaded_np(void);

__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
int pthread_threadid_np(pthread_t _Nullable,__uint64_t* _Nullable);


__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
int pthread_getname_np(pthread_t,char*,size_t);

__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
int pthread_setname_np(const char*);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_main_np(void);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
mach_port_t pthread_mach_thread_np(pthread_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
size_t pthread_get_stacksize_np(pthread_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void* pthread_get_stackaddr_np(pthread_t);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t _Nullable);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
  const struct timespec * _Nullable);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))

int pthread_create_suspended_np(
  pthread_t _Nullable * _Nonnull, const pthread_attr_t * _Nullable,
  void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable);





__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_kill(pthread_t, int);

__attribute__((availability(macos,introduced=10.5))) __attribute__((availability(ios,introduced=2.0)))
_Nullable pthread_t pthread_from_mach_thread_np(mach_port_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
  __asm("_" "pthread_sigmask" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void pthread_yield_np(void);


}
#pragma clang assume_nonnull end
# 28 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__threading_support" 2 3








# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 37 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__threading_support" 2 3
# 52 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__threading_support" 3
namespace std {inline namespace __1 {



typedef pthread_mutex_t __libcpp_mutex_t;


typedef pthread_mutex_t __libcpp_recursive_mutex_t;


typedef pthread_cond_t __libcpp_condvar_t;



typedef pthread_once_t __libcpp_exec_once_flag;



typedef pthread_t __libcpp_thread_id;




typedef pthread_t __libcpp_thread_t;


typedef pthread_key_t __libcpp_tls_key;
# 111 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__threading_support" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_mutex_lock(__libcpp_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_mutex_unlock(__libcpp_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_mutex_destroy(__libcpp_mutex_t *__m);


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_condvar_signal(__libcpp_condvar_t* __cv);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_condvar_broadcast(__libcpp_condvar_t* __cv);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_condvar_wait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               timespec *__ts);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_condvar_destroy(__libcpp_condvar_t* __cv);


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
                          void (*init_routine)(void));


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2);


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool __libcpp_thread_isnull(const __libcpp_thread_t *__t);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__libcpp_thread_id __libcpp_thread_get_current_id();

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_thread_join(__libcpp_thread_t *__t);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_thread_detach(__libcpp_thread_t *__t);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __libcpp_thread_yield();

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns);


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_tls_create(__libcpp_tls_key* __key,
                        void(* __at_exit)(void*));

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void *__libcpp_tls_get(__libcpp_tls_key __key);

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __libcpp_tls_set(__libcpp_tls_key __key, void *__p);






int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m)
{
  pthread_mutexattr_t attr;
  int __ec = pthread_mutexattr_init(&attr);
  if (__ec)
    return __ec;
  __ec = pthread_mutexattr_settype(&attr, 2);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutex_init(__m, &attr);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutexattr_destroy(&attr);
  if (__ec) {
    pthread_mutex_destroy(__m);
    return __ec;
  }
  return 0;
}

int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}

bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_recursive_mutex_unlock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}

int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}

int __libcpp_mutex_lock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}

bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_mutex_unlock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}

int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}


int __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
{
  return pthread_cond_signal(__cv);
}

int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv)
{
  return pthread_cond_broadcast(__cv);
}

int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m)
{
  return pthread_cond_wait(__cv, __m);
}

int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               timespec *__ts)
{
  return pthread_cond_timedwait(__cv, __m, __ts);
}

int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
{
  return pthread_cond_destroy(__cv);
}


int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
                          void (*init_routine)(void)) {
  return pthread_once(flag, init_routine);
}



bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2)
{
  return pthread_equal(t1, t2) != 0;
}


bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2)
{
  return t1 < t2;
}


bool __libcpp_thread_isnull(const __libcpp_thread_t *__t) {
  return *__t == 0;
}

int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg)
{
  return pthread_create(__t, 0, __func, __arg);
}

__libcpp_thread_id __libcpp_thread_get_current_id()
{
  return pthread_self();
}

__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
{
  return *__t;
}

int __libcpp_thread_join(__libcpp_thread_t *__t)
{
  return pthread_join(*__t, 0);
}

int __libcpp_thread_detach(__libcpp_thread_t *__t)
{
  return pthread_detach(*__t);
}

void __libcpp_thread_yield()
{
  sched_yield();
}

void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns)
{
   using namespace chrono;
   seconds __s = duration_cast<seconds>(__ns);
   timespec __ts;
   typedef decltype(__ts.tv_sec) ts_sec;
   constexpr ts_sec __ts_sec_max = numeric_limits<ts_sec>::max();

   if (__s.count() < __ts_sec_max)
   {
     __ts.tv_sec = static_cast<ts_sec>(__s.count());
     __ts.tv_nsec = static_cast<decltype(__ts.tv_nsec)>((__ns - __s).count());
   }
   else
   {
     __ts.tv_sec = __ts_sec_max;
     __ts.tv_nsec = 999999999;
   }

   while (nanosleep(&__ts, &__ts) == -1 && (*__error()) == 4);
}


int __libcpp_tls_create(__libcpp_tls_key *__key, void (*__at_exit)(void *))
{
  return pthread_key_create(__key, __at_exit);
}

void *__libcpp_tls_get(__libcpp_tls_key __key)
{
  return pthread_getspecific(__key);
}

int __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
{
    return pthread_setspecific(__key, __p);
}
# 633 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__threading_support" 3
} }
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__mutex_base" 2 3
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__mutex_base" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__mutex_base" 2 3


namespace std {inline namespace __1 {
# 40 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__mutex_base" 3
class __attribute__ ((__visibility__("default"))) mutex
{

    __libcpp_mutex_t __m_ = {0x32AAABA7, {0}};




public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))

    constexpr mutex() = default;



    ~mutex();

private:
    mutex(const mutex&);
    mutex& operator=(const mutex&);

public:
    void lock() ;
    bool try_lock() noexcept ;
    void unlock() noexcept ;

    typedef __libcpp_mutex_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) native_handle_type native_handle() {return &__m_;}
};

static_assert(is_nothrow_default_constructible<mutex>::value,
              "the default constructor for std::mutex must be nothrow");

struct __attribute__ ((__visibility__("default"))) defer_lock_t {};
struct __attribute__ ((__visibility__("default"))) try_to_lock_t {};
struct __attribute__ ((__visibility__("default"))) adopt_lock_t {};
# 85 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__mutex_base" 3
constexpr defer_lock_t defer_lock = defer_lock_t();
constexpr try_to_lock_t try_to_lock = try_to_lock_t();
constexpr adopt_lock_t adopt_lock = adopt_lock_t();



template <class _Mutex>
class __attribute__ ((__type_visibility__("default")))
lock_guard
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type& __m_;
public:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit lock_guard(mutex_type& __m)
        : __m_(__m) {__m_.lock();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    lock_guard(mutex_type& __m, adopt_lock_t)
        : __m_(__m) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~lock_guard() {__m_.unlock();}

private:
    lock_guard(lock_guard const&) = delete;
    lock_guard& operator=(lock_guard const&) = delete;
};

template <class _Mutex>
class __attribute__ ((__type_visibility__("default"))) unique_lock
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type* __m_;
    bool __owns_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock() noexcept : __m_(nullptr), __owns_(false) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit unique_lock(mutex_type& __m)
        : __m_(std::__1::addressof(__m)), __owns_(true) {__m_->lock();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, defer_lock_t) noexcept
        : __m_(std::__1::addressof(__m)), __owns_(false) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, try_to_lock_t)
        : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, adopt_lock_t)
        : __m_(std::__1::addressof(__m)), __owns_(true) {}
    template <class _Clock, class _Duration>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __t)
            : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_until(__t)) {}
    template <class _Rep, class _Period>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        unique_lock(mutex_type& __m, const chrono::duration<_Rep, _Period>& __d)
            : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_for(__d)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~unique_lock()
    {
        if (__owns_)
            __m_->unlock();
    }

private:
    unique_lock(unique_lock const&);
    unique_lock& operator=(unique_lock const&);

public:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(unique_lock&& __u) noexcept
        : __m_(__u.__m_), __owns_(__u.__owns_)
        {__u.__m_ = nullptr; __u.__owns_ = false;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock& operator=(unique_lock&& __u) noexcept
        {
            if (__owns_)
                __m_->unlock();
            __m_ = __u.__m_;
            __owns_ = __u.__owns_;
            __u.__m_ = nullptr;
            __u.__owns_ = false;
            return *this;
        }



    void lock();
    bool try_lock();

    template <class _Rep, class _Period>
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d);
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);

    void unlock();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(unique_lock& __u) noexcept
    {
        std::__1::swap(__m_, __u.__m_);
        std::__1::swap(__owns_, __u.__owns_);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    mutex_type* release() noexcept
    {
        mutex_type* __m = __m_;
        __m_ = nullptr;
        __owns_ = false;
        return __m;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool owns_lock() const noexcept {return __owns_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit
        operator bool () const noexcept {return __owns_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    mutex_type* mutex() const noexcept {return __m_;}
};

template <class _Mutex>
void
unique_lock<_Mutex>::lock()
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::lock: already locked");
    __m_->lock();
    __owns_ = true;
}

template <class _Mutex>
bool
unique_lock<_Mutex>::try_lock()
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::try_lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock: already locked");
    __owns_ = __m_->try_lock();
    return __owns_;
}

template <class _Mutex>
template <class _Rep, class _Period>
bool
unique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period>& __d)
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::try_lock_for: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock_for: already locked");
    __owns_ = __m_->try_lock_for(__d);
    return __owns_;
}

template <class _Mutex>
template <class _Clock, class _Duration>
bool
unique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::try_lock_until: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock_until: already locked");
    __owns_ = __m_->try_lock_until(__t);
    return __owns_;
}

template <class _Mutex>
void
unique_lock<_Mutex>::unlock()
{
    if (!__owns_)
        __throw_system_error(1, "unique_lock::unlock: not locked");
    __m_->unlock();
    __owns_ = false;
}

template <class _Mutex>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) noexcept
    {__x.swap(__y);}


enum class __attribute__ ((__type_visibility__("default"))) cv_status
{
    no_timeout,
    timeout
};


class __attribute__ ((__visibility__("default"))) condition_variable
{

    __libcpp_condvar_t __cv_ = {0x3CB0B1BB, {0}};




public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))

    constexpr condition_variable() noexcept = default;



    ~condition_variable();

private:
    condition_variable(const condition_variable&);
    condition_variable& operator=(const condition_variable&);

public:
    void notify_one() noexcept;
    void notify_all() noexcept;

    void wait(unique_lock<mutex>& __lk) noexcept;
    template <class _Predicate>
        inline __attribute__ ((__visibility__("hidden")))
        void wait(unique_lock<mutex>& __lk, _Predicate __pred);

    template <class _Clock, class _Duration>
        inline __attribute__ ((__visibility__("hidden")))
        cv_status
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t);

    template <class _Clock, class _Duration, class _Predicate>
        inline __attribute__ ((__visibility__("hidden")))
        bool
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred);

    template <class _Rep, class _Period>
        inline __attribute__ ((__visibility__("hidden")))
        cv_status
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d);

    template <class _Rep, class _Period, class _Predicate>
        bool
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d,
                 _Predicate __pred);

    typedef __libcpp_condvar_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) native_handle_type native_handle() {return &__cv_;}

private:
    void __do_timed_wait(unique_lock<mutex>& __lk,
       chrono::time_point<chrono::system_clock, chrono::nanoseconds>) noexcept;
};


template <class _To, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    chrono::__is_duration<_To>::value,
    _To
>::type
__ceil(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    _To __r = duration_cast<_To>(__d);
    if (__r < __d)
        ++__r;
    return __r;
}


template <class _Predicate>
void
condition_variable::wait(unique_lock<mutex>& __lk, _Predicate __pred)
{
    while (!__pred())
        wait(__lk);
}

template <class _Clock, class _Duration>
cv_status
condition_variable::wait_until(unique_lock<mutex>& __lk,
                               const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    wait_for(__lk, __t - _Clock::now());
    return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
}

template <class _Clock, class _Duration, class _Predicate>
bool
condition_variable::wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred)
{
    while (!__pred())
    {
        if (wait_until(__lk, __t) == cv_status::timeout)
            return __pred();
    }
    return true;
}

template <class _Rep, class _Period>
cv_status
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d)
{
    using namespace chrono;
    if (__d <= __d.zero())
        return cv_status::timeout;
    typedef time_point<system_clock, duration<long double, nano> > __sys_tpf;
    typedef time_point<system_clock, nanoseconds> __sys_tpi;
    __sys_tpf _Max = __sys_tpi::max();
    steady_clock::time_point __c_now = steady_clock::now();
    system_clock::time_point __s_now = system_clock::now();
    if (_Max - __d > __s_now)
        __do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));
    else
        __do_timed_wait(__lk, __sys_tpi::max());
    return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :
                                                 cv_status::timeout;
}

template <class _Rep, class _Period, class _Predicate>
inline
bool
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d,
                             _Predicate __pred)
{
    return wait_until(__lk, chrono::steady_clock::now() + __d,
                      std::__1::move(__pred));
}



} }
# 192 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/mutex" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/functional" 1 3
# 495 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/functional" 3


namespace std {inline namespace __1 {


template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) plus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) plus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) minus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) minus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) multiplies : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) multiplies<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) divides : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) divides<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) modulus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) modulus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) negate : unary_function<_Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) negate<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(- std::__1::forward<_Tp>(__x)))
    -> decltype (- std::__1::forward<_Tp>(__x))
        { return - std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) equal_to : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) not_equal_to : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) not_equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) greater : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) greater<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};






template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) greater_equal : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) greater_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) less_equal : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) less_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) logical_and : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) logical_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) logical_or : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) logical_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) logical_not : unary_function<_Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) logical_not<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(!std::__1::forward<_Tp>(__x)))
    -> decltype (!std::__1::forward<_Tp>(__x))
        { return !std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) bit_and : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) bit_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) bit_or : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) bit_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) bit_xor<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>
struct __attribute__ ((__type_visibility__("default"))) bit_not : unary_function<_Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x) const
        {return ~__x;}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) bit_not<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(~std::__1::forward<_Tp>(__x)))
    -> decltype (~std::__1::forward<_Tp>(__x))
        { return ~std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};


template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
inline constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}

template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit constexpr
    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}

    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
inline constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}
# 1254 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/functional" 3
template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type __f_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __mem_fn(type __f) noexcept : __f_(__f) {}



    template <class... _ArgTypes>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename __invoke_return<type, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return __invoke(__f_, std::__1::forward<_ArgTypes>(__args)...);
    }
# 1375 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/functional" 3
};

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm) noexcept
{
    return __mem_fn<_Rp _Tp::*>(__pm);
}







class __attribute__ ((__visibility__("default"))) bad_function_call
    : public exception
{






};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __throw_bad_function_call()
{

    throw bad_function_call();



}

template<class _Fp> class __attribute__ ((__type_visibility__("default"))) function;

namespace __function
{

template<class _Rp>
struct __maybe_derive_from_unary_function
{
};

template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template<class _Rp>
struct __maybe_derive_from_binary_function
{
};

template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Fp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool __not_null(_Fp const&) { return true; }

template <class _Fp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool __not_null(_Fp* __ptr) { return __ptr; }

template <class _Ret, class _Class>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool __not_null(_Ret _Class::*__ptr) { return __ptr; }

template <class _Fp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool __not_null(function<_Fp> const& __f) { return !!__f; }

}



namespace __function {

template<class _Fp> class __base;

template<class _Rp, class ..._ArgTypes>
class __base<_Rp(_ArgTypes...)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __base() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() noexcept = 0;
    virtual void destroy_deallocate() noexcept = 0;
    virtual _Rp operator()(_ArgTypes&& ...) = 0;

    virtual const void* target(const type_info&) const noexcept = 0;
    virtual const std::type_info& target_type() const noexcept = 0;

};

template<class _FD, class _Alloc, class _FB> class __func;

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
class __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __func(_Fp&& __f)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)),
                                    std::__1::forward_as_tuple()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __func(const _Fp& __f, const _Alloc& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
                                    std::__1::forward_as_tuple(__a)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __func(const _Fp& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
                                    std::__1::forward_as_tuple(std::__1::move(__a))) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __func(_Fp&& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)),
                                    std::__1::forward_as_tuple(std::__1::move(__a))) {}
    virtual __base<_Rp(_ArgTypes...)>* __clone() const;
    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;
    virtual void destroy() noexcept;
    virtual void destroy_deallocate() noexcept;
    virtual _Rp operator()(_ArgTypes&& ... __arg);

    virtual const void* target(const type_info&) const noexcept;
    virtual const std::type_info& target_type() const noexcept;

};

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
__base<_Rp(_ArgTypes...)>*
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() noexcept
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() noexcept
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
_Rp
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
{
    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
    return _Invoker::__call(__f_.first(), std::__1::forward<_ArgTypes>(__arg)...);
}



template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
const void*
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const noexcept
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const noexcept
{
    return typeid(_Fp);
}



}

template<class _Rp, class ..._ArgTypes>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_ArgTypes...)>
    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>
{
    typedef __function::__base<_Rp(_ArgTypes...)> __base;
    typename aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    __attribute__((__no_sanitize__("cfi"))) static __base *__as_base(void *p) {
      return reinterpret_cast<__base*>(p);
    }

    template <class _Fp, bool = !is_same<_Fp, function>::value &&
                                __invokable<_Fp&, _ArgTypes...>::value>
        struct __callable;
    template <class _Fp>
        struct __callable<_Fp, true>
        {
            static const bool value = is_same<void, _Rp>::value ||
                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,
                               _Rp>::value;
        };
    template <class _Fp>
        struct __callable<_Fp, false>
        {
            static const bool value = false;
        };
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    function() noexcept : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    function(nullptr_t) noexcept : __f_(0) {}
    function(const function&);
    function(function&&) noexcept;
    template<class _Fp, class = typename enable_if<
        __callable<_Fp>::value && !is_same<_Fp, function>::value
    >::type>
    function(_Fp);
# 1645 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/functional" 3
    function& operator=(const function&);
    function& operator=(function&&) noexcept;
    function& operator=(nullptr_t) noexcept;
    template<class _Fp>
      typename enable_if
      <
        __callable<typename decay<_Fp>::type>::value &&
        !is_same<typename remove_reference<_Fp>::type, function>::value,
        function&
      >::type
      operator=(_Fp&&);

    ~function();


    void swap(function&) noexcept;
# 1670 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/functional" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit operator bool() const noexcept {return __f_;}


    template<class _R2, class... _ArgTypes2>
      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;
    template<class _R2, class... _ArgTypes2>
      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;
public:

    _Rp operator()(_ArgTypes...) const;



    const std::type_info& target_type() const noexcept;
    template <typename _Tp> _Tp* target() noexcept;
    template <typename _Tp> const _Tp* target() const noexcept;

};

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if ((void *)__f.__f_ == &__f.__buf_)
    {
        __f_ = __as_base(&__buf_);
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}
# 1722 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/functional" 3
template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(function&& __f) noexcept
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if ((void *)__f.__f_ == &__f.__buf_)
    {
        __f_ = __as_base(&__buf_);
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
}
# 1760 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/functional" 3
template<class _Rp, class ..._ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>::function(_Fp __f)
    : __f_(0)
{
    if (__function::__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)
        {
            __f_ = ::new((void*)&__buf_) _FF(std::__1::move(__f));
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(std::__1::move(__f), allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}
# 1812 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/functional" 3
template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(function&& __f) noexcept
{
    function::operator=(nullptr);
    if (__f.__f_ == 0)
        __f_ = 0;
    else if ((void *)__f.__f_ == &__f.__buf_)
    {
        __f_ = __as_base(&__buf_);
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(nullptr_t) noexcept
{
    __base* __t = __f_;
    __f_ = 0;
    if ((void *)__t == &__buf_)
        __t->destroy();
    else if (__t)
        __t->destroy_deallocate();
    return *this;
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp>
typename enable_if
<
    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&
    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,
    function<_Rp(_ArgTypes...)>&
>::type
function<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)
{
    function(std::__1::forward<_Fp>(__f)).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::~function()
{
    if ((void *)__f_ == &__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class ..._ArgTypes>
void
function<_Rp(_ArgTypes...)>::swap(function& __f) noexcept
{
    if (std::__1::addressof(__f) == this)
      return;
    if ((void *)__f_ == &__buf_ && (void *)__f.__f_ == &__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = __as_base(&__tempbuf);
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone(__as_base(&__buf_));
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = __as_base(&__buf_);
        __t->__clone(__as_base(&__f.__buf_));
        __t->destroy();
        __f.__f_ = __as_base(&__f.__buf_);
    }
    else if ((void *)__f_ == &__buf_)
    {
        __f_->__clone(__as_base(&__f.__buf_));
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = __as_base(&__f.__buf_);
    }
    else if ((void *)__f.__f_ == &__f.__buf_)
    {
        __f.__f_->__clone(__as_base(&__buf_));
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = __as_base(&__buf_);
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class ..._ArgTypes>
_Rp
function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
{
    if (__f_ == 0)
        __throw_bad_function_call();
    return (*__f_)(std::__1::forward<_ArgTypes>(__arg)...);
}



template<class _Rp, class ..._ArgTypes>
const std::type_info&
function<_Rp(_ArgTypes...)>::target_type() const noexcept
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp, class ..._ArgTypes>
template <typename _Tp>
_Tp*
function<_Rp(_ArgTypes...)>::target() noexcept
{
    if (__f_ == 0)
        return nullptr;
    return (_Tp*) const_cast<void *>(__f_->target(typeid(_Tp)));
}

template<class _Rp, class ..._ArgTypes>
template <typename _Tp>
const _Tp*
function<_Rp(_ArgTypes...)>::target() const noexcept
{
    if (__f_ == 0)
        return nullptr;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) noexcept
{return __x.swap(__y);}
# 1993 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/functional" 3
template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};


template <class _Tp>
constexpr size_t is_bind_expression_v = is_bind_expression<_Tp>::value;


template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};


template <class _Tp>
constexpr size_t is_placeholder_v = is_placeholder<_Tp>::value;


namespace placeholders
{

template <int _Np> struct __ph {};
# 2028 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/functional" 3
constexpr __ph<1> _1{};
constexpr __ph<2> _2{};
constexpr __ph<3> _3{};
constexpr __ph<4> _4{};
constexpr __ph<5> _5{};
constexpr __ph<6> _6{};
constexpr __ph<7> _7{};
constexpr __ph<8> _8{};
constexpr __ph<9> _9{};
constexpr __ph<10> _10{};


}

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};




template <class _Tp, class _Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}

template <class _Ti, class ..._Uj, size_t ..._Indx>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __invoke_of<_Ti&, _Uj...>::type
__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)
{
    return __ti(std::__1::forward<_Uj>(std::__1::get<_Indx>(__uj))...);
}

template <class _Ti, class ..._Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_bind_expression<_Ti>::value,
    __invoke_of<_Ti&, _Uj...>
>::type
__mu(_Ti& __ti, tuple<_Uj...>& __uj)
{
    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
    return __mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj>
struct __mu_return2 {};

template <class _Ti, class _Uj>
struct __mu_return2<true, _Ti, _Uj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
>::type
__mu(_Ti&, _Uj& __uj)
{
    const size_t _Indx = is_placeholder<_Ti>::value - 1;
    return std::__1::forward<typename tuple_element<_Indx, _Uj>::type>(std::__1::get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_bind_expression<_Ti>::value &&
    is_placeholder<_Ti>::value == 0 &&
    !__is_reference_wrapper<_Ti>::value,
    _Ti&
>::type
__mu(_Ti& __ti, _Uj&)
{
    return __ti;
}

template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
          class _TupleUj>
struct ____mu_return;

template <bool _Invokable, class _Ti, class ..._Uj>
struct ____mu_return_invokable
{
    typedef __nat type;
};

template <class _Ti, class ..._Uj>
struct ____mu_return_invokable<true, _Ti, _Uj...>
{
    typedef typename __invoke_of<_Ti&, _Uj...>::type type;
};

template <class _Ti, class ..._Uj>
struct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >
    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>
{
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, true, _TupleUj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
                                   _TupleUj>::type&& type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, true, false, false, _TupleUj>
{
    typedef typename _Ti::type& type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, false, _TupleUj>
{
    typedef _Ti& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public ____mu_return<_Ti,
                           __is_reference_wrapper<_Ti>::value,
                           is_bind_expression<_Ti>::value,
                           0 < is_placeholder<_Ti>::value &&
                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,
                           _TupleUj>
{
};

template <class _Fp, class _BoundArgs, class _TupleUj>
struct __is_valid_bind_return
{
    static const bool value = false;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class _BoundArgs, class _TupleUj,
          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
struct __bind_return;

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            const _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __bind_return<_Fp, _BoundArgs, _Args>::type
__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
                _Args&& __args)
{
    return std::__1::__invoke(__f, std::__1::__mu(std::__1::get<_Indx>(__bound_args), __args)...);
}

template<class _Fp, class ..._BoundArgs>
class __bind
    : public __weak_result_type<typename decay<_Fp>::type>
{
protected:
    typedef typename decay<_Fp>::type _Fd;
    typedef tuple<typename decay<_BoundArgs>::type...> _Td;
private:
    _Fd __f_;
    _Td __bound_args_;

    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
public:
    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind>::value
                               >::type>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)
        : __f_(std::__1::forward<_Gp>(__f)),
          __bound_args_(std::__1::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args)
        {
            return std::__1::__apply_functor(__f_, __bound_args_, __indices(),
                                  tuple<_Args&&...>(std::__1::forward<_Args>(__args)...));
        }

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args) const
        {
            return std::__1::__apply_functor(__f_, __bound_args_, __indices(),
                                   tuple<_Args&&...>(std::__1::forward<_Args>(__args)...));
        }
};

template<class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};

template<class _Rp, class _Fp, class ..._BoundArgs>
class __bind_r
    : public __bind<_Fp, _BoundArgs...>
{
    typedef __bind<_Fp, _BoundArgs...> base;
    typedef typename base::_Fd _Fd;
    typedef typename base::_Td _Td;
public:
    typedef _Rp result_type;


    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind_r>::value
                               >::type>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)
        : base(std::__1::forward<_Gp>(__f),
               std::__1::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args)
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base&>(*this), std::__1::forward<_Args>(__args)...);
        }

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args) const
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base const&>(*this), std::__1::forward<_Args>(__args)...);
        }
};

template<class _Rp, class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};

template<class _Fp, class ..._BoundArgs>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bind<_Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind<_Fp, _BoundArgs...> type;
    return type(std::__1::forward<_Fp>(__f), std::__1::forward<_BoundArgs>(__bound_args)...);
}

template<class _Rp, class _Fp, class ..._BoundArgs>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bind_r<_Rp, _Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
    return type(std::__1::forward<_Fp>(__f), std::__1::forward<_BoundArgs>(__bound_args)...);
}







template <class _Fn, class ..._Args>
result_of_t<_Fn&&(_Args&&...)>
invoke(_Fn&& __f, _Args&&... __args)
    noexcept(noexcept(std::__1::__invoke(std::__1::forward<_Fn>(__f), std::__1::forward<_Args>(__args)...)))
{
    return std::__1::__invoke(std::__1::forward<_Fn>(__f), std::__1::forward<_Args>(__args)...);
}

template <class _DecayFunc>
class __attribute__ ((__type_visibility__("default"))) __not_fn_imp {
  _DecayFunc __fd;

public:
    __not_fn_imp() = delete;

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_Args&& ...__args) &
            noexcept(noexcept(!std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...)))
        -> decltype( !std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...))
        { return !std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...); }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_Args&& ...__args) &&
            noexcept(noexcept(!std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...)))
        -> decltype( !std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...))
        { return !std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...); }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_Args&& ...__args) const&
            noexcept(noexcept(!std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...)))
        -> decltype( !std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...))
        { return !std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...); }


    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_Args&& ...__args) const&&
            noexcept(noexcept(!std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...)))
        -> decltype( !std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...))
        { return !std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...); }

private:
    template <class _RawFunc,
              class = enable_if_t<!is_same<decay_t<_RawFunc>, __not_fn_imp>::value>>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __not_fn_imp(_RawFunc&& __rf)
        : __fd(std::__1::forward<_RawFunc>(__rf)) {}

    template <class _RawFunc>
    friend inline __attribute__ ((__visibility__("hidden"), __always_inline__))
    __not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&&);
};

template <class _RawFunc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&& __fn) {
    return __not_fn_imp<decay_t<_RawFunc>>(std::__1::forward<_RawFunc>(__fn));
}





} }
# 193 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/mutex" 2 3
# 201 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/mutex" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 205 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/mutex" 2 3


namespace std {inline namespace __1 {



class __attribute__ ((__visibility__("default"))) recursive_mutex
{
    __libcpp_recursive_mutex_t __m_;

public:
     recursive_mutex();
     ~recursive_mutex();

private:
    recursive_mutex(const recursive_mutex&);
    recursive_mutex& operator=(const recursive_mutex&);

public:
    void lock();
    bool try_lock() noexcept;
    void unlock() noexcept;

    typedef __libcpp_recursive_mutex_t* native_handle_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    native_handle_type native_handle() {return &__m_;}
};

class __attribute__ ((__visibility__("default"))) timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    bool __locked_;
public:
     timed_mutex();
     ~timed_mutex();

private:
    timed_mutex(const timed_mutex&);
    timed_mutex& operator=(const timed_mutex&);

public:
    void lock();
    bool try_lock() noexcept;
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>
        inline __attribute__ ((__visibility__("hidden")))
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() noexcept;
};

template <class _Clock, class _Duration>
bool
timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    unique_lock<mutex> __lk(__m_);
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __locked_)
        no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
    if (!__locked_)
    {
        __locked_ = true;
        return true;
    }
    return false;
}

class __attribute__ ((__visibility__("default"))) recursive_timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    size_t __count_;
    __libcpp_thread_id __id_;
public:
     recursive_timed_mutex();
     ~recursive_timed_mutex();

private:
    recursive_timed_mutex(const recursive_timed_mutex&);
    recursive_timed_mutex& operator=(const recursive_timed_mutex&);

public:
    void lock();
    bool try_lock() noexcept;
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>
        inline __attribute__ ((__visibility__("hidden")))
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() noexcept;
};

template <class _Clock, class _Duration>
bool
recursive_timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    __libcpp_thread_id __id = __libcpp_thread_get_current_id();
    unique_lock<mutex> lk(__m_);
    if (__libcpp_thread_id_equal(__id, __id_))
    {
        if (__count_ == numeric_limits<size_t>::max())
            return false;
        ++__count_;
        return true;
    }
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __count_ != 0)
        no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
    if (__count_ == 0)
    {
        __count_ = 1;
        __id_ = __id;
        return true;
    }
    return false;
}

template <class _L0, class _L1>
int
try_lock(_L0& __l0, _L1& __l1)
{
    unique_lock<_L0> __u0(__l0, try_to_lock);
    if (__u0.owns_lock())
    {
        if (__l1.try_lock())
        {
            __u0.release();
            return -1;
        }
        else
            return 1;
    }
    return 0;
}



template <class _L0, class _L1, class _L2, class... _L3>
int
try_lock(_L0& __l0, _L1& __l1, _L2& __l2, _L3&... __l3)
{
    int __r = 0;
    unique_lock<_L0> __u0(__l0, try_to_lock);
    if (__u0.owns_lock())
    {
        __r = try_lock(__l1, __l2, __l3...);
        if (__r == -1)
            __u0.release();
        else
            ++__r;
    }
    return __r;
}



template <class _L0, class _L1>
void
lock(_L0& __l0, _L1& __l1)
{
    while (true)
    {
        {
            unique_lock<_L0> __u0(__l0);
            if (__l1.try_lock())
            {
                __u0.release();
                break;
            }
        }
        __libcpp_thread_yield();
        {
            unique_lock<_L1> __u1(__l1);
            if (__l0.try_lock())
            {
                __u1.release();
                break;
            }
        }
        __libcpp_thread_yield();
    }
}



template <class _L0, class _L1, class _L2, class ..._L3>
void
__lock_first(int __i, _L0& __l0, _L1& __l1, _L2& __l2, _L3& ...__l3)
{
    while (true)
    {
        switch (__i)
        {
        case 0:
            {
                unique_lock<_L0> __u0(__l0);
                __i = try_lock(__l1, __l2, __l3...);
                if (__i == -1)
                {
                    __u0.release();
                    return;
                }
            }
            ++__i;
            __libcpp_thread_yield();
            break;
        case 1:
            {
                unique_lock<_L1> __u1(__l1);
                __i = try_lock(__l2, __l3..., __l0);
                if (__i == -1)
                {
                    __u1.release();
                    return;
                }
            }
            if (__i == sizeof...(_L3) + 1)
                __i = 0;
            else
                __i += 2;
            __libcpp_thread_yield();
            break;
        default:
            __lock_first(__i - 2, __l2, __l3..., __l0, __l1);
            return;
        }
    }
}

template <class _L0, class _L1, class _L2, class ..._L3>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
lock(_L0& __l0, _L1& __l1, _L2& __l2, _L3& ...__l3)
{
    __lock_first(0, __l0, __l1, __l2, __l3...);
}

template <class _L0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __unlock(_L0& __l0) {
    __l0.unlock();
}

template <class _L0, class _L1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __unlock(_L0& __l0, _L1& __l1) {
    __l0.unlock();
    __l1.unlock();
}

template <class _L0, class _L1, class _L2, class ..._L3>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __unlock(_L0& __l0, _L1& __l1, _L2& __l2, _L3&... __l3) {
    __l0.unlock();
    __l1.unlock();
    std::__1::__unlock(__l2, __l3...);
}




template <class ..._Mutexes>
class __attribute__ ((__type_visibility__("default"))) scoped_lock;

template <>
class __attribute__ ((__type_visibility__("default"))) scoped_lock<> {
public:
    explicit scoped_lock() {}
    ~scoped_lock() = default;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit scoped_lock(adopt_lock_t) {}

    scoped_lock(scoped_lock const&) = delete;
    scoped_lock& operator=(scoped_lock const&) = delete;
};

template <class _Mutex>
class __attribute__ ((__type_visibility__("default"))) scoped_lock<_Mutex> {
public:
    typedef _Mutex mutex_type;
private:
    mutex_type& __m_;
public:
    explicit scoped_lock(mutex_type & __m)
        : __m_(__m) {__m_.lock();}

    ~scoped_lock() {__m_.unlock();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit scoped_lock(mutex_type& __m, adopt_lock_t)
        : __m_(__m) {}

    scoped_lock(scoped_lock const&) = delete;
    scoped_lock& operator=(scoped_lock const&) = delete;
};

template <class ..._MArgs>
class __attribute__ ((__type_visibility__("default"))) scoped_lock
{
    static_assert(sizeof...(_MArgs) > 1, "At least 2 lock types required");
    typedef tuple<_MArgs&...> _MutexTuple;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit scoped_lock(_MArgs&... __margs)
      : __t_(__margs...)
    {
        std::__1::lock(__margs...);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    scoped_lock(_MArgs&... __margs, adopt_lock_t)
        : __t_(__margs...)
    {
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~scoped_lock() {
        typedef typename __make_tuple_indices<sizeof...(_MArgs)>::type _Indices;
        __unlock_unpack(_Indices{}, __t_);
    }

    scoped_lock(scoped_lock const&) = delete;
    scoped_lock& operator=(scoped_lock const&) = delete;

private:
    template <size_t ..._Indx>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __unlock_unpack(__tuple_indices<_Indx...>, _MutexTuple& __mt) {
        std::__1::__unlock(std::__1::get<_Indx>(__mt)...);
    }

    _MutexTuple __t_;
};




struct __attribute__ ((__type_visibility__("default"))) once_flag;



template<class _Callable, class... _Args>
__attribute__ ((__visibility__("hidden"), __always_inline__))
void call_once(once_flag&, _Callable&&, _Args&&...);
# 572 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/mutex" 3
struct __attribute__ ((__type_visibility__("default"))) once_flag
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
        once_flag() noexcept : __state_(0) {}

private:
    once_flag(const once_flag&);
    once_flag& operator=(const once_flag&);

    unsigned long __state_;


    template<class _Callable, class... _Args>
    friend
    void call_once(once_flag&, _Callable&&, _Args&&...);
# 597 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/mutex" 3
};



template <class _Fp>
class __call_once_param
{
    _Fp& __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __call_once_param(_Fp& __f) : __f_(__f) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()()
    {
        typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
        __execute(_Index());
    }

private:
    template <size_t ..._Indices>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __execute(__tuple_indices<_Indices...>)
    {
        __invoke(std::__1::get<0>(std::__1::move(__f_)), std::__1::get<_Indices>(std::__1::move(__f_))...);
    }
};
# 644 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/mutex" 3
template <class _Fp>
void
__call_once_proxy(void* __vp)
{
    __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
    (*__p)();
}

__attribute__ ((__visibility__("default"))) void __call_once(volatile unsigned long&, void*, void(*)(void*));



template<class _Callable, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
call_once(once_flag& __flag, _Callable&& __func, _Args&&... __args)
{
    if (__libcpp_acquire_load(&__flag.__state_) != ~0ul)
    {
        typedef tuple<_Callable&&, _Args&&...> _Gp;
        _Gp __f(std::__1::forward<_Callable>(__func), std::__1::forward<_Args>(__args)...);
        __call_once_param<_Gp> __p(__f);
        __call_once(__flag.__state_, &__p, &__call_once_proxy<_Gp>);
    }
}
# 698 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/mutex" 3
} }
# 19 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/locale.h" 1 3
# 41 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/locale.h" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/locale.h" 1 3 4
# 40 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/locale.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_locale.h" 1 3 4
# 43 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_locale.h" 3 4
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};



extern "C" {
struct lconv *localeconv(void);
}
# 41 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/locale.h" 2 3 4
# 52 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/locale.h" 3 4
extern "C" {
char *setlocale(int, const char *);
}
# 44 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/locale.h" 2 3
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 2 3
# 39 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_xlocale.h" 1 3 4
# 29 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_xlocale.h" 3 4
struct _xlocale;
typedef struct _xlocale * locale_t;

extern "C" {
int ___mb_cur_max(void);
int ___mb_cur_max_l(locale_t);
}
# 35 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 2 3 4
# 62 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 3 4
extern "C" {
extern const locale_t _c_locale;

locale_t duplocale(locale_t);
int freelocale(locale_t);
struct lconv * localeconv_l(locale_t);
locale_t newlocale(int, const char *, locale_t);
const char * querylocale(int, locale_t);
locale_t uselocale(locale_t);
}



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_ctype.h" 1 3 4
# 37 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_ctype.h" 3 4
extern "C" {
unsigned long ___runetype_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___toupper_l(__darwin_ct_rune_t, locale_t);
}

extern "C" {
int __maskrune_l(__darwin_ct_rune_t, unsigned long, locale_t);
}

inline int
__istype_l(__darwin_ct_rune_t _c, unsigned long _f, locale_t _l)
{
 return !!(isascii(_c) ? (_DefaultRuneLocale.__runetype[_c] & _f)
  : __maskrune_l(_c, _f, _l));
}

inline __darwin_ct_rune_t
__toupper_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__mapupper[_c]
  : ___toupper_l(_c, _l);
}

inline __darwin_ct_rune_t
__tolower_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__maplower[_c]
  : ___tolower_l(_c, _l);
}

inline int
__wcwidth_l(__darwin_ct_rune_t _c, locale_t _l)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune_l(_c, 0xe0000000L|0x00040000L, _l);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}



inline int
digittoint_l(int c, locale_t l)
{
 return (__maskrune_l(c, 0x0F, l));
}

inline int
isalnum_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L|0x00000400L, l));
}

inline int
isalpha_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L, l));
}

inline int
isblank_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00020000L, l));
}

inline int
iscntrl_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000200L, l));
}

inline int
isdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isgraph_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000800L, l));
}

inline int
ishexnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
isideogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00080000L, l));
}

inline int
islower_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00001000L, l));
}

inline int
isnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isphonogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00200000L, l));
}

inline int
isprint_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00040000L, l));
}

inline int
ispunct_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00002000L, l));
}

inline int
isrune_l(int c, locale_t l)
{
 return (__istype_l(c, 0xFFFFFFF0L, l));
}

inline int
isspace_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00004000L, l));
}

inline int
isspecial_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00100000L, l));
}

inline int
isupper_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00008000L, l));
}

inline int
isxdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
tolower_l(int c, locale_t l)
{
        return (__tolower_l(c, l));
}

inline int
toupper_l(int c, locale_t l)
{
        return (__toupper_l(c, l));
}
# 75 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/__wctype.h" 1 3 4
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/__wctype.h" 3 4
inline int
iswalnum_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L|0x00000400L, _l));
}

inline int
iswalpha_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L, _l));
}

inline int
iswcntrl_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000200L, _l));
}

inline int
iswctype_l(wint_t _wc, wctype_t _charclass, locale_t _l)
{
 return (__istype_l(_wc, _charclass, _l));
}

inline int
iswdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswgraph_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000800L, _l));
}

inline int
iswlower_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00001000L, _l));
}

inline int
iswprint_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00040000L, _l));
}

inline int
iswpunct_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00002000L, _l));
}

inline int
iswspace_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00004000L, _l));
}

inline int
iswupper_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00008000L, _l));
}

inline int
iswxdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline wint_t
towlower_l(wint_t _wc, locale_t _l)
{
        return (__tolower_l(_wc, _l));
}

inline wint_t
towupper_l(wint_t _wc, locale_t _l)
{
        return (__toupper_l(_wc, _l));
}
# 138 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/__wctype.h" 3 4
extern "C" {
wctype_t
 wctype_l(const char *, locale_t);
}
# 78 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 2 3 4
# 92 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_stdio.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_stdio.h" 3 4
extern "C" {

int fprintf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int fscanf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int printf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 2, 3)));
int scanf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 2, 3)));
int sprintf_l(char * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4))) __attribute__((__availability__(swift, unavailable, message="Use snprintf_l instead.")));
int sscanf_l(const char * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int vfprintf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));
int vprintf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 2, 0)));
int vsprintf_l(char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0))) __attribute__((__availability__(swift, unavailable, message="Use vsnprintf_l instead.")));


int snprintf_l(char * , size_t, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 4, 5)));
int vfscanf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));
int vscanf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 2, 0)));
int vsnprintf_l(char * , size_t, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 4, 0)));
int vsscanf_l(const char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));



int dprintf_l(int, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf_l(int, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0))) __attribute__((availability(macosx,introduced=10.7)));




int asprintf_l(char ** , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int vasprintf_l(char ** , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));


}
# 93 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_stdlib.h" 1 3 4
# 29 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_stdlib.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_stdlib.h" 2 3 4


extern "C" {
double atof_l(const char *, locale_t);
int atoi_l(const char *, locale_t);
long atol_l(const char *, locale_t);

long long
  atoll_l(const char *, locale_t);

int mblen_l(const char *, size_t, locale_t);
size_t mbstowcs_l(wchar_t * , const char * , size_t,
     locale_t);
int mbtowc_l(wchar_t * , const char * , size_t,
     locale_t);
double strtod_l(const char *, char **, locale_t) __asm("_" "strtod_l" );
float strtof_l(const char *, char **, locale_t) __asm("_" "strtof_l" );
long strtol_l(const char *, char **, int, locale_t);
long double
  strtold_l(const char *, char **, locale_t);
long long
  strtoll_l(const char *, char **, int, locale_t);

long long
  strtoq_l(const char *, char **, int, locale_t);

unsigned long
  strtoul_l(const char *, char **, int, locale_t);
unsigned long long
  strtoull_l(const char *, char **, int, locale_t);

unsigned long long
  strtouq_l(const char *, char **, int, locale_t);

size_t wcstombs_l(char * , const wchar_t * , size_t,
     locale_t);
int wctomb_l(char *, wchar_t, locale_t);





}
# 96 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_string.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_string.h" 3 4
extern "C" {
int strcoll_l(const char *, const char *, locale_t);
size_t strxfrm_l(char *, const char *, size_t, locale_t);
int strcasecmp_l(const char *, const char *, locale_t);
char *strcasestr_l(const char *, const char *, locale_t);
int strncasecmp_l(const char *, const char *, size_t, locale_t);
}
# 99 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_time.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_time.h" 3 4
extern "C" {
size_t strftime_l(char * , size_t, const char * ,
  const struct tm * , locale_t)
  __asm("_" "strftime_l" ) __attribute__((__format__ (__strftime__, 3, 0)));
char *strptime_l(const char * , const char * ,
  struct tm * , locale_t)
  __asm("_" "strptime_l" ) __attribute__((__format__ (__strftime__, 2, 0)));
}
# 102 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_wchar.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
wint_t btowc_l(int, locale_t);
wint_t fgetwc_l(FILE *, locale_t);
wchar_t *fgetws_l(wchar_t * , int, FILE * , locale_t);
wint_t fputwc_l(wchar_t, FILE *, locale_t);
int fputws_l(const wchar_t * , FILE * , locale_t);
int fwprintf_l(FILE * , locale_t, const wchar_t * , ...);
int fwscanf_l(FILE * , locale_t, const wchar_t * , ...);
wint_t getwc_l(FILE *, locale_t);
wint_t getwchar_l(locale_t);
size_t mbrlen_l(const char * , size_t, mbstate_t * ,
     locale_t);
size_t mbrtowc_l(wchar_t * , const char * , size_t,
     mbstate_t * , locale_t);
int mbsinit_l(const mbstate_t *, locale_t);
size_t mbsrtowcs_l(wchar_t * , const char ** , size_t,
     mbstate_t * , locale_t);
wint_t putwc_l(wchar_t, FILE *, locale_t);
wint_t putwchar_l(wchar_t, locale_t);
int swprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , ...);
int swscanf_l(const wchar_t * , locale_t,
  const wchar_t * , ...);
wint_t ungetwc_l(wint_t, FILE *, locale_t);
int vfwprintf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , __darwin_va_list);
int vwprintf_l(locale_t, const wchar_t * , __darwin_va_list);
size_t wcrtomb_l(char * , wchar_t, mbstate_t * ,
     locale_t);
int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
size_t wcsftime_l(wchar_t * , size_t, const wchar_t * ,
  const struct tm * , locale_t)
  __asm("_" "wcsftime_l" );
size_t wcsrtombs_l(char * , const wchar_t ** , size_t,
     mbstate_t * , locale_t);
double wcstod_l(const wchar_t * , wchar_t ** , locale_t);
long wcstol_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long
 wcstoul_l(const wchar_t * , wchar_t ** , int,
     locale_t);
int wcswidth_l(const wchar_t *, size_t, locale_t);
size_t wcsxfrm_l(wchar_t * , const wchar_t * , size_t,
     locale_t);
int wctob_l(wint_t, locale_t);
int wcwidth_l(wchar_t, locale_t);
int wprintf_l(locale_t, const wchar_t * , ...);
int wscanf_l(locale_t, const wchar_t * , ...);
}
# 90 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
int vfwscanf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswscanf_l(const wchar_t * , locale_t,
  const wchar_t * , __darwin_va_list);
int vwscanf_l(locale_t, const wchar_t * , __darwin_va_list);
float wcstof_l(const wchar_t * , wchar_t ** , locale_t);
long double
 wcstold_l(const wchar_t * , wchar_t ** , locale_t);

long long
 wcstoll_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long long
 wcstoull_l(const wchar_t * , wchar_t ** , int,
     locale_t);

}
# 117 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs_l(wchar_t * , const char ** , size_t,
     size_t, mbstate_t * , locale_t);
int wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t n, locale_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs_l(char * , const wchar_t ** , size_t,
     size_t, mbstate_t * , locale_t);
}







extern "C" {
wchar_t *fgetwln_l(FILE * , size_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
}
# 105 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_wctype.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_wctype.h" 3 4
inline int
iswblank_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00020000L, _l));
}

inline int
iswhexnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline int
iswideogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00080000L, _l));
}

inline int
iswnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswphonogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00200000L, _l));
}

inline int
iswrune_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0xFFFFFFF0L, _l));
}

inline int
iswspecial_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00100000L, _l));
}
# 90 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_wctype.h" 3 4
extern "C" {
wint_t nextwctype_l(wint_t, wctype_t, locale_t);
wint_t towctrans_l(wint_t, wctrans_t, locale_t);
wctrans_t
 wctrans_l(const char *, locale_t);
}
# 108 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale.h" 2 3 4
# 40 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 2 3
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 3


namespace std {inline namespace __1 {
# 71 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 3
class __attribute__ ((__visibility__("default"))) locale;

template <class _Facet>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
has_facet(const locale&) noexcept;

template <class _Facet>
__attribute__ ((__visibility__("hidden"), __always_inline__))
const _Facet&
use_facet(const locale&);

class __attribute__ ((__visibility__("default"))) locale
{
public:

    class __attribute__ ((__visibility__("default"))) facet;
    class __attribute__ ((__visibility__("default"))) id;

    typedef int category;
    __attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
    static const category
        none = 0,
        collate = (1 << 0),
        ctype = (1 << 1),
        monetary = (1 << 3),
        numeric = (1 << 4),
        time = (1 << 5),
        messages = (1 << 2),
        all = collate | ctype | monetary | numeric | time | messages;


    locale() noexcept;
    locale(const locale&) noexcept;
    explicit locale(const char*);
    explicit locale(const string&);
    locale(const locale&, const char*, category);
    locale(const locale&, const string&, category);
    template <class _Facet>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) locale(const locale&, _Facet*);
    locale(const locale&, const locale&, category);

    ~locale();

    const locale& operator=(const locale&) noexcept;

    template <class _Facet>
      inline __attribute__ ((__visibility__("hidden")))
      locale combine(const locale&) const;


    string name() const;
    bool operator==(const locale&) const;
    bool operator!=(const locale& __y) const {return !(*this == __y);}
    template <class _CharT, class _Traits, class _Allocator>
      inline __attribute__ ((__visibility__("hidden")))
      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,
                      const basic_string<_CharT, _Traits, _Allocator>&) const;


    static locale global(const locale&);
    static const locale& classic();

private:
    class __imp;
    __imp* __locale_;

    void __install_ctor(const locale&, facet*, long);
    static locale& __global();
    bool has_facet(id&) const;
    const facet* use_facet(id&) const;

    template <class _Facet> friend bool has_facet(const locale&) noexcept;
    template <class _Facet> friend const _Facet& use_facet(const locale&);
};

class __attribute__ ((__visibility__("default"))) locale::facet
    : public __shared_count
{
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit facet(size_t __refs = 0)
        : __shared_count(static_cast<long>(__refs)-1) {}

    virtual ~facet();



private:
    virtual void __on_zero_shared() noexcept;
};

class __attribute__ ((__visibility__("default"))) locale::id
{
    once_flag __flag_;
    int32_t __id_;

    static int32_t __next_id;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr id() :__id_(0) {}
private:
    void __init();
    void operator=(const id&);
    id(const id&);
public:
    long __get();

    friend class locale;
    friend class locale::__imp;
};

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale::locale(const locale& __other, _Facet* __f)
{
    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}

template <class _Facet>
locale
locale::combine(const locale& __other) const
{
    if (!std::__1::has_facet<_Facet>(__other))
        __throw_runtime_error("locale::combine: locale missing facet");

    return locale(*this, &const_cast<_Facet&>(std::__1::use_facet<_Facet>(__other)));
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
has_facet(const locale& __l) noexcept
{
    return __l.has_facet(_Facet::id);
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Facet&
use_facet(const locale& __l)
{
    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
}



template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) collate
    : public locale::facet
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit collate(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(const char_type* __lo1, const char_type* __hi1,
                const char_type* __lo2, const char_type* __hi2) const
    {
        return do_compare(__lo1, __hi1, __lo2, __hi2);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    string_type transform(const char_type* __lo, const char_type* __hi) const
    {
        return do_transform(__lo, __hi);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long hash(const char_type* __lo, const char_type* __hi) const
    {
        return do_hash(__lo, __hi);
    }

    static locale::id id;

protected:
    ~collate();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const
        {return string_type(__lo, __hi);}
    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT> locale::id collate<_CharT>::id;

template <class _CharT>
collate<_CharT>::~collate()
{
}

template <class _CharT>
int
collate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,
                            const char_type* __lo2, const char_type* __hi2) const
{
    for (; __lo2 != __hi2; ++__lo1, ++__lo2)
    {
        if (__lo1 == __hi1 || *__lo1 < *__lo2)
            return -1;
        if (*__lo2 < *__lo1)
            return 1;
    }
    return __lo1 != __hi1;
}

template <class _CharT>
long
collate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const
{
    size_t __h = 0;
    const size_t __sr = 8 * sizeof(size_t) - 8;
    const size_t __mask = size_t(0xF) << (__sr + 4);
    for(const char_type* __p = __lo; __p != __hi; ++__p)
    {
        __h = (__h << 4) + static_cast<size_t>(*__p);
        size_t __g = __h & __mask;
        __h ^= __g | (__g >> __sr);
    }
    return static_cast<long>(__h);
}

extern template class __attribute__ ((__visibility__("default"))) collate<char>;
extern template class __attribute__ ((__visibility__("default"))) collate<wchar_t>;



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) collate_byname;

template <>
class __attribute__ ((__visibility__("default"))) collate_byname<char>
    : public collate<char>
{
    locale_t __l;
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <>
class __attribute__ ((__visibility__("default"))) collate_byname<wchar_t>
    : public collate<wchar_t>
{
    locale_t __l;
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();

    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT, class _Traits, class _Allocator>
bool
locale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,
                   const basic_string<_CharT, _Traits, _Allocator>& __y) const
{
    return std::__1::use_facet<std::__1::collate<_CharT> >(*this).compare(
                                       __x.data(), __x.data() + __x.size(),
                                       __y.data(), __y.data() + __y.size()) < 0;
}



class __attribute__ ((__visibility__("default"))) ctype_base
{
public:
# 385 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 3
    typedef __uint32_t mask;





    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask cntrl = 0x00000200L;
    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask punct = 0x00002000L;
    static const mask xdigit = 0x00010000L;




    static const mask blank = 0x00020000L;
# 447 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 3
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ctype_base() {}
};

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype;

template <>
class __attribute__ ((__visibility__("default"))) ctype<wchar_t>
    : public locale::facet,
      public ctype_base
{
public:
    typedef wchar_t char_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit ctype(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return do_is(__m, __c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        return do_is(__low, __high, __vec);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_is(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_not(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;

protected:
    ~ctype();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <>
class __attribute__ ((__visibility__("default"))) ctype<char>
    : public locale::facet, public ctype_base
{
    const mask* __tab_;
    bool __del_;
public:
    typedef char char_type;

    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        for (; __low != __high; ++__low, ++__vec)
            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;


    static const size_t table_size = (1 <<8 );



    __attribute__ ((__visibility__("hidden"), __always_inline__)) const mask* table() const noexcept {return __tab_;}
    static const mask* classic_table() noexcept;
# 666 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__locale" 3
protected:
    ~ctype();
    virtual char_type do_toupper(char_type __c) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type __c) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char __c) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;
    virtual char do_narrow(char_type __c, char __dfault) const;
    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype_byname;

template <>
class __attribute__ ((__visibility__("default"))) ctype_byname<char>
    : public ctype<char>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
};

template <>
class __attribute__ ((__visibility__("default"))) ctype_byname<wchar_t>
    : public ctype<wchar_t>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isspace(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isprint(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
iscntrl(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
islower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isalpha(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ispunct(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isxdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isalnum(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isgraph(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
toupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).toupper(__c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
tolower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).tolower(__c);
}



class __attribute__ ((__visibility__("default"))) codecvt_base
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) codecvt_base() {}
    enum result {ok, partial, error, noconv};
};



template <class _InternT, class _ExternT, class _StateT> class __attribute__ ((__type_visibility__("default"))) codecvt;



template <>
class __attribute__ ((__visibility__("default"))) codecvt<char, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};



template <>
class __attribute__ ((__visibility__("default"))) codecvt<wchar_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    locale_t __l;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    explicit codecvt(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    explicit codecvt(const char*, size_t __refs = 0);

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};



template <>
class __attribute__ ((__visibility__("default"))) codecvt<char16_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};



template <>
class __attribute__ ((__visibility__("default"))) codecvt<char32_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};



template <class _InternT, class _ExternT, class _StateT>
class __attribute__ ((__type_visibility__("default"))) codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT>
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt_byname(const char* __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt_byname(const string& __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}
protected:
    ~codecvt_byname();
};

template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()
{
}

extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<wchar_t, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char16_t, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char32_t, char, mbstate_t>;

[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_runtime_error(const char*);

template <size_t _Np>
struct __narrow_to_utf8
{
    template <class _OutputIterator, class _CharT>
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
};

template <>
struct __narrow_to_utf8<8>
{
    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        for (; __wb < __we; ++__wb, ++__s)
            *__s = *__wb;
        return __s;
    }
};

template <>
struct __narrow_to_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char16_t* __wn = (const char16_t*)__wb;
            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <>
struct __narrow_to_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char32_t* __wn = (const char32_t*)__wb;
            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <size_t _Np>
struct __widen_from_utf8
{
    template <class _OutputIterator>
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
};

template <>
struct __widen_from_utf8<8>
{
    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        for (; __nb < __ne; ++__nb, ++__s)
            *__s = *__nb;
        return __s;
    }
};

template <>
struct __widen_from_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char16_t __buf[__sz];
            char16_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = (wchar_t)*__p;
            __nb = __nn;
        }
        return __s;
    }
};

template <>
struct __widen_from_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char32_t __buf[__sz];
            char32_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = (wchar_t)*__p;
            __nb = __nn;
        }
        return __s;
    }
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct;

template <>
class __attribute__ ((__visibility__("default"))) numpunct<char>
    : public locale::facet
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};

template <>
class __attribute__ ((__visibility__("default"))) numpunct<wchar_t>
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct_byname;

template <>
class __attribute__ ((__visibility__("default"))) numpunct_byname<char>
: public numpunct<char>
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

template <>
class __attribute__ ((__visibility__("default"))) numpunct_byname<wchar_t>
: public numpunct<wchar_t>
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

} }
# 217 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ios" 2 3
# 225 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ios" 3


namespace std {inline namespace __1 {

typedef ptrdiff_t streamsize;

class __attribute__ ((__visibility__("default"))) ios_base
{
public:
    class __attribute__ ((__visibility__("default"))) failure;

    typedef unsigned int fmtflags;
    static const fmtflags boolalpha = 0x0001;
    static const fmtflags dec = 0x0002;
    static const fmtflags fixed = 0x0004;
    static const fmtflags hex = 0x0008;
    static const fmtflags internal = 0x0010;
    static const fmtflags left = 0x0020;
    static const fmtflags oct = 0x0040;
    static const fmtflags right = 0x0080;
    static const fmtflags scientific = 0x0100;
    static const fmtflags showbase = 0x0200;
    static const fmtflags showpoint = 0x0400;
    static const fmtflags showpos = 0x0800;
    static const fmtflags skipws = 0x1000;
    static const fmtflags unitbuf = 0x2000;
    static const fmtflags uppercase = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield = dec | oct | hex;
    static const fmtflags floatfield = scientific | fixed;

    typedef unsigned int iostate;
    static const iostate badbit = 0x1;
    static const iostate eofbit = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;

    typedef unsigned int openmode;
    static const openmode app = 0x01;
    static const openmode ate = 0x02;
    static const openmode binary = 0x04;
    static const openmode in = 0x08;
    static const openmode out = 0x10;
    static const openmode trunc = 0x20;

    enum seekdir {beg, cur, end};
# 281 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ios" 3
    class __attribute__ ((__visibility__("default"))) Init;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags flags() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags flags(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags setf(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void unsetf(fmtflags __mask);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize precision() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize precision(streamsize __prec);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize width() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize width(streamsize __wide);


    locale imbue(const locale& __loc);
    locale getloc() const;


    static int xalloc();
    long& iword(int __index);
    void*& pword(int __index);


    virtual ~ios_base();


    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int __index);
    void register_callback(event_callback __fn, int __index);

private:
    ios_base(const ios_base&);
    ios_base& operator=(const ios_base&);

public:
    static bool sync_with_stdio(bool __sync = true);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate rdstate() const;
    void clear(iostate __state = goodbit);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void setstate(iostate __state);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool good() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool eof() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool fail() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool bad() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate exceptions() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void exceptions(iostate __iostate);

    void __set_badbit_and_consider_rethrow();
    void __set_failbit_and_consider_rethrow();

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ios_base() {
               }

    void init(void* __sb);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void* rdbuf() const {return __rdbuf_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
        clear();
    }

    void __call_callbacks(event);
    void copyfmt(const ios_base&);
    void move(ios_base&);
    void swap(ios_base&) noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void set_rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
    }

private:

    fmtflags __fmtflags_;
    streamsize __precision_;
    streamsize __width_;
    iostate __rdstate_;
    iostate __exceptions_;
    void* __rdbuf_;
    void* __loc_;
    event_callback* __fn_;
    int* __index_;
    size_t __event_size_;
    size_t __event_cap_;



    static atomic<int> __xindex_;



    long* __iarray_;
    size_t __iarray_size_;
    size_t __iarray_cap_;
    void** __parray_;
    size_t __parray_size_;
    size_t __parray_cap_;
};


enum class __attribute__ ((__type_visibility__("default"))) io_errc
{
    stream = 1
};


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<io_errc> : public true_type { };






__attribute__ ((__visibility__("default")))
const error_category& iostream_category() noexcept;

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_code
make_error_code(io_errc __e) noexcept
{
    return error_code(static_cast<int>(__e), iostream_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_condition
make_error_condition(io_errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), iostream_category());
}

class __attribute__ ((__visibility__("default"))) ios_base::failure
    : public system_error
{
public:
    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
    virtual ~failure() throw();
};

class __attribute__ ((__visibility__("default"))) ios_base::Init
{
public:
    Init();
    ~Init();
};



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::flags() const
{
    return __fmtflags_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ = __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ |= __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::unsetf(fmtflags __mask)
{
    __fmtflags_ &= ~__mask;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl, fmtflags __mask)
{
    fmtflags __r = __fmtflags_;
    unsetf(__mask);
    __fmtflags_ |= __fmtfl & __mask;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::precision() const
{
    return __precision_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::precision(streamsize __prec)
{
    streamsize __r = __precision_;
    __precision_ = __prec;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::width() const
{
    return __width_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::width(streamsize __wide)
{
    streamsize __r = __width_;
    __width_ = __wide;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::iostate
ios_base::rdstate() const
{
    return __rdstate_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::setstate(iostate __state)
{
    clear(__rdstate_ | __state);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::good() const
{
    return __rdstate_ == 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::eof() const
{
    return (__rdstate_ & eofbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::fail() const
{
    return (__rdstate_ & (failbit | badbit)) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::bad() const
{
    return (__rdstate_ & badbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::iostate
ios_base::exceptions() const
{
    return __exceptions_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::exceptions(iostate __iostate)
{
    __exceptions_ = __iostate;
    clear(__rdstate_);
}
# 582 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ios" 3
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ios
    : public ios_base
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
# 604 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ios" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit operator bool() const {return !fail();}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator!() const {return fail();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate rdstate() const {return ios_base::rdstate();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void clear(iostate __state = goodbit) {ios_base::clear(__state);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void setstate(iostate __state) {ios_base::setstate(__state);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool good() const {return ios_base::good();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool eof() const {return ios_base::eof();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool fail() const {return ios_base::fail();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool bad() const {return ios_base::bad();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate exceptions() const {return ios_base::exceptions();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
    virtual ~basic_ios();


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream<char_type, traits_type>* tie() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);

    basic_ios& copyfmt(const basic_ios& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type fill() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type fill(char_type __ch);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    locale imbue(const locale& __loc);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ios() {
                }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void init(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void move(basic_ios& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void move(basic_ios&& __rhs) {move(__rhs);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_ios& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);
private:
    basic_ostream<char_type, traits_type>* __tie_;
     mutable int_type __fill_;
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)
{
    init(__sb);
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::init(__sb);
    __tie_ = 0;
    __fill_ = traits_type::eof();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie() const
{
    return __tie_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)
{
    basic_ostream<char_type, traits_type>* __r = __tie_;
    __tie_ = __tiestr;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf() const
{
    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    basic_streambuf<char_type, traits_type>* __r = rdbuf();
    ios_base::rdbuf(__sb);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale
basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
{
    locale __r = getloc();
    ios_base::imbue(__loc);
    if (rdbuf())
        rdbuf()->pubimbue(__loc);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char
basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
{
    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
    return use_facet<ctype<char_type> >(getloc()).widen(__c);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill() const
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
        __fill_ = widen(' ');
    return __fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill(char_type __ch)
{
    char_type __r = __fill_;
    __fill_ = __ch;
    return __r;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
{
    if (this != &__rhs)
    {
        __call_callbacks(erase_event);
        ios_base::copyfmt(__rhs);
        __tie_ = __rhs.__tie_;
        __fill_ = __rhs.__fill_;
        __call_callbacks(copyfmt_event);
        exceptions(__rhs.exceptions());
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::move(basic_ios& __rhs)
{
    ios_base::move(__rhs);
    __tie_ = __rhs.__tie_;
    __rhs.__tie_ = 0;
    __fill_ = __rhs.__fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) noexcept
{
    ios_base::swap(__rhs);
    std::__1::swap(__tie_, __rhs.__tie_);
    std::__1::swap(__fill_, __rhs.__fill_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::set_rdbuf(__sb);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
boolalpha(ios_base& __str)
{
    __str.setf(ios_base::boolalpha);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noboolalpha(ios_base& __str)
{
    __str.unsetf(ios_base::boolalpha);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showbase(ios_base& __str)
{
    __str.setf(ios_base::showbase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowbase(ios_base& __str)
{
    __str.unsetf(ios_base::showbase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showpoint(ios_base& __str)
{
    __str.setf(ios_base::showpoint);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowpoint(ios_base& __str)
{
    __str.unsetf(ios_base::showpoint);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showpos(ios_base& __str)
{
    __str.setf(ios_base::showpos);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowpos(ios_base& __str)
{
    __str.unsetf(ios_base::showpos);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
skipws(ios_base& __str)
{
    __str.setf(ios_base::skipws);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noskipws(ios_base& __str)
{
    __str.unsetf(ios_base::skipws);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
uppercase(ios_base& __str)
{
    __str.setf(ios_base::uppercase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
nouppercase(ios_base& __str)
{
    __str.unsetf(ios_base::uppercase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
unitbuf(ios_base& __str)
{
    __str.setf(ios_base::unitbuf);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
nounitbuf(ios_base& __str)
{
    __str.unsetf(ios_base::unitbuf);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
internal(ios_base& __str)
{
    __str.setf(ios_base::internal, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
left(ios_base& __str)
{
    __str.setf(ios_base::left, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
right(ios_base& __str)
{
    __str.setf(ios_base::right, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
dec(ios_base& __str)
{
    __str.setf(ios_base::dec, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
hex(ios_base& __str)
{
    __str.setf(ios_base::hex, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
oct(ios_base& __str)
{
    __str.setf(ios_base::oct, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
fixed(ios_base& __str)
{
    __str.setf(ios_base::fixed, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
scientific(ios_base& __str)
{
    __str.setf(ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
hexfloat(ios_base& __str)
{
    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
defaultfloat(ios_base& __str)
{
    __str.unsetf(ios_base::floatfield);
    return __str;
}

template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;

    __stream_type& __stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;

    __save_flags(const __save_flags&);
    __save_flags& operator=(const __save_flags&);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __save_flags(__stream_type& __stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
        {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};

} }
# 39 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iostream" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/streambuf" 1 3
# 117 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/streambuf" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 121 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/streambuf" 2 3

namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_streambuf
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    virtual ~basic_streambuf();


    inline __attribute__((__visibility__("default"), __always_inline__))
    locale pubimbue(const locale& __loc) {
        imbue(__loc);
        locale __r = __loc_;
        __loc_ = __loc;
        return __r;
    }

    inline __attribute__((__visibility__("default"), __always_inline__))
    locale getloc() const { return __loc_; }


    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)
    { return setbuf(__s, __n); }

    inline __attribute__((__visibility__("default"), __always_inline__))
    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekoff(__off, __way, __which); }

    inline __attribute__((__visibility__("default"), __always_inline__))
    pos_type pubseekpos(pos_type __sp,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekpos(__sp, __which); }

    inline __attribute__((__visibility__("default"), __always_inline__))
    int pubsync() { return sync(); }



    inline __attribute__((__visibility__("default"), __always_inline__))
    streamsize in_avail() {
        if (__ninp_ < __einp_)
            return static_cast<streamsize>(__einp_ - __ninp_);
        return showmanyc();
    }

    inline __attribute__((__visibility__("default"), __always_inline__))
    int_type snextc() {
        if (sbumpc() == traits_type::eof())
            return traits_type::eof();
        return sgetc();
    }

    inline __attribute__((__visibility__("default"), __always_inline__))
    int_type sbumpc() {
        if (__ninp_ == __einp_)
            return uflow();
        return traits_type::to_int_type(*__ninp_++);
    }

    inline __attribute__((__visibility__("default"), __always_inline__))
    int_type sgetc() {
        if (__ninp_ == __einp_)
            return underflow();
        return traits_type::to_int_type(*__ninp_);
    }

    inline __attribute__((__visibility__("default"), __always_inline__))
    streamsize sgetn(char_type* __s, streamsize __n)
    { return xsgetn(__s, __n); }


    inline __attribute__((__visibility__("default"), __always_inline__))
    int_type sputbackc(char_type __c) {
        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
            return pbackfail(traits_type::to_int_type(__c));
        return traits_type::to_int_type(*--__ninp_);
    }

    inline __attribute__((__visibility__("default"), __always_inline__))
    int_type sungetc() {
        if (__binp_ == __ninp_)
          return pbackfail();
        return traits_type::to_int_type(*--__ninp_);
    }


    inline __attribute__((__visibility__("default"), __always_inline__))
    int_type sputc(char_type __c) {
        if (__nout_ == __eout_)
            return overflow(traits_type::to_int_type(__c));
        *__nout_++ = __c;
        return traits_type::to_int_type(__c);
    }

    inline __attribute__((__visibility__("default"), __always_inline__))
    streamsize sputn(const char_type* __s, streamsize __n)
    { return xsputn(__s, __n); }

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& __rhs);
    basic_streambuf& operator=(const basic_streambuf& __rhs);
    void swap(basic_streambuf& __rhs);


    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* eback() const {return __binp_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* gptr() const {return __ninp_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* egptr() const {return __einp_;}

    inline __attribute__((__visibility__("default"), __always_inline__))
    void gbump(int __n) { __ninp_ += __n; }

    inline __attribute__((__visibility__("default"), __always_inline__))
    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {
        __binp_ = __gbeg;
        __ninp_ = __gnext;
        __einp_ = __gend;
    }


    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* pbase() const {return __bout_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* pptr() const {return __nout_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* epptr() const {return __eout_;}

    inline __attribute__((__visibility__("default"), __always_inline__))
    void pbump(int __n) { __nout_ += __n; }

    inline __attribute__((__visibility__("default"), __always_inline__))
    void setp(char_type* __pbeg, char_type* __pend) {
        __bout_ = __nout_ = __pbeg;
        __eout_ = __pend;
    }



    virtual void imbue(const locale& __loc);


    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual int sync();


    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* __s, streamsize __n);
    virtual int_type underflow();
    virtual int_type uflow();


    virtual int_type pbackfail(int_type __c = traits_type::eof());


    virtual streamsize xsputn(const char_type* __s, streamsize __n);
    virtual int_type overflow(int_type __c = traits_type::eof());

private:
    locale __loc_;
    char_type* __binp_;
    char_type* __ninp_;
    char_type* __einp_;
    char_type* __bout_;
    char_type* __nout_;
    char_type* __eout_;
};

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(0),
      __ninp_(0),
      __einp_(0),
      __bout_(0),
      __nout_(0),
      __eout_(0)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>&
basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)
{
    __loc_ = __sb.__loc_;
    __binp_ = __sb.__binp_;
    __ninp_ = __sb.__ninp_;
    __einp_ = __sb.__einp_;
    __bout_ = __sb.__bout_;
    __nout_ = __sb.__nout_;
    __eout_ = __sb.__eout_;
    return *this;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)
{
    std::__1::swap(__loc_, __sb.__loc_);
    std::__1::swap(__binp_, __sb.__binp_);
    std::__1::swap(__ninp_, __sb.__ninp_);
    std::__1::swap(__einp_, __sb.__einp_);
    std::__1::swap(__bout_, __sb.__bout_);
    std::__1::swap(__nout_, __sb.__nout_);
    std::__1::swap(__eout_, __sb.__eout_);
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)
{
    return this;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)
{
    const int_type __eof = traits_type::eof();
    int_type __c;
    streamsize __i = 0;
    while(__i < __n)
    {
        if (__ninp_ < __einp_)
        {
            const streamsize __len = std::__1::min(__einp_ - __ninp_, __n - __i);
            traits_type::copy(__s, __ninp_, __len);
            __s += __len;
            __i += __len;
            this->gbump(__len);
        }
        else if ((__c = uflow()) != __eof)
        {
            *__s = traits_type::to_char_type(__c);
            ++__s;
            ++__i;
        }
        else
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow()
{
    if (underflow() == traits_type::eof())
        return traits_type::eof();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type)
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)
{
    streamsize __i = 0;
    int_type __eof = traits_type::eof();
    while( __i < __n)
    {
        if (__nout_ >= __eout_)
        {
            if (overflow(traits_type::to_int_type(*__s)) == __eof)
                break;
            ++__s;
            ++__i;
        }
        else
        {
            streamsize __chunk_size = std::__1::min(__eout_ - __nout_, __n - __i);
            traits_type::copy(__nout_, __s, __chunk_size);
            __nout_ += __chunk_size;
            __s += __chunk_size;
            __i += __chunk_size;
        }
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type)
{
    return traits_type::eof();
}


extern template class __attribute__ ((__visibility__("default"))) basic_streambuf<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_streambuf<wchar_t>;

extern template class __attribute__ ((__visibility__("default"))) basic_ios<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ios<wchar_t>;


} }
# 40 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iostream" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/istream" 1 3
# 163 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/istream" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ostream" 1 3
# 140 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ostream" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/locale" 1 3
# 197 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/locale" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/nl_types.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/nl_types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 1 3 4
# 84 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_char.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_char.h" 3 4
typedef unsigned char u_char;
# 85 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_short.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_short.h" 3 4
typedef unsigned short u_short;
# 86 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_int.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_u_int.h" 3 4
typedef unsigned int u_int;
# 87 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4

typedef unsigned long u_long;


typedef unsigned short ushort;
typedef unsigned int uint;


typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_caddr_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_caddr_t.h" 3 4
typedef char * caddr_t;
# 100 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4

typedef int32_t daddr_t;



typedef u_int32_t fixpt_t;


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_blkcnt_t.h" 3 4
typedef __darwin_blkcnt_t blkcnt_t;
# 108 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_blksize_t.h" 3 4
typedef __darwin_blksize_t blksize_t;
# 109 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_gid_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_gid_t.h" 3 4
typedef __darwin_gid_t gid_t;
# 110 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_in_addr_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_in_addr_t.h" 3 4
typedef __uint32_t in_addr_t;
# 111 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_in_port_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_in_port_t.h" 3 4
typedef __uint16_t in_port_t;
# 112 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_ino_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_ino_t.h" 3 4
typedef __darwin_ino_t ino_t;
# 113 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_ino64_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_ino64_t.h" 3 4
typedef __darwin_ino64_t ino64_t;
# 116 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_key_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_key_t.h" 3 4
typedef __int32_t key_t;
# 119 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_nlink_t.h" 3 4
typedef __uint16_t nlink_t;
# 121 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4




typedef int32_t segsz_t;
typedef int32_t swblk_t;
# 138 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 3 4
static inline __int32_t major(__uint32_t _x)
{
 return (__int32_t)(((__uint32_t)_x >> 24) & 0xff);
}

static inline __int32_t minor(__uint32_t _x)
{
 return (__int32_t)((_x) & 0xffffff);
}

static inline dev_t makedev(__uint32_t _major, __uint32_t _minor)
{
 return (dev_t)(((_major) << 24) | (_minor));
}
# 167 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_useconds_t.h" 3 4
typedef __darwin_useconds_t useconds_t;
# 168 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_suseconds_t.h" 3 4
typedef __darwin_suseconds_t suseconds_t;
# 169 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_rsize_t.h" 3 4
typedef __darwin_size_t rsize_t;
# 172 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_errno_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_errno_t.h" 3 4
typedef int errno_t;
# 173 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4








# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fd_def.h" 1 3 4
# 48 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fd_def.h" 3 4
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;
}


static inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[(unsigned long)_n/(sizeof(__int32_t) * 8)] & ((__int32_t)(((unsigned long)1)<<((unsigned long)_n % (sizeof(__int32_t) * 8)))));
}
# 182 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4




typedef __int32_t fd_mask;








# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 195 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fd_set.h" 1 3 4
# 196 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 197 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 198 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 199 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fd_copy.h" 1 3 4
# 202 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 229 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 3 4
typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 230 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 3 4
typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 231 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/types.h" 2 3 4
# 46 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/nl_types.h" 2 3 4
# 89 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/nl_types.h" 3 4
typedef struct __nl_cat_d {
 void *__data;
 int __size;
} *nl_catd;


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_nl_item.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/_types/_nl_item.h" 3 4
typedef __darwin_nl_item nl_item;
# 95 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/nl_types.h" 2 3 4

extern "C" {
nl_catd catopen(const char *, int);
char *catgets(nl_catd, int, int, const char *)
 __attribute__((__format_arg__(4)));
int catclose(nl_catd);
}
# 198 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/locale" 2 3







# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__bsd_locale_defaults.h" 1 3
# 206 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/locale" 2 3
# 212 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/locale" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 216 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/locale" 2 3


namespace std {inline namespace __1 {
# 249 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/locale" 3
template <class _InputIterator, class _ForwardIterator, class _Ctype>
__attribute__ ((__visibility__("hidden")))
_ForwardIterator
__scan_keyword(_InputIterator& __b, _InputIterator __e,
               _ForwardIterator __kb, _ForwardIterator __ke,
               const _Ctype& __ct, ios_base::iostate& __err,
               bool __case_sensitive = true)
{
    typedef typename iterator_traits<_InputIterator>::value_type _CharT;
    size_t __nkw = static_cast<size_t>(std::__1::distance(__kb, __ke));
    const unsigned char __doesnt_match = '\0';
    const unsigned char __might_match = '\1';
    const unsigned char __does_match = '\2';
    unsigned char __statbuf[100];
    unsigned char* __status = __statbuf;
    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);
    if (__nkw > sizeof(__statbuf))
    {
        __status = (unsigned char*)malloc(__nkw);
        if (__status == 0)
            __throw_bad_alloc();
        __stat_hold.reset(__status);
    }
    size_t __n_might_match = __nkw;
    size_t __n_does_match = 0;

    unsigned char* __st = __status;
    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
    {
        if (!__ky->empty())
            *__st = __might_match;
        else
        {
            *__st = __does_match;
            --__n_might_match;
            ++__n_does_match;
        }
    }

    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
    {

        _CharT __c = *__b;
        if (!__case_sensitive)
            __c = __ct.toupper(__c);
        bool __consume = false;






        __st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
        {
            if (*__st == __might_match)
            {
                _CharT __kc = (*__ky)[__indx];
                if (!__case_sensitive)
                    __kc = __ct.toupper(__kc);
                if (__c == __kc)
                {
                    __consume = true;
                    if (__ky->size() == __indx+1)
                    {
                        *__st = __does_match;
                        --__n_might_match;
                        ++__n_does_match;
                    }
                }
                else
                {
                    *__st = __doesnt_match;
                    --__n_might_match;
                }
            }
        }

        if (__consume)
        {
            ++__b;



            if (__n_might_match + __n_does_match > 1)
            {
                __st = __status;
                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
                {
                    if (*__st == __does_match && __ky->size() != __indx+1)
                    {
                        *__st = __doesnt_match;
                        --__n_does_match;
                    }
                }
            }
        }
    }

    if (__b == __e)
        __err |= ios_base::eofbit;

    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)
        if (*__st == __does_match)
            break;
    if (__kb == __ke)
        __err |= ios_base::failbit;
    return __kb;
}

struct __attribute__ ((__visibility__("default"))) __num_get_base
{
    static const int __num_get_buf_sz = 40;

    static int __get_base(ios_base&);
    static const char __src[33];
};

__attribute__ ((__visibility__("default")))
void __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,
                      ios_base::iostate& __err);

template <class _CharT>
struct __num_get
    : protected __num_get_base
{
    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                                      _CharT& __thousands_sep);

    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,
                                   char* __a, char*& __a_end,
                                   _CharT __decimal_point, _CharT __thousands_sep,
                                   const string& __grouping, unsigned* __g,
                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);

    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);
# 423 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/locale" 3
};


template <class _CharT>
string
__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}


template <class _CharT>
string
__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                    _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __decimal_point = __np.decimal_point();
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
int

__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)






{
    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
    {
        *__a_end++ = __ct == __atoms[24] ? '+' : '-';
        __dc = 0;
        return 0;
    }
    if (__grouping.size() != 0 && __ct == __thousands_sep)
    {
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
    if (__f >= 24)
        return -1;
    switch (__base)
    {
    case 8:
    case 10:
        if (__f >= __base)
            return -1;
        break;
    case 16:
        if (__f < 22)
            break;
        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
        {
            __dc = 0;
            *__a_end++ = __src[__f];
            return 0;
        }
        return -1;
    }
    *__a_end++ = __src[__f];
    ++__dc;
    return 0;
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,
                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,
                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)
{
    if (__ct == __decimal_point)
    {
        if (!__in_units)
            return -1;
        __in_units = false;
        *__a_end++ = '.';
        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
            *__g_end++ = __dc;
        return 0;
    }
    if (__ct == __thousands_sep && __grouping.size() != 0)
    {
        if (!__in_units)
            return -1;
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
    if (__f >= 32)
        return -1;
    char __x = __src[__f];
    if (__x == '-' || __x == '+')
    {
        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))
        {
            *__a_end++ = __x;
            return 0;
        }
        return -1;
    }
    if (__x == 'x' || __x == 'X')
        __exp = 'P';
    else if ((__x & 0x5F) == __exp)
    {
        __exp |= 0x80;
        if (__in_units)
        {
            __in_units = false;
            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
                *__g_end++ = __dc;
        }
    }
    *__a_end++ = __x;
    if (__f >= 22)
        return 0;
    ++__dc;
    return 0;
}

extern template struct __attribute__ ((__visibility__("default"))) __num_get<char>;
extern template struct __attribute__ ((__visibility__("default"))) __num_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_get
    : public locale::facet,
      private __num_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit num_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, bool& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned short& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned int& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, float& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, void*& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~num_get() {}

    template <class _Fp>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_floating_point
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Fp& __v) const;

    template <class _Signed>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_signed
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Signed& __v) const;

    template <class _Unsigned>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_unsigned
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Unsigned& __v) const;


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, bool& __v) const;

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned short& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned int& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, float& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, void*& __v) const;
};

template <class _CharT, class _InputIterator>
locale::id
num_get<_CharT, _InputIterator>::id;

template <class _Tp>
_Tp
__num_get_signed_integral(const char* __a, const char* __a_end,
                          ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        long long __ll = strtoll_l(__a, &__p2, __base, 0);
        typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 __ll < numeric_limits<_Tp>::min() ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            if (__ll > 0)
                return numeric_limits<_Tp>::max();
            else
                return numeric_limits<_Tp>::min();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
_Tp
__num_get_unsigned_integral(const char* __a, const char* __a_end,
                            ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        if (*__a == '-')
        {
            __err = ios_base::failbit;
            return 0;
        }
        typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        unsigned long long __ll = strtoull_l(__a, &__p2, __base, 0);
        typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            return numeric_limits<_Tp>::max();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp __do_strtod(const char* __a, char** __p2);

template <>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
float __do_strtod<float>(const char* __a, char** __p2) {
    return strtof_l(__a, __p2, 0);
}

template <>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
double __do_strtod<double>(const char* __a, char** __p2) {
    return strtod_l(__a, __p2, 0);
}

template <>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long double __do_strtod<long double>(const char* __a, char** __p2) {
    return strtold_l(__a, __p2, 0);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden")))
_Tp
__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)
{
    if (__a != __a_end)
    {
        typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        _Tp __ld = __do_strtod<_Tp>(__a, &__p2);
        typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34)
            __err = ios_base::failbit;
        return __ld;
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        bool& __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
    {
        long __lv = -1;
        __b = do_get(__b, __e, __iob, __err, __lv);
        switch (__lv)
        {
        case 0:
            __v = false;
            break;
        case 1:
            __v = true;
            break;
        default:
            __v = true;
            __err = ios_base::failbit;
            break;
        }
        return __b;
    }
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());
    typedef typename numpunct<_CharT>::string_type string_type;
    const string_type __names[2] = {__np.truename(), __np.falsename()};
    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,
                                            __ct, __err);
    __v = __i == __names;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Signed& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type __atoms[__atoms_size];
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Unsigned& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type __atoms[__atoms_size];
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Fp& __v) const
{


    char_type __atoms[32];
    char_type __decimal_point;
    char_type __thousands_sep;
    string __grouping = this->__stage2_float_prep(__iob, __atoms,
                                                  __decimal_point,
                                                  __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    bool __in_units = true;
    char __exp = 'E';
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
                                      __decimal_point, __thousands_sep,
                                      __grouping, __g, __g_end,
                                      __dc, __atoms))
            break;
    }
    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_float<_Fp>(__a, __a_end, __err);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        void*& __v) const
{

    int __base = 16;

    char_type __atoms[26];
    char_type __thousands_sep = 0;
    string __grouping;
    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,
                                                    __num_get_base::__src + 26, __atoms);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping,
                                    __g, __g_end, __atoms))
            break;
    }

    __buf.resize(__a_end - __a);
    if (sscanf_l(__buf.c_str(), 0, "%p", &__v) != 1)
        __err = ios_base::failbit;

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) num_get<char>;
extern template class __attribute__ ((__visibility__("default"))) num_get<wchar_t>;

struct __attribute__ ((__visibility__("default"))) __num_put_base
{
protected:
    static void __format_int(char* __fmt, const char* __len, bool __signd,
                             ios_base::fmtflags __flags);
    static bool __format_float(char* __fmt, const char* __len,
                               ios_base::fmtflags __flags);
    static char* __identify_padding(char* __nb, char* __ne,
                                    const ios_base& __iob);
};

template <class _CharT>
struct __num_put
    : protected __num_put_base
{
    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,
                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                      const locale& __loc);
    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,
                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                        const locale& __loc);
};

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,
                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                         const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    if (__grouping.empty())
    {
        __ct.widen(__nb, __ne, __ob);
        __oe = __ob + (__ne - __nb);
    }
    else
    {
        __oe = __ob;
        char* __nf = __nb;
        if (*__nf == '-' || *__nf == '+')
            *__oe++ = __ct.widen(*__nf++);
        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                                   __nf[1] == 'X'))
        {
            *__oe++ = __ct.widen(*__nf++);
            *__oe++ = __ct.widen(*__nf++);
        }
        reverse(__nf, __ne);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ne; ++__p)
        {
            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
                __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,
                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                           const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    __oe = __ob;
    char* __nf = __nb;
    if (*__nf == '-' || *__nf == '+')
        *__oe++ = __ct.widen(*__nf++);
    char* __ns;
    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                               __nf[1] == 'X'))
    {
        *__oe++ = __ct.widen(*__nf++);
        *__oe++ = __ct.widen(*__nf++);
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isxdigit_l(*__ns, 0))
                break;
    }
    else
    {
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isdigit_l(*__ns, 0))
                break;
    }
    if (__grouping.empty())
    {
        __ct.widen(__nf, __ns, __oe);
        __oe += __ns - __nf;
    }
    else
    {
        reverse(__nf, __ns);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ns; ++__p)
        {
            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    for (__nf = __ns; __nf < __ne; ++__nf)
    {
        if (*__nf == '.')
        {
            *__oe++ = __npt.decimal_point();
            ++__nf;
            break;
        }
        else
            *__oe++ = __ct.widen(*__nf);
    }
    __ct.widen(__nf, __ne, __oe);
    __oe += __ne - __nf;
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

extern template struct __attribute__ ((__visibility__("default"))) __num_put<char>;
extern template struct __attribute__ ((__visibility__("default"))) __num_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_put
    : public locale::facet,
      private __num_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit num_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  bool __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const void* __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~num_put() {}

    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             bool __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             const void* __v) const;
};

template <class _CharT, class _OutputIterator>
locale::id
num_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
__attribute__ ((__visibility__("hidden")))
_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    for (;__ob < __op; ++__ob, ++__s)
        *__s = *__ob;
    for (; __ns; --__ns, ++__s)
        *__s = __fl;
    for (; __ob < __oe; ++__ob, ++__s)
        *__s = *__ob;
    __iob.width(0);
    return __s;
}





template <class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden")))
ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    if (__s.__sbuf_ == nullptr)
        return __s;
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    streamsize __np = __op - __ob;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__ob, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    if (__ns > 0)
    {
        basic_string<_CharT, _Traits> __sp(__ns, __fl);
        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __np = __oe - __op;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__op, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __iob.width(0);
    return __s;
}



template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, bool __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
        return do_put(__s, __iob, __fl, (unsigned long)__v);
    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());
    typedef typename numpunct<char_type>::string_type string_type;




    string_type __nm = __v ? __np.truename() : __np.falsename();

    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
        *__s = *__i;
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long>::digits / 3)
                          + ((numeric_limits<long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 2;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)
                          + ((numeric_limits<long long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 2;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)
                          + ((numeric_limits<unsigned long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 1;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)
                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 1;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);

    else
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
    unique_ptr<char, void(*)(void*)> __nbh(0, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)
            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
        else
            __nc = asprintf_l(&__nb, 0, __fmt, __v);
        if (__nb == 0)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "L";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);

    else
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
    unique_ptr<char, void(*)(void*)> __nbh(0, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)
            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
        else
            __nc = asprintf_l(&__nb, 0, __fmt, __v);
        if (__nb == 0)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, const void* __v) const
{

    char __fmt[6] = "%p";
    const unsigned __nbuf = 20;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __ct.widen(__nar, __ne, __o);
    __oe = __o + (__ne - __nar);
    if (__np == __ne)
        __op = __oe;
    else
        __op = __o + (__np - __nar);


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

extern template class __attribute__ ((__visibility__("default"))) num_put<char>;
extern template class __attribute__ ((__visibility__("default"))) num_put<wchar_t>;

template <class _CharT, class _InputIterator>
__attribute__ ((__visibility__("hidden")))
int
__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
{

    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return 0;
    }

    _CharT __c = *__b;
    if (!__ct.is(ctype_base::digit, __c))
    {
        __err |= ios_base::failbit;
        return 0;
    }
    int __r = __ct.narrow(__c, 0) - '0';
    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)
    {

        __c = *__b;
        if (!__ct.is(ctype_base::digit, __c))
            return __r;
        __r = __r * 10 + __ct.narrow(__c, 0) - '0';
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __r;
}

class __attribute__ ((__visibility__("default"))) time_base
{
public:
    enum dateorder {no_order, dmy, mdy, ymd, ydm};
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_c_storage
{
protected:
    typedef basic_string<_CharT> string_type;

    virtual const string_type* __weeks() const;
    virtual const string_type* __months() const;
    virtual const string_type* __am_pm() const;
    virtual const string_type& __c() const;
    virtual const string_type& __r() const;
    virtual const string_type& __x() const;
    virtual const string_type& __X() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~__time_get_c_storage() {}
};

template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__weeks() const;
template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__months() const;
template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__am_pm() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__c() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__r() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__x() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__X() const;

template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__weeks() const;
template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__months() const;
template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__c() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__r() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__x() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__X() const;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef time_base::dateorder dateorder;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    dateorder date_order() const
    {
        return this->do_date_order();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_time(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_date(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                          ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_weekday(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                            ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_monthname(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_year(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm *__tm,
                  char __fmt, char __mod = 0) const
    {
        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
    }

    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm* __tm,
                  const char_type* __fmtb, const char_type* __fmte) const;

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_get() {}

    virtual dateorder do_date_order() const;
    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                                     ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                                       ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, tm* __tm,
                             char __fmt, char __mod) const;
private:
    void __get_white_space(iter_type& __b, iter_type __e,
                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;

    void __get_weekdayname(int& __m,
                           iter_type& __b, iter_type __e,
                           ios_base::iostate& __err,
                           const ctype<char_type>& __ct) const;
    void __get_monthname(int& __m,
                         iter_type& __b, iter_type __e,
                         ios_base::iostate& __err,
                         const ctype<char_type>& __ct) const;
    void __get_day(int& __d,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_month(int& __m,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_year(int& __y,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_year4(int& __y,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_hour(int& __d,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_12_hour(int& __h,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_am_pm(int& __h,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_minute(int& __m,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_second(int& __s,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_weekday(int& __w,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_day_year_num(int& __w,
                            iter_type& __b, iter_type __e,
                            ios_base::iostate& __err,
                            const ctype<char_type>& __ct) const;
};

template <class _CharT, class _InputIterator>
locale::id
time_get<_CharT, _InputIterator>::id;



template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,
                                                    iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{

    const string_type* __wk = this->__weeks();
    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;
    if (__i < 14)
        __w = __i % 7;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_monthname(int& __m,
                                                  iter_type& __b, iter_type __e,
                                                  ios_base::iostate& __err,
                                                  const ctype<char_type>& __ct) const
{

    const string_type* __month = this->__months();
    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;
    if (__i < 24)
        __m = __i % 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day(int& __d,
                                            iter_type& __b, iter_type __e,
                                            ios_base::iostate& __err,
                                            const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_month(int& __m,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
    if (!(__err & ios_base::failbit) && __t <= 11)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year(int& __y,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
    {
        if (__t < 69)
            __t += 2000;
        else if (69 <= __t && __t <= 99)
            __t += 1900;
        __y = __t - 1900;
    }
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year4(int& __y,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
        __y = __t - 1900;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_hour(int& __h,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 23)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_12_hour(int& __h,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_minute(int& __m,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 59)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_second(int& __s,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 60)
        __s = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekday(int& __w,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
    if (!(__err & ios_base::failbit) && __t <= 6)
        __w = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,
                                                     iter_type& __b, iter_type __e,
                                                     ios_base::iostate& __err,
                                                     const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
    if (!(__err & ios_base::failbit) && __t <= 365)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{
    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        ;
    if (__b == __e)
        __err |= ios_base::eofbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_am_pm(int& __h,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    const string_type* __ap = this->__am_pm();
    if (__ap[0].size() + __ap[1].size() == 0)
    {
        __err |= ios_base::failbit;
        return;
    }
    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;
    if (__i == 0 && __h == 12)
        __h = 0;
    else if (__i == 1 && __h < 12)
        __h += 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return;
    }
    if (__ct.narrow(*__b, 0) != '%')
        __err |= ios_base::failbit;
    else if(++__b == __e)
        __err |= ios_base::eofbit;
}



template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
                                      ios_base& __iob,
                                      ios_base::iostate& __err, tm* __tm,
                                      const char_type* __fmtb, const char_type* __fmte) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __err = ios_base::goodbit;
    while (__fmtb != __fmte && __err == ios_base::goodbit)
    {
        if (__b == __e)
        {
            __err = ios_base::failbit;
            break;
        }
        if (__ct.narrow(*__fmtb, 0) == '%')
        {
            if (++__fmtb == __fmte)
            {
                __err = ios_base::failbit;
                break;
            }
            char __cmd = __ct.narrow(*__fmtb, 0);
            char __opt = '\0';
            if (__cmd == 'E' || __cmd == '0')
            {
                if (++__fmtb == __fmte)
                {
                    __err = ios_base::failbit;
                    break;
                }
                __opt = __cmd;
                __cmd = __ct.narrow(*__fmtb, 0);
            }
            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
            ++__fmtb;
        }
        else if (__ct.is(ctype_base::space, *__fmtb))
        {
            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
                ;
            for ( ; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                ;
        }
        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
        {
            ++__b;
            ++__fmtb;
        }
        else
            __err = ios_base::failbit;
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder
time_get<_CharT, _InputIterator>::do_date_order() const
{
    return mdy;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const string_type& __fmt = this->__x();
    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
                                                 ios_base& __iob,
                                                 ios_base::iostate& __err,
                                                 tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
                                                   ios_base& __iob,
                                                   ios_base::iostate& __err,
                                                   tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_year(__tm->tm_year, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                         ios_base& __iob,
                                         ios_base::iostate& __err, tm* __tm,
                                         char __fmt, char) const
{
    __err = ios_base::goodbit;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    switch (__fmt)
    {
    case 'a':
    case 'A':
        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'b':
    case 'B':
    case 'h':
        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'c':
        {
        const string_type& __fm = this->__c();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'd':
    case 'e':
        __get_day(__tm->tm_mday, __b, __e, __err, __ct);
        break;
    case 'D':
        {
        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'F':
        {
        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'H':
        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'I':
        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'j':
        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
        break;
    case 'm':
        __get_month(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'M':
        __get_minute(__tm->tm_min, __b, __e, __err, __ct);
        break;
    case 'n':
    case 't':
        __get_white_space(__b, __e, __err, __ct);
        break;
    case 'p':
        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'r':
        {
        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'R':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'S':
        __get_second(__tm->tm_sec, __b, __e, __err, __ct);
        break;
    case 'T':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'w':
        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'x':
        return do_get_date(__b, __e, __iob, __err, __tm);
    case 'X':
        {
        const string_type& __fm = this->__X();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'y':
        __get_year(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case 'Y':
        __get_year4(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case '%':
        __get_percent(__b, __e, __err, __ct);
        break;
    default:
        __err |= ios_base::failbit;
    }
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) time_get<char>;
extern template class __attribute__ ((__visibility__("default"))) time_get<wchar_t>;

class __attribute__ ((__visibility__("default"))) __time_get
{
protected:
    locale_t __loc_;

    __time_get(const char* __nm);
    __time_get(const string& __nm);
    ~__time_get();
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_storage
    : public __time_get
{
protected:
    typedef basic_string<_CharT> string_type;

    string_type __weeks_[14];
    string_type __months_[24];
    string_type __am_pm_[2];
    string_type __c_;
    string_type __r_;
    string_type __x_;
    string_type __X_;

    explicit __time_get_storage(const char* __nm);
    explicit __time_get_storage(const string& __nm);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~__time_get_storage() {}

    time_base::dateorder __do_date_order() const;

private:
    void init(const ctype<_CharT>&);
    string_type __analyze(char __fmt, const ctype<_CharT>&);
};

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT>
{
public:
    typedef time_base::dateorder dateorder;
    typedef _InputIterator iter_type;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get_byname(const char* __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get_byname(const string& __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_get_byname() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual dateorder do_date_order() const {return this->__do_date_order();}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __weeks() const {return this->__weeks_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __months() const {return this->__months_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __am_pm() const {return this->__am_pm_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __c() const {return this->__c_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __r() const {return this->__r_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __x() const {return this->__x_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __X() const {return this->__X_;}
};

extern template class __attribute__ ((__visibility__("default"))) time_get_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) time_get_byname<wchar_t>;

class __attribute__ ((__visibility__("default"))) __time_put
{
    locale_t __loc_;
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __time_put() : __loc_(0) {}
    __time_put(const char* __nm);
    __time_put(const string& __nm);
    ~__time_put();
    void __do_put(char* __nb, char*& __ne, const tm* __tm,
                  char __fmt, char __mod) const;
    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,
                  char __fmt, char __mod) const;
};

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put
    : public locale::facet,
      private __time_put
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,
                  const char_type* __pb, const char_type* __pe) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const tm* __tm, char __fmt, char __mod = 0) const
    {
        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_put() {}
    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,
                             char __fmt, char __mod) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(const char* __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(const string& __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
};

template <class _CharT, class _OutputIterator>
locale::id
time_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,
                                       char_type __fl, const tm* __tm,
                                       const char_type* __pb,
                                       const char_type* __pe) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    for (; __pb != __pe; ++__pb)
    {
        if (__ct.narrow(*__pb, 0) == '%')
        {
            if (++__pb == __pe)
            {
                *__s++ = __pb[-1];
                break;
            }
            char __mod = 0;
            char __fmt = __ct.narrow(*__pb, 0);
            if (__fmt == 'E' || __fmt == 'O')
            {
                if (++__pb == __pe)
                {
                    *__s++ = __pb[-2];
                    *__s++ = __pb[-1];
                    break;
                }
                __mod = __fmt;
                __fmt = __ct.narrow(*__pb, 0);
            }
            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        }
        else
            *__s++ = *__pb;
    }
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,
                                          char_type, const tm* __tm,
                                          char __fmt, char __mod) const
{
    char_type __nar[100];
    char_type* __nb = __nar;
    char_type* __ne = __nb + 100;
    __do_put(__nb, __ne, __tm, __fmt, __mod);
    return std::__1::copy(__nb, __ne, __s);
}

extern template class __attribute__ ((__visibility__("default"))) time_put<char>;
extern template class __attribute__ ((__visibility__("default"))) time_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put_byname
    : public time_put<_CharT, _OutputIterator>
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put_byname(const char* __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put_byname(const string& __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_put_byname() {}
};

extern template class __attribute__ ((__visibility__("default"))) time_put_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) time_put_byname<wchar_t>;



class __attribute__ ((__visibility__("default"))) money_base
{
public:
    enum part {none, space, symbol, sign, value};
    struct pattern {char field[4];};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) money_base() {}
};



template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct
    : public locale::facet,
      public money_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type curr_symbol() const {return do_curr_symbol();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type positive_sign() const {return do_positive_sign();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type negative_sign() const {return do_negative_sign();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) int frac_digits() const {return do_frac_digits();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pattern pos_format() const {return do_pos_format();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pattern neg_format() const {return do_neg_format();}

    static locale::id id;
    static const bool intl = _International;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~moneypunct() {}

    virtual char_type do_decimal_point() const {return numeric_limits<char_type>::max();}
    virtual char_type do_thousands_sep() const {return numeric_limits<char_type>::max();}
    virtual string do_grouping() const {return string();}
    virtual string_type do_curr_symbol() const {return string_type();}
    virtual string_type do_positive_sign() const {return string_type();}
    virtual string_type do_negative_sign() const {return string_type(1, '-');}
    virtual int do_frac_digits() const {return 0;}
    virtual pattern do_pos_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
    virtual pattern do_neg_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
};

template <class _CharT, bool _International>
locale::id
moneypunct<_CharT, _International>::id;

template <class _CharT, bool _International>
const bool
moneypunct<_CharT, _International>::intl;

extern template class __attribute__ ((__visibility__("default"))) moneypunct<char, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<char, true>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, true>;



template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct_byname
    : public moneypunct<_CharT, _International>
{
public:
    typedef money_base::pattern pattern;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~moneypunct_byname() {}

    virtual char_type do_decimal_point() const {return __decimal_point_;}
    virtual char_type do_thousands_sep() const {return __thousands_sep_;}
    virtual string do_grouping() const {return __grouping_;}
    virtual string_type do_curr_symbol() const {return __curr_symbol_;}
    virtual string_type do_positive_sign() const {return __positive_sign_;}
    virtual string_type do_negative_sign() const {return __negative_sign_;}
    virtual int do_frac_digits() const {return __frac_digits_;}
    virtual pattern do_pos_format() const {return __pos_format_;}
    virtual pattern do_neg_format() const {return __neg_format_;}

private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;

    void init(const char*);
};

template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<char, false>::init(const char*);
template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<char, true>::init(const char*);
template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<wchar_t, false>::init(const char*);
template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<wchar_t, true>::init(const char*);

extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, true>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, true>;



template <class _CharT>
class __money_get
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __money_get() {}

    static void __gather_info(bool __intl, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __psn,
                              string_type& __nsn, int& __fd);
};

template <class _CharT>
void
__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __psn,
                                   string_type& __nsn, int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

extern template class __attribute__ ((__visibility__("default"))) __money_get<char>;
extern template class __attribute__ ((__visibility__("default"))) __money_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_get
    : public locale::facet,
      private __money_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit money_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, string_type& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    static locale::id id;

protected:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~money_get() {}

    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             long double& __v) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             string_type& __v) const;

private:
    static bool __do_get(iter_type& __b, iter_type __e,
                         bool __intl, const locale& __loc,
                         ios_base::fmtflags __flags, ios_base::iostate& __err,
                         bool& __neg, const ctype<char_type>& __ct,
                         unique_ptr<char_type, void(*)(void*)>& __wb,
                         char_type*& __wn, char_type* __we);
};

template <class _CharT, class _InputIterator>
locale::id
money_get<_CharT, _InputIterator>::id;

__attribute__ ((__visibility__("default"))) void __do_nothing(void*);

template <class _Tp>
__attribute__ ((__visibility__("hidden")))
void
__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)
{
    bool __owns = __b.get_deleter() != __do_nothing;
    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?
                       2 * __cur_cap : numeric_limits<size_t>::max();
    if (__new_cap == 0)
        __new_cap = sizeof(_Tp);
    size_t __n_off = static_cast<size_t>(__n - __b.get());
    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);
    if (__t == 0)
        __throw_bad_alloc();
    if (__owns)
        __b.release();
    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);
    __new_cap /= sizeof(_Tp);
    __n = __b.get() + __n_off;
    __e = __b.get() + __new_cap;
}


template <class _CharT, class _InputIterator>
bool
money_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,
                                            bool __intl, const locale& __loc,
                                            ios_base::fmtflags __flags,
                                            ios_base::iostate& __err,
                                            bool& __neg,
                                            const ctype<char_type>& __ct,
                                            unique_ptr<char_type, void(*)(void*)>& __wb,
                                            char_type*& __wn, char_type* __we)
{
    const unsigned __bz = 100;
    unsigned __gbuf[__bz];
    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
    unsigned* __gn = __gb.get();
    unsigned* __ge = __gn + __bz;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __psn;
    string_type __nsn;


    string_type __spaces;
    int __fd;
    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
                                       __sym, __psn, __nsn, __fd);
    const string_type* __trailing_sign = 0;
    __wn = __wb.get();
    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::space:
            if (__p != 3)
            {
                if (__ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
                else
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            ((void)0);
        case money_base::none:
            if (__p != 3)
            {
                while (__b != __e && __ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
            }
            break;
        case money_base::sign:
            if (__psn.size() + __nsn.size() > 0)
            {
                if (__psn.size() == 0 || __nsn.size() == 0)
                {
                    if (__psn.size() > 0)
                    {
                        if (*__b == __psn[0])
                        {
                            ++__b;
                            if (__psn.size() > 1)
                                __trailing_sign = &__psn;
                        }
                        else
                            __neg = true;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                }
                else
                {
                    if (*__b == __psn[0])
                    {
                        ++__b;
                        if (__psn.size() > 1)
                            __trailing_sign = &__psn;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                    else
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                }
            }
            break;
        case money_base::symbol:
            {
            bool __more_needed = __trailing_sign ||
                                 (__p < 2) ||
                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
            bool __sb = (__flags & ios_base::showbase) != 0;
            if (__sb || __more_needed)
            {
                typename string_type::const_iterator __sym_space_end = __sym.begin();
                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
                                __pat.field[__p - 1] == money_base::space)) {


                    while (__sym_space_end != __sym.end() &&
                           __ct.is(ctype_base::space, *__sym_space_end))
                        ++__sym_space_end;
                    const size_t __num_spaces = __sym_space_end - __sym.begin();
                    if (__num_spaces > __spaces.size() ||
                        !equal(__spaces.end() - __num_spaces, __spaces.end(),
                               __sym.begin())) {



                        __sym_space_end = __sym.begin();
                    }
                }
                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                while (__sym_curr_char != __sym.end() && __b != __e &&
                       *__b == *__sym_curr_char) {
                    ++__b;
                    ++__sym_curr_char;
                }
                if (__sb && __sym_curr_char != __sym.end())
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            }
            break;
        case money_base::value:
            {
            unsigned __ng = 0;
            for (; __b != __e; ++__b)
            {
                char_type __c = *__b;
                if (__ct.is(ctype_base::digit, __c))
                {
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = __c;
                    ++__ng;
                }
                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
                {
                    if (__gn == __ge)
                        __double_or_nothing(__gb, __gn, __ge);
                    *__gn++ = __ng;
                    __ng = 0;
                }
                else
                    break;
            }
            if (__gb.get() != __gn && __ng > 0)
            {
                if (__gn == __ge)
                    __double_or_nothing(__gb, __gn, __ge);
                *__gn++ = __ng;
            }
            if (__fd > 0)
            {
                if (__b == __e || *__b != __dp)
                {
                    __err |= ios_base::failbit;
                    return false;
                }
                for (++__b; __fd > 0; --__fd, ++__b)
                {
                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = *__b;
                }
            }
            if (__wn == __wb.get())
            {
                __err |= ios_base::failbit;
                return false;
            }
            }
            break;
        }
    }
    if (__trailing_sign)
    {
        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
        {
            if (__b == __e || *__b != (*__trailing_sign)[__i])
            {
                __err |= ios_base::failbit;
                return false;
            }
        }
    }
    if (__gb.get() != __gn)
    {
        ios_base::iostate __et = ios_base::goodbit;
        __check_grouping(__grp, __gb.get(), __gn, __et);
        if (__et)
        {
            __err |= ios_base::failbit;
            return false;
        }
    }
    return true;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          long double& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        const char __src[] = "0123456789";
        char_type __atoms[sizeof(__src)-1];
        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
        char __nbuf[__bz];
        char* __nc = __nbuf;
        unique_ptr<char, void(*)(void*)> __h(0, free);
        if (__wn - __wb.get() > __bz-2)
        {
            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
            if (__h.get() == 0)
                __throw_bad_alloc();
            __nc = __h.get();
        }
        if (__neg)
            *__nc++ = '-';
        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
            *__nc = __src[find(__atoms, std::__1::end(__atoms), *__w) - __atoms];
        *__nc = char();
        if (sscanf(__nbuf, "%Lf", &__v) != 1)
            __throw_runtime_error("money_get error");
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          string_type& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        __v.clear();
        if (__neg)
            __v.push_back(__ct.widen('-'));
        char_type __z = __ct.widen('0');
        char_type* __w;
        for (__w = __wb.get(); __w < __wn-1; ++__w)
            if (*__w != __z)
                break;
        __v.append(__w, __wn);
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) money_get<char>;
extern template class __attribute__ ((__visibility__("default"))) money_get<wchar_t>;



template <class _CharT>
class __money_put
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __money_put() {}

    static void __gather_info(bool __intl, bool __neg, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __sn,
                              int& __fd);
    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,
                         ios_base::fmtflags __flags,
                         const char_type* __db, const char_type* __de,
                         const ctype<char_type>& __ct, bool __neg,
                         const money_base::pattern& __pat, char_type __dp,
                         char_type __ts, const string& __grp,
                         const string_type& __sym, const string_type& __sn,
                         int __fd);
};

template <class _CharT>
void
__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __sn,
                                   int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

template <class _CharT>
void
__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,
                              ios_base::fmtflags __flags,
                              const char_type* __db, const char_type* __de,
                              const ctype<char_type>& __ct, bool __neg,
                              const money_base::pattern& __pat, char_type __dp,
                              char_type __ts, const string& __grp,
                              const string_type& __sym, const string_type& __sn,
                              int __fd)
{
    __me = __mb;
    for (unsigned __p = 0; __p < 4; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::none:
            __mi = __me;
            break;
        case money_base::space:
            __mi = __me;
            *__me++ = __ct.widen(' ');
            break;
        case money_base::sign:
            if (!__sn.empty())
                *__me++ = __sn[0];
            break;
        case money_base::symbol:
            if (!__sym.empty() && (__flags & ios_base::showbase))
                __me = std::__1::copy(__sym.begin(), __sym.end(), __me);
            break;
        case money_base::value:
            {

            char_type* __t = __me;

            if (__neg)
                ++__db;

            const char_type* __d;
            for (__d = __db; __d < __de; ++__d)
                if (!__ct.is(ctype_base::digit, *__d))
                    break;

            if (__fd > 0)
            {
                int __f;
                for (__f = __fd; __d > __db && __f > 0; --__f)
                    *__me++ = *--__d;
                char_type __z = __f > 0 ? __ct.widen('0') : char_type();
                for (; __f > 0; --__f)
                    *__me++ = __z;
                *__me++ = __dp;
            }

            if (__d == __db)
            {
                *__me++ = __ct.widen('0');
            }
            else
            {
                unsigned __ng = 0;
                unsigned __ig = 0;
                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
                                              : static_cast<unsigned>(__grp[__ig]);
                while (__d != __db)
                {
                    if (__ng == __gl)
                    {
                        *__me++ = __ts;
                        __ng = 0;
                        if (++__ig < __grp.size())
                            __gl = __grp[__ig] == numeric_limits<char>::max() ?
                                        numeric_limits<unsigned>::max() :
                                        static_cast<unsigned>(__grp[__ig]);
                    }
                    *__me++ = *--__d;
                    ++__ng;
                }
            }

            reverse(__t, __me);
            }
            break;
        }
    }

    if (__sn.size() > 1)
        __me = std::__1::copy(__sn.begin()+1, __sn.end(), __me);

    if ((__flags & ios_base::adjustfield) == ios_base::left)
        __mi = __me;
    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
        __mi = __mb;
}

extern template class __attribute__ ((__visibility__("default"))) __money_put<char>;
extern template class __attribute__ ((__visibility__("default"))) __money_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_put
    : public locale::facet,
      private __money_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit money_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  long double __units) const
    {
        return do_put(__s, __intl, __iob, __fl, __units);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  const string_type& __digits) const
    {
        return do_put(__s, __intl, __iob, __fl, __digits);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~money_put() {}

    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, long double __units) const;
    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, const string_type& __digits) const;
};

template <class _CharT, class _OutputIterator>
locale::id
money_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           long double __units) const
{

    const size_t __bs = 100;
    char __buf[__bs];
    char* __bb = __buf;
    char_type __digits[__bs];
    char_type* __db = __digits;
    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, "%.0Lf", __units));
    unique_ptr<char, void(*)(void*)> __hn(0, free);
    unique_ptr<char_type, void(*)(void*)> __hd(0, free);

    if (__n > __bs-1)
    {
        __n = static_cast<size_t>(asprintf_l(&__bb, 0, "%.0Lf", __units));
        if (__bb == 0)
            __throw_bad_alloc();
        __hn.reset(__bb);
        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));
        if (__hd == nullptr)
            __throw_bad_alloc();
        __db = __hd.get();
    }

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    __ct.widen(__bb, __bb + __n, __db);
    bool __neg = __n > 0 && __bb[0] == '-';
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[__bs];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __hw(0, free);
    size_t __exn = static_cast<int>(__n) > __fd ?
                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +
                    __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > __bs)
    {
        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __hw.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __db, __db + __n, __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           const string_type& __digits) const
{

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[100];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __h(0, free);
    size_t __exn = static_cast<int>(__digits.size()) > __fd ?
                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > 100)
    {
        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __h.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __digits.data(), __digits.data() + __digits.size(), __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

extern template class __attribute__ ((__visibility__("default"))) money_put<char>;
extern template class __attribute__ ((__visibility__("default"))) money_put<wchar_t>;



class __attribute__ ((__visibility__("default"))) messages_base
{
public:
    typedef ptrdiff_t catalog;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) messages_base() {}
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages
    : public locale::facet,
      public messages_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    catalog open(const basic_string<char>& __nm, const locale& __loc) const
    {
        return do_open(__nm, __loc);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    string_type get(catalog __c, int __set, int __msgid,
                    const string_type& __dflt) const
    {
        return do_get(__c, __set, __msgid, __dflt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void close(catalog __c) const
    {
        do_close(__c);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~messages() {}

    virtual catalog do_open(const basic_string<char>&, const locale&) const;
    virtual string_type do_get(catalog, int __set, int __msgid,
                               const string_type& __dflt) const;
    virtual void do_close(catalog) const;
};

template <class _CharT>
locale::id
messages<_CharT>::id;

template <class _CharT>
typename messages<_CharT>::catalog
messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const
{

    catalog __cat = (catalog)catopen(__nm.c_str(), 1);
    if (__cat != -1)
        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));
    return __cat;



}

template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
                         const string_type& __dflt) const
{

    string __ndflt;
    __narrow_to_utf8<sizeof(char_type)*8>()(back_inserter(__ndflt),
                                                       __dflt.c_str(),
                                                       __dflt.c_str() + __dflt.size());
    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
    string_type __w;
    __widen_from_utf8<sizeof(char_type)*8>()(back_inserter(__w),
                                                        __n, __n + strlen(__n));
    return __w;



}

template <class _CharT>
void
messages<_CharT>::do_close(catalog __c) const
{

    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    catclose(__cat);

}

extern template class __attribute__ ((__visibility__("default"))) messages<char>;
extern template class __attribute__ ((__visibility__("default"))) messages<wchar_t>;

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages_byname
    : public messages<_CharT>
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages_byname(const char*, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages_byname(const string&, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~messages_byname() {}
};

extern template class __attribute__ ((__visibility__("default"))) messages_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) messages_byname<wchar_t>;

template<class _Codecvt, class _Elem = wchar_t,
         class _Wide_alloc = allocator<_Elem>,
         class _Byte_alloc = allocator<char> >
class __attribute__ ((__type_visibility__("default"))) wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
    typedef typename _Codecvt::state_type state_type;
    typedef typename wide_string::traits_type::int_type int_type;

private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    _Codecvt* __cvtptr_;
    state_type __cvtstate_;
    size_t __cvtcount_;

    wstring_convert(const wstring_convert& __wc);
    wstring_convert& operator=(const wstring_convert& __wc);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit wstring_convert(_Codecvt* __pcvt = new _Codecvt);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wstring_convert(_Codecvt* __pcvt, state_type __state);
    explicit wstring_convert(const byte_string& __byte_err,
                    const wide_string& __wide_err = wide_string());

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wstring_convert(wstring_convert&& __wc);

    ~wstring_convert();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(char __byte)
        {return from_bytes(&__byte, &__byte+1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(const char* __ptr)
        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(const byte_string& __str)
        {return from_bytes(__str.data(), __str.data() + __str.size());}
    wide_string from_bytes(const char* __first, const char* __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(_Elem __wchar)
        {return to_bytes(&__wchar, &__wchar+1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(const _Elem* __wptr)
        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(const wide_string& __wstr)
        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}
    byte_string to_bytes(const _Elem* __first, const _Elem* __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t converted() const noexcept {return __cvtcount_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    state_type state() const {return __cvtstate_;}
};

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt)
        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt, state_type __state)
        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)
        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
          __cvtstate_(), __cvtcount_(0)
{
    __cvtptr_ = new _Codecvt;
}



template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(wstring_convert&& __wc)
        : __byte_err_string_(std::__1::move(__wc.__byte_err_string_)),
          __wide_err_string_(std::__1::move(__wc.__wide_err_string_)),
          __cvtptr_(__wc.__cvtptr_),
          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)
{
    __wc.__cvtptr_ = nullptr;
}



template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()
{
    delete __cvtptr_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    from_bytes(const char* __frm, const char* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        wide_string __ws(2*(__frm_end - __frm), _Elem());
        if (__frm != __frm_end)
            __ws.resize(__ws.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            _Elem* __to = &__ws[0];
            _Elem* __to_end = __to + __ws.size();
            const char* __frm_nxt;
            do
            {
                _Elem* __to_nxt;
                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
                                          __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __ws.resize(__to - &__ws[0]);

                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __ws.resize(__to_nxt - &__ws[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__ws[0];
                    __ws.resize(2 * __s);
                    __to = &__ws[0] + __s;
                    __to_end = &__ws[0] + __ws.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
            return __ws;
    }

    if (__wide_err_string_.empty())
        __throw_range_error("wstring_convert: from_bytes error");

    return __wide_err_string_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    to_bytes(const _Elem* __frm, const _Elem* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        byte_string __bs(2*(__frm_end - __frm), char());
        if (__frm != __frm_end)
            __bs.resize(__bs.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            char* __to = &__bs[0];
            char* __to_end = __to + __bs.size();
            const _Elem* __frm_nxt;
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
                                           __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);

                    __bs.append((const char*)__frm, (const char*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__bs[0];
                    __bs.resize(2 * __s);
                    __to = &__bs[0] + __s;
                    __to_end = &__bs[0] + __bs.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
        {
            size_t __s = __bs.size();
            __bs.resize(__bs.capacity());
            char* __to = &__bs[0] + __s;
            char* __to_end = __to + __bs.size();
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
                if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __sp = __to_nxt - &__bs[0];
                    __bs.resize(2 * __sp);
                    __to = &__bs[0] + __sp;
                    __to_end = &__bs[0] + __bs.size();
                }
            } while (__r == codecvt_base::partial);
            if (__r == codecvt_base::ok)
                return __bs;
        }
    }

    if (__byte_err_string_.empty())
        __throw_range_error("wstring_convert: to_bytes error");

    return __byte_err_string_;
}

template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
class __attribute__ ((__type_visibility__("default"))) wbuffer_convert
    : public basic_streambuf<_Elem, _Tr>
{
public:

    typedef _Elem char_type;
    typedef _Tr traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename _Codecvt::state_type state_type;

private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    streambuf* __bufptr_;
    _Codecvt* __cv_;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;

    wbuffer_convert(const wbuffer_convert&);
    wbuffer_convert& operator=(const wbuffer_convert&);
public:
    explicit wbuffer_convert(streambuf* __bytebuf = 0,
            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());
    ~wbuffer_convert();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streambuf* rdbuf() const {return __bufptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streambuf* rdbuf(streambuf* __bytebuf)
    {
        streambuf* __r = __bufptr_;
        __bufptr_ = __bytebuf;
        return __r;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    state_type state() const {return __st_;}

protected:
    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,
                                                            streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();

private:
    bool __read_mode();
    void __write_mode();
    wbuffer_convert* __close();
};

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::
    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
    : __extbuf_(0),
      __extbufnext_(0),
      __extbufend_(0),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
{
    setbuf(0, 4096);
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
{
    __close();
    delete __cv_;
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == 0)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = *this->gptr();
            }
        }
        else
        {
             ((void)0);
             if (__extbufend_ != __extbufnext_)
                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            streamsize __nmemb = std::__1::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;


            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
            if (__nr != 0)
            {
                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->egptr(), __inext);
                if (__r == codecvt_base::noconv)
                {
                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_,
                               (char_type*) const_cast<char *>(__extbufend_));
                    __c = *this->gptr();
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = *this->gptr();
                }
            }
        }
    }
    else
        __c = *this->gptr();
    if (this->eback() == &__1buf)
        this->setg(0, 0, 0);
    return __c;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
{
    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this->pbase();
    char_type* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == 0)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                return traits_type::eof();
        }
        else
        {
            char* __extbe = __extbuf_;
            codecvt_base::result __r;
            do
            {
                const char_type* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this->setp(const_cast<char_type *>(__e), this->pptr());
                        this->pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)
{
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode __om)
{
    int __width = __cv_->encoding();
    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
        return pos_type(off_type(-1));

    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
        return pos_type(off_type(-1));
    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
    __r.state(__st_);
    return __r;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
{
    if (__cv_ == 0 || __bufptr_ == 0 || sync())
        return pos_type(off_type(-1));
    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
        return pos_type(off_type(-1));
    return __sp;
}

template <class _Codecvt, class _Elem, class _Tr>
int
wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return 0;
    if (__cm_ & ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (__bufptr_->pubsync())
            return -1;
    }
    else if (__cm_ & ios_base::in)
    {
        off_type __c;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    reverse(this->gptr(), this->egptr());
                    codecvt_base::result __r;
                    const char_type* __e = this->gptr();
                    char* __extbe;
                    do
                    {
                        __r = __cv_->out(__st_, __e, this->egptr(), __e,
                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
                        switch (__r)
                        {
                        case codecvt_base::noconv:
                            __c += this->egptr() - this->gptr();
                            break;
                        case codecvt_base::ok:
                        case codecvt_base::partial:
                            __c += __extbe - __extbuf_;
                            break;
                        default:
                            return -1;
                        }
                    } while (__r == codecvt_base::partial);
                }
            }
        }
        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
            return -1;
        this->setg(0, 0, 0);
        __cm_ = 0;
    }
    return 0;
}

template <class _Codecvt, class _Elem, class _Tr>
bool
wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
        this->setp(0, 0);
        if (__always_noconv_)
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template <class _Codecvt, class _Elem, class _Tr>
void
wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
        this->setg(0, 0, 0);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(0, 0);
        __cm_ = ios_base::out;
    }
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
{
    wbuffer_convert* __rt = 0;
    if (__cv_ != 0 && __bufptr_ != 0)
    {
        __rt = this;
        if ((__cm_ & ios_base::out) && sync())
            __rt = 0;
    }
    return __rt;
}

} }
# 141 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ostream" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/bitset" 1 3
# 117 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/bitset" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__bit_reference" 1 3
# 19 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__bit_reference" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__bit_reference" 2 3


namespace std {inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp>
struct __has_storage_type
{
    static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;

    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, false>;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator ~() const noexcept
        {return !static_cast<bool>(*this);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference& operator=(bool __x) noexcept
    {
        if (__x)
            *__seg_ |= __mask_;
        else
            *__seg_ &= ~__mask_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference& operator=(const __bit_reference& __x) noexcept
        {return operator=(static_cast<bool>(__x));}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void flip() noexcept {*__seg_ ^= __mask_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, false> operator&() const noexcept
        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false>
{
};

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, bool& __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(bool& __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
class __bit_const_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__const_storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;
    friend class __bit_iterator<_Cp, true>;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_const_reference(const __bit_reference<_Cp>& __x) noexcept
        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, true> operator&() const noexcept
        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    __bit_const_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}

    __bit_const_reference& operator=(const __bit_const_reference& __x);
};



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        if (*__first.__seg_)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(*__first.__seg_)));

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    {
        __storage_type __b = ~*__first.__seg_;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(~*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(~*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(~*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp>
void
__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ &= ~__m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ &= ~__m;
    }
}

template <class _Cp>
void
__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ |= __m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ |= __m;
    }
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)
{
    if (__n > 0)
    {
        if (__value_)
            __fill_n_true(__first, __n);
        else
            __fill_n_false(__first, __n);
    }
}



template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)
{
    std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        __storage_type __nw = __n / __bits_per_word;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__first.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        __result.__seg_ += __nw;

        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
            else
                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b = *__first.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            ++__result.__seg_;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b >> __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__first.__ctz_ == __result.__ctz_)
        return __copy_aligned(__first, __last, __result);
    return __copy_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
            __storage_type __b = *__last.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                       __result.__ctz_) % __bits_per_word);

         }



        __storage_type __nw = __n / __bits_per_word;
        __result.__seg_ -= __nw;
        __last.__seg_ -= __nw;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__last.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            *--__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz_l = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
            __storage_type __b = *__last.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
            if (__ddn > 0)
            {
                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __last.__ctz_)
                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                else
                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
            }
            if (__dn > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                __last.__ctz_ -= __dn + __ddn;
                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
            }

         }



        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) >> __clz_r;
        for (; __n >= __bits_per_word; __n -= __bits_per_word)
        {
            __storage_type __b = *--__last.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> __clz_r;
            *--__result.__seg_ &= __m;
            *__result.__seg_ |= __b << __result.__ctz_;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                     __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__last.__ctz_ == __result.__ctz_)
        return __copy_backward_aligned(__first, __last, __result);
    return __copy_backward_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy_backward(__first, __last, __result);
}



template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
            swap(*__first.__seg_, *__result.__seg_);

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
            {
                unsigned __s = __result.__ctz_ - __first.__ctz_;
                *__result.__seg_ |= __b1 << __s;
                *__first.__seg_ |= __b2 >> __s;
            }
            else
            {
                unsigned __s = __first.__ctz_ - __result.__ctz_;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
            }
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                unsigned __s = __first.__ctz_ + __ddn;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b1 = *__first.__seg_;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ = __b2 >> __result.__ctz_;
            ++__result.__seg_;
            __b2 = *__result.__seg_ & ~__m;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b1 >> __clz_r;
            *__first.__seg_ |= __b2 << __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ |= __b2 >> __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 >> __dn;
                *__first.__seg_ |= __b2 << __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class __C1, class __C2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __swap_ranges_aligned(__first1, __last1, __first2);
    return __swap_ranges_unaligned(__first1, __last1, __first2);
}



template <class _Cp>
struct __bit_array
{
    typedef typename _Cp::difference_type difference_type;
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    static const unsigned _Np = 4;

    difference_type __size_;
    __storage_type __word_[_Np];

    __attribute__ ((__visibility__("hidden"), __always_inline__)) static difference_type capacity()
        {return static_cast<difference_type>(_Np * __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __bit_array(difference_type __s) : __size_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator begin()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator end()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                                                  static_cast<unsigned>(__size_ % __bits_per_word));
    }
};

template <class _Cp>
__bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
{
    typedef __bit_iterator<_Cp, false> _I1;
    typedef typename _I1::difference_type difference_type;
    difference_type __d1 = __middle - __first;
    difference_type __d2 = __last - __middle;
    _I1 __r = __first + __d2;
    while (__d1 != 0 && __d2 != 0)
    {
        if (__d1 <= __d2)
        {
            if (__d1 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d1);
                std::__1::copy(__first, __middle, __b.begin());
                std::__1::copy(__b.begin(), __b.end(), std::__1::copy(__middle, __last, __first));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = std::__1::swap_ranges(__first, __middle, __middle);
                __first = __middle;
                __middle = __mp;
                __d2 -= __d1;
            }
        }
        else
        {
            if (__d2 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d2);
                std::__1::copy(__middle, __last, __b.begin());
                std::__1::copy_backward(__b.begin(), __b.end(), std::__1::copy_backward(__first, __middle, __last));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = __first + __d2;
                std::__1::swap_ranges(__first, __mp, __middle);
                __first = __mp;
                __d1 -= __d2;
            }
        }
    }
    return __r;
}



template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                  __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first1.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            if (__first2.__ctz_ > __first1.__ctz_)
            {
                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                    return false;
            }
            else
            {
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                    return false;
            }
            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                    return false;
                __first2.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first1.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
        {
            __storage_type __b = *__first1.__seg_;
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            ++__first2.__seg_;
            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                return false;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first1.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if ((*__first2.__seg_ & __m) != (__b >> __dn))
                    return false;
            }
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
            ++__first2.__seg_;
            ++__first1.__seg_;


        }



        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
            if (*__first2.__seg_ != *__first1.__seg_)
                return false;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __equal_aligned(__first1, __last1, __first2);
    return __equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
public:
    typedef typename _Cp::difference_type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
    typedef random_access_iterator_tag iterator_category;

private:
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                           typename _Cp::__storage_pointer>::type __storage_pointer;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;

    __storage_pointer __seg_;
    unsigned __ctz_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator() noexcept

    : __seg_(nullptr), __ctz_(0)

    {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_iterator(const __bit_iterator<_Cp, false>& __it) noexcept
        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const noexcept
        {return reference(__seg_, __storage_type(1) << __ctz_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator++()
    {
        if (__ctz_ != __bits_per_word-1)
            ++__ctz_;
        else
        {
            __ctz_ = 0;
            ++__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator++(int)
    {
        __bit_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator--()
    {
        if (__ctz_ != 0)
            --__ctz_;
        else
        {
            __ctz_ = __bits_per_word - 1;
            --__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator--(int)
    {
        __bit_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator+=(difference_type __n)
    {
        if (__n >= 0)
            __seg_ += (__n + __ctz_) / __bits_per_word;
        else
            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)
                    / static_cast<difference_type>(__bits_per_word);
        __n &= (__bits_per_word - 1);
        __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator+(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator-(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)
        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const {return *(*this + __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_iterator(__storage_pointer __s, unsigned __ctz) noexcept
        : __seg_(__s), __ctz_(__ctz) {}

    friend typename _Cp::__self;

    friend class __bit_reference<_Cp>;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, true>;
    template <class _Dp> friend struct __bit_array;
    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                  __bit_iterator<_Dp, _IC> __last,
                                                                                  __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                    __bit_iterator<_Dp, _IC> __last,
                                                                                    __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                                                        __bit_iterator<_Dp, _IC> __last,
                                                                        __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                           __bit_iterator<_Dp, _IC> __last,
                                                                                           __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                             __bit_iterator<_Dp, _IC> __last,
                                                                                             __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
                                                                                 __bit_iterator<_Dp, _IC> __last,
                                                                                 __bit_iterator<_Dp, false> __result);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C2, false>);
    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                                          typename _Dp::size_type);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                                           typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} }
# 118 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/bitset" 2 3
# 127 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/bitset" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 131 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/bitset" 2 3


namespace std {inline namespace __1 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> >
{
    static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_[_N_words];

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) noexcept
        {return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator^=(const __bitset& __v) noexcept;

    void flip() noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const
        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const
        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());}

    bool all() const noexcept;
    bool any() const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t __hash_code() const noexcept;
private:





    unsigned long to_ulong(false_type) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unsigned long to_ulong(true_type) const;
    unsigned long long to_ullong(false_type) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unsigned long long to_ullong(true_type) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unsigned long long to_ullong(true_type, false_type) const;
    unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset() noexcept

    : __first_{0}

{



}
# 256 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/bitset" 3
template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset(unsigned long long __v) noexcept


    : __first_{__v}






{



}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::flip() noexcept
{

    size_type __n = _Size;
    __storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <size_t _N_words, size_t _Size>
unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ulong overflow error");

    return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline
unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ullong overflow error");

    return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const
{
    return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
{
    unsigned long long __r = __first_[0];
    for (std::size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
    return __r;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::all() const noexcept
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (~*__p)
            return false;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (~*__p & __m)
            return false;
    }
    return true;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::any() const noexcept
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (*__p)
            return true;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (*__p & __m)
            return true;
    }
    return false;
}

template <size_t _N_words, size_t _Size>
inline
size_t
__bitset<_N_words, _Size>::__hash_code() const noexcept
{
    size_t __h = 0;
    for (size_type __i = 0; __i < _N_words; ++__i)
        __h ^= __first_[__i];
    return __h;
}

template <size_t _Size>
class __bitset<1, _Size>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) noexcept
        {return reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator^=(const __bitset& __v) noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void flip() noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unsigned long to_ulong() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unsigned long long to_ullong() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool all() const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool any() const noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t __hash_code() const noexcept;
};

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset() noexcept
    : __first_(0)
{
}

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset(unsigned long long __v) noexcept
    : __first_(static_cast<__storage_type>(__v))
{
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator&=(const __bitset& __v) noexcept
{
    __first_ &= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator|=(const __bitset& __v) noexcept
{
    __first_ |= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator^=(const __bitset& __v) noexcept
{
    __first_ ^= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::flip() noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    __first_ = ~__first_;
    __first_ &= __m;
}

template <size_t _Size>
inline
unsigned long
__bitset<1, _Size>::to_ulong() const
{
    return __first_;
}

template <size_t _Size>
inline
unsigned long long
__bitset<1, _Size>::to_ullong() const
{
    return __first_;
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::all() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return !(~__first_ & __m);
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::any() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return __first_ & __m;
}

template <size_t _Size>
inline
size_t
__bitset<1, _Size>::__hash_code() const noexcept
{
    return __first_;
}

template <>
class __bitset<0, 0>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit constexpr __bitset(unsigned long long) noexcept;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t) noexcept
        {return reference(0, 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr const_reference __make_ref(size_t) const noexcept
        {return const_reference(0, 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t) noexcept
        {return iterator(0, 0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t) const noexcept
        {return const_iterator(0, 0);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator&=(const __bitset&) noexcept {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator|=(const __bitset&) noexcept {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator^=(const __bitset&) noexcept {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void flip() noexcept {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const {return 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const {return 0;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool all() const noexcept {return true;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool any() const noexcept {return false;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_t __hash_code() const noexcept {return 0;}
};

inline
constexpr
__bitset<0, 0>::__bitset() noexcept
{
}

inline
constexpr
__bitset<0, 0>::__bitset(unsigned long long) noexcept
{
}

template <size_t _Size> class __attribute__ ((__type_visibility__("default"))) bitset;
template <size_t _Size> struct hash<bitset<_Size> >;

template <size_t _Size>
class __attribute__ ((__type_visibility__("default"))) bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
{
public:
    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
    typedef __bitset<__n_words, _Size> base;

public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr bitset() noexcept {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        bitset(unsigned long long __v) noexcept : base(__v) {}
    template<class _CharT>
        explicit bitset(const _CharT* __str,
                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
    template<class _CharT, class _Traits, class _Allocator>
        explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =
                                (basic_string<_CharT,_Traits,_Allocator>::npos),
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bitset& operator&=(const bitset& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bitset& operator|=(const bitset& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bitset& operator^=(const bitset& __rhs) noexcept;
    bitset& operator<<=(size_t __pos) noexcept;
    bitset& operator>>=(size_t __pos) noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bitset& set() noexcept;
    bitset& set(size_t __pos, bool __val = true);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bitset& reset() noexcept;
    bitset& reset(size_t __pos);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bitset operator~() const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bitset& flip() noexcept;
    bitset& flip(size_t __pos);


    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
                              const_reference operator[](size_t __p) const {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_t __p) {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unsigned long to_ulong() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unsigned long long to_ullong() const;
    template <class _CharT, class _Traits, class _Allocator>
        basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
                                                            _CharT __one = _CharT('1')) const;
    template <class _CharT, class _Traits>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                    _CharT __one = _CharT('1')) const;
    template <class _CharT>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                                _CharT __one = _CharT('1')) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0',
                                                                      char __one = '1') const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t count() const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr size_t size() const noexcept {return _Size;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const bitset& __rhs) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const bitset& __rhs) const noexcept;
    bool test(size_t __pos) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool all() const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool any() const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool none() const noexcept {return !any();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bitset operator<<(size_t __pos) const noexcept;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bitset operator>>(size_t __pos) const noexcept;

private:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t __hash_code() const noexcept {return base::__hash_code();}

    friend struct hash<bitset>;
};

template <size_t _Size>
template<class _CharT>
bitset<_Size>::bitset(const _CharT* __str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
    for (size_t __i = 0; __i < __rlen; ++__i)
        if (__str[__i] != __zero && __str[__i] != __one)
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[_Mp - 1 - __i];
        if (__c == __zero)
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
template<class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,
       _CharT __zero, _CharT __one)
{
    if (__pos > __str.size())
        __throw_out_of_range("bitset string pos out of range");

    size_t __rlen = std::__1::min(__n, __str.size() - __pos);
    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
        if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[__pos + _Mp - 1 - __i];
        if (_Traits::eq(__c, __zero))
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) noexcept
{
    base::operator&=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) noexcept
{
    base::operator|=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) noexcept
{
    base::operator^=(__rhs);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator<<=(size_t __pos) noexcept
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
    std::__1::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator>>=(size_t __pos) noexcept
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::set() noexcept
{
    std::__1::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::set(size_t __pos, bool __val)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset set argument out of range");

    (*this)[__pos] = __val;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::reset() noexcept
{
    std::__1::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::reset(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset reset argument out of range");

    (*this)[__pos] = false;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator~() const noexcept
{
    bitset __x(*this);
    __x.flip();
    return __x;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::flip() noexcept
{
    base::flip();
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::flip(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset flip argument out of range");

    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}

template <size_t _Size>
inline
unsigned long
bitset<_Size>::to_ulong() const
{
    return base::to_ulong();
}

template <size_t _Size>
inline
unsigned long long
bitset<_Size>::to_ullong() const
{
    return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
    for (size_t __i = 0; __i < _Size; ++__i)
    {
        if ((*this)[__i])
            __r[_Size - 1 - __i] = __one;
    }
    return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline
basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline
basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline
basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const
{
    return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline
size_t
bitset<_Size>::count() const noexcept
{
    return static_cast<size_t>(std::__1::count(base::__make_iter(0), base::__make_iter(_Size), true));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator==(const bitset& __rhs) const noexcept
{
    return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator!=(const bitset& __rhs) const noexcept
{
    return !(*this == __rhs);
}

template <size_t _Size>
bool
bitset<_Size>::test(size_t __pos) const
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset test argument out of range");

    return (*this)[__pos];
}

template <size_t _Size>
inline
bool
bitset<_Size>::all() const noexcept
{
    return base::all();
}

template <size_t _Size>
inline
bool
bitset<_Size>::any() const noexcept
{
    return base::any();
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r <<= __pos;
    return __r;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r >>= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r &= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r |= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r ^= __y;
    return __r;
}

template <size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >
    : public unary_function<bitset<_Size>, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const bitset<_Size>& __bs) const noexcept
        {return __bs.__hash_code();}
};

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

} }
# 143 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ostream" 2 3
# 146 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ostream" 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream
    : virtual public basic_ios<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__((__visibility__("default"), __always_inline__))
    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)
    { this->init(__sb); }
    virtual ~basic_ostream();
protected:

    inline __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream(basic_ostream&& __rhs);


    inline __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream& operator=(basic_ostream&& __rhs);

    inline __attribute__((__visibility__("default"), __always_inline__))
    void swap(basic_ostream& __rhs)
    { basic_ios<char_type, traits_type>::swap(__rhs); }


    basic_ostream (const basic_ostream& __rhs) = delete;
    basic_ostream& operator=(const basic_ostream& __rhs) = delete;




public:


    class __attribute__ ((__type_visibility__("default"))) sentry;


    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))
    { return __pf(*this); }

    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_ostream& operator<<(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type,traits_type>&))
    { __pf(*this); return *this; }

    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))
    { __pf(*this); return *this; }

    basic_ostream& operator<<(bool __n);
    basic_ostream& operator<<(short __n);
    basic_ostream& operator<<(unsigned short __n);
    basic_ostream& operator<<(int __n);
    basic_ostream& operator<<(unsigned int __n);
    basic_ostream& operator<<(long __n);
    basic_ostream& operator<<(unsigned long __n);
    basic_ostream& operator<<(long long __n);
    basic_ostream& operator<<(unsigned long long __n);
    basic_ostream& operator<<(float __f);
    basic_ostream& operator<<(double __f);
    basic_ostream& operator<<(long double __f);
    basic_ostream& operator<<(const void* __p);
    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);


    basic_ostream& put(char_type __c);
    basic_ostream& write(const char_type* __s, streamsize __n);
    basic_ostream& flush();


    inline __attribute__((__visibility__("default"), __always_inline__))
    pos_type tellp();
    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_ostream& seekp(pos_type __pos);
    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream() {}
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream<_CharT, _Traits>::sentry
{
    bool __ok_;
    basic_ostream<_CharT, _Traits>& __os_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_ostream<_CharT, _Traits>& __os);
    ~sentry();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit
        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)
    : __ok_(false),
      __os_(__os)
{
    if (__os.good())
    {
        if (__os.tie())
            __os.tie()->flush();
        __ok_ = true;
    }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::~sentry()
{
    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)
                      && !uncaught_exception())
    {

        try
        {

            if (__os_.rdbuf()->pubsync() == -1)
                __os_.setstate(ios_base::badbit);

        }
        catch (...)
        {
        }

    }
}



template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)
{
    this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            if (__sb)
            {

                try
                {

                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    _Ip __i(__sb);
                    _Ip __eof;
                    _Op __o(*this);
                    size_t __c = 0;
                    for (; __i != __eof; ++__i, ++__o, ++__c)
                    {
                        *__o = *__i;
                        if (__o.failed())
                            break;
                    }
                    if (__c == 0)
                        this->setstate(ios_base::failbit);

                }
                catch (...)
                {
                    this->__set_failbit_and_consider_rethrow();
                }

            }
            else
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(bool __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned short>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned int>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(float __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,
                          const _CharT* __str, size_t __len)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 __str,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __str + __len :
                                     __str,
                                 __str + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)
{
    return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            _CharT __c = __os.widen(__cn);
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 &__c,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     &__c + 1 :
                                     &__c,
                                 &__c + 1,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, char __c)
{
    return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, signed char __c)
{
    return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)
{
    return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)
{
    return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            size_t __len = char_traits<char>::length(__strn);
            const int __bs = 100;
            _CharT __wbb[__bs];
            _CharT* __wb = __wbb;
            unique_ptr<_CharT, void(*)(void*)> __h(0, free);
            if (__len > __bs)
            {
                __wb = (_CharT*)malloc(__len*sizeof(_CharT));
                if (__wb == 0)
                    __throw_bad_alloc();
                __h.reset(__wb);
            }
            for (_CharT* __p = __wb; *__strn != '\0'; ++__strn, ++__p)
                *__p = __os.widen(*__strn);
            if (__pad_and_output(_Ip(__os),
                                 __wb,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __wb + __len :
                                     __wb,
                                 __wb + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const char* __str)
{
    return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)
{
    const char *__s = (const char *) __str;
    return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)
{
    const char *__s = (const char *) __str;
    return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            _Op __o(*this);
            *__o = __c;
            if (__o.failed())
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)
{

    try
    {

        sentry __sen(*this);
        if (__sen && __n)
        {
            if (this->rdbuf()->sputn(__s, __n) != __n)
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::flush()
{

    try
    {

        if (this->rdbuf())
        {
            sentry __s(*this);
            if (__s)
            {
                if (this->rdbuf()->pubsync() == -1)
                    this->setstate(ios_base::badbit);
            }
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp()
{
    if (this->fail())
        return pos_type(-1);
    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
{
    sentry __s(*this);
    if (!this->fail())
    {
        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)
{
    sentry __s(*this);
    if (!this->fail())
    {
        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
endl(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(__os.widen('\n'));
    __os.flush();
    return __os;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
ends(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(_CharT());
    return __os;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
flush(basic_ostream<_CharT, _Traits>& __os)
{
    __os.flush();
    return __os;
}



template <class _Stream, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_lvalue_reference<_Stream>::value &&
    is_base_of<ios_base, _Stream>::value,
    _Stream&&
>::type
operator<<(_Stream&& __os, const _Tp& __x)
{
    __os << __x;
    return std::__1::move(__os);
}



template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string_view<_CharT, _Traits> __sv)
{
    return std::__1::__put_character_sequence(__os, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)
{
    return __os << __ec.category().name() << ':' << __ec.value();
}

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)
{
    return __os << __p.get();
}

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
{
    return __os << __x.template to_string<_CharT, _Traits>
                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),
                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
}


extern template class __attribute__ ((__visibility__("default"))) basic_ostream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ostream<wchar_t>;


} }
# 164 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/istream" 2 3
# 167 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/istream" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 171 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/istream" 2 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
    streamsize __gc_;
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__((__visibility__("default"), __always_inline__))
    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb) : __gc_(0)
    { this->init(__sb); }
    virtual ~basic_istream();
protected:

    inline __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_istream(basic_istream&& __rhs);


    inline __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_istream& operator=(basic_istream&& __rhs);


    inline __attribute__((__visibility__("default"), __always_inline__))
    void swap(basic_istream& __rhs) {
      std::__1::swap(__gc_, __rhs.__gc_);
      basic_ios<char_type, traits_type>::swap(__rhs);
    }


    basic_istream (const basic_istream& __rhs) = delete;
    basic_istream& operator=(const basic_istream& __rhs) = delete;

public:


    class __attribute__ ((__type_visibility__("default"))) sentry;


    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&))
    { return __pf(*this); }

    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_istream& operator>>(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type, traits_type>&))
    { __pf(*this); return *this; }

    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_istream& operator>>(ios_base& (*__pf)(ios_base&))
    { __pf(*this); return *this; }

    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);
    basic_istream& operator>>(bool& __n);
    basic_istream& operator>>(short& __n);
    basic_istream& operator>>(unsigned short& __n);
    basic_istream& operator>>(int& __n);
    basic_istream& operator>>(unsigned int& __n);
    basic_istream& operator>>(long& __n);
    basic_istream& operator>>(unsigned long& __n);
    basic_istream& operator>>(long long& __n);
    basic_istream& operator>>(unsigned long long& __n);
    basic_istream& operator>>(float& __f);
    basic_istream& operator>>(double& __f);
    basic_istream& operator>>(long double& __f);
    basic_istream& operator>>(void*& __p);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streamsize gcount() const {return __gc_;}
    int_type get();

    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_istream& get(char_type& __c) {
      int_type __ch = get();
      if (__ch != traits_type::eof())
        __c = traits_type::to_char_type(__ch);
      return *this;
    }

    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_istream& get(char_type* __s, streamsize __n)
    { return get(__s, __n, this->widen('\n')); }

    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);

    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb)
    { return get(__sb, this->widen('\n')); }

    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);

    inline __attribute__((__visibility__("default"), __always_inline__))
    basic_istream& getline(char_type* __s, streamsize __n)
    { return getline(__s, __n, this->widen('\n')); }

    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);

    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
    int_type peek();
    basic_istream& read (char_type* __s, streamsize __n);
    streamsize readsome(char_type* __s, streamsize __n);

    basic_istream& putback(char_type __c);
    basic_istream& unget();
    int sync();

    pos_type tellg();
    basic_istream& seekg(pos_type __pos);
    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream<_CharT, _Traits>::sentry
{
    bool __ok_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit
        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,
                                               bool __noskipws)
    : __ok_(false)
{
    if (__is.good())
    {
        if (__is.tie())
            __is.tie()->flush();
        if (!__noskipws && (__is.flags() & ios_base::skipws))
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            _Ip __i(__is);
            _Ip __eof;
            for (; __i != __eof; ++__i)
                if (!__ct.is(__ct.space, *__i))
                    break;
            if (__i == __eof)
                __is.setstate(ios_base::failbit | ios_base::eofbit);
        }
        __ok_ = __is.good();
    }
    else
        __is.setstate(ios_base::failbit);
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)
    : __gc_(__rhs.__gc_)
{
    __rhs.__gc_ = 0;
    this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream()
{
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(float& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(double& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long double& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(bool& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(void*& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(short& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            long __temp;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
            if (__temp < numeric_limits<short>::min())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<short>::min();
            }
            else if (__temp > numeric_limits<short>::max())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<short>::max();
            }
            else
                __n = static_cast<short>(__temp);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(int& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            long __temp;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
            if (__temp < numeric_limits<int>::min())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<int>::min();
            }
            else if (__temp > numeric_limits<int>::max())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<int>::max();
            }
            else
                __n = static_cast<int>(__temp);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            ios_base::iostate __err = ios_base::goodbit;
            while (__c < __n-1)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                *__s++ = __ch;
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            *__s = _CharT();
            __is.width(0);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)
{
    return __is >> (char*)__s;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char* __s)
{
    return __is >> (char*)__s;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
            if (_Traits::eq_int_type(__i, _Traits::eof()))
                __is.setstate(ios_base::eofbit | ios_base::failbit);
            else
                __c = _Traits::to_char_type(__i);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)
{
    return __is >> (char&)__c;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char& __c)
{
    return __is >> (char&)__c;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)
{
    __gc_ = 0;

    try
    {

        sentry __s(*this, true);
        if (__s)
        {
            if (__sb)
            {

                try
                {

                    ios_base::iostate __err = ios_base::goodbit;
                    while (true)
                    {
                        typename traits_type::int_type __i = this->rdbuf()->sgetc();
                        if (traits_type::eq_int_type(__i, _Traits::eof()))
                        {
                           __err |= ios_base::eofbit;
                           break;
                        }
                        if (traits_type::eq_int_type(
                                __sb->sputc(traits_type::to_char_type(__i)),
                                traits_type::eof()))
                            break;
                        ++__gc_;
                        this->rdbuf()->sbumpc();
                    }
                    if (__gc_ == 0)
                       __err |= ios_base::failbit;
                    this->setstate(__err);

                }
                catch (...)
                {
                    if (__gc_ == 0)
                        this->__set_failbit_and_consider_rethrow();
                }

            }
            else
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get()
{
    __gc_ = 0;
    int_type __r = traits_type::eof();

    try
    {

        sentry __s(*this, true);
        if (__s)
        {
            __r = this->rdbuf()->sbumpc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
               this->setstate(ios_base::failbit | ios_base::eofbit);
            else
                __gc_ = 1;
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            if (__n > 0)
            {
                ios_base::iostate __err = ios_base::goodbit;
                while (__gc_ < __n-1)
                {
                    int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    *__s++ = __ch;
                    ++__gc_;
                     this->rdbuf()->sbumpc();
                }
                if (__gc_ == 0)
                   __err |= ios_base::failbit;
                this->setstate(__err);
            }
            else
                this->setstate(ios_base::failbit);
        }
        if (__n > 0)
            *__s = char_type();

    }
    catch (...)
    {
        if (__n > 0)
            *__s = char_type();
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,
                                    char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;

            try
            {

                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                        break;
                    ++__gc_;
                    this->rdbuf()->sbumpc();
                }

            }
            catch (...)
            {
            }

            if (__gc_ == 0)
               __err |= ios_base::failbit;
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;
            while (true)
            {
                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                {
                    this->rdbuf()->sbumpc();
                    ++__gc_;
                    break;
                }
                if (__gc_ >= __n-1)
                {
                    __err |= ios_base::failbit;
                    break;
                }
                *__s++ = __ch;
                this->rdbuf()->sbumpc();
                ++__gc_;
            }
            if (__gc_ == 0)
               __err |= ios_base::failbit;
            this->setstate(__err);
        }
        if (__n > 0)
            *__s = char_type();

    }
    catch (...)
    {
        if (__n > 0)
            *__s = char_type();
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;
            if (__n == numeric_limits<streamsize>::max())
            {
                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            else
            {
                while (__gc_ < __n)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek()
{
    __gc_ = 0;
    int_type __r = traits_type::eof();

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            __r = this->rdbuf()->sgetc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
                this->setstate(ios_base::eofbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            __gc_ = this->rdbuf()->sgetn(__s, __n);
            if (__gc_ != __n)
                this->setstate(ios_base::failbit | ios_base::eofbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            streamsize __c = this->rdbuf()->in_avail();
            switch (__c)
            {
            case -1:
                this->setstate(ios_base::eofbit);
                break;
            case 0:
                break;
            default:
                read(__s, std::__1::min(__c, __n));
                break;
            }
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __gc_;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(char_type __c)
{
    __gc_ = 0;

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())
                this->setstate(ios_base::badbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::unget()
{
    __gc_ = 0;

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())
                this->setstate(ios_base::badbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
int
basic_istream<_CharT, _Traits>::sync()
{
    int __r = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0)
                return -1;
            if (this->rdbuf()->pubsync() == -1)
            {
                this->setstate(ios_base::badbit);
                return -1;
            }
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg()
{
    pos_type __r(-1);

    try
    {

        sentry __sen(*this, true);
        if (__sen)
            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos)
{

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __is.setstate(ios_base::eofbit);
                   break;
                }
                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
                    break;
                __is.rdbuf()->sbumpc();
            }
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}



template <class _CharT, class _Traits, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp&& __x)
{
    __is >> std::__1::forward<_Tp>(__x);
    return __is;
}



template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__((__visibility__("default"), __always_inline__))
    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb)
      : basic_istream<_CharT, _Traits>(__sb)
    {}

    virtual ~basic_iostream();
protected:

    inline __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_iostream(basic_iostream&& __rhs);


    inline __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_iostream& operator=(basic_iostream&& __rhs);

    inline __attribute__((__visibility__("default"), __always_inline__))
    void swap(basic_iostream& __rhs)
    { basic_istream<char_type, traits_type>::swap(__rhs); }
public:
};



template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)
    : basic_istream<_CharT, _Traits>(std::__1::move(__rhs))
{
}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>&
basic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            __str.clear();
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = __str.max_size();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max();
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            ios_base::iostate __err = ios_base::goodbit;
            while (__c < __n)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __is.width(0);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }
        else
            __is.setstate(ios_base::failbit);

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            __str.clear();
            ios_base::iostate __err = ios_base::goodbit;
            streamsize __extr = 0;
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                ++__extr;
                _CharT __ch = _Traits::to_char_type(__i);
                if (_Traits::eq(__ch, __dlm))
                    break;
                __str.push_back(__ch);
                if (__str.size() == __str.max_size())
                {
                    __err |= ios_base::failbit;
                    break;
                }
            }
            if (__extr == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{
    return getline(__is, __str, __dlm);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}



template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            basic_string<_CharT, _Traits> __str;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            size_t __c = 0;
            ios_base::iostate __err = ios_base::goodbit;
            _CharT __zero = __ct.widen('0');
            _CharT __one = __ct.widen('1');
            while (__c < _Size)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __x = bitset<_Size>(__str);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }
        else
            __is.setstate(ios_base::failbit);

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}


extern template class __attribute__ ((__visibility__("default"))) basic_istream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_istream<wchar_t>;
extern template class __attribute__ ((__visibility__("default"))) basic_iostream<char>;


} }
# 41 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iostream" 2 3
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/iostream" 3


namespace std {inline namespace __1 {


extern __attribute__ ((__visibility__("default"))) istream cin;
extern __attribute__ ((__visibility__("default"))) wistream wcin;


extern __attribute__ ((__visibility__("default"))) ostream cout;
extern __attribute__ ((__visibility__("default"))) wostream wcout;

extern __attribute__ ((__visibility__("default"))) ostream cerr;
extern __attribute__ ((__visibility__("default"))) wostream wcerr;
extern __attribute__ ((__visibility__("default"))) ostream clog;
extern __attribute__ ((__visibility__("default"))) wostream wclog;

} }
# 10 "src/main.cpp" 2

# 1 "src/application.hpp" 1
# 12 "src/application.hpp"
void runGame();
# 12 "src/main.cpp" 2
# 1 "include/Simpleton/SDL/library.hpp" 1
# 12 "include/Simpleton/SDL/library.hpp"
# 1 "include/Simpleton/SDL/error.hpp" 1
# 14 "include/Simpleton/SDL/error.hpp"
extern "C" const char *SDL_GetError();

namespace SDL {
  class Error final : public std::runtime_error {
  public:
    inline Error()
      : std::runtime_error(SDL_GetError()) {}
  };

  namespace detail {
    template <typename Ptr>
    Ptr checkSDLNull(const Ptr ptr) {
      if (ptr == nullptr) throw Error();
      return ptr;
    }
  }
}
# 13 "include/Simpleton/SDL/library.hpp" 2
# 1 "/usr/local/include/SDL2/SDL.h" 1
# 32 "/usr/local/include/SDL2/SDL.h"
# 1 "/usr/local/include/SDL2/SDL_main.h" 1
# 25 "/usr/local/include/SDL2/SDL_main.h"
# 1 "/usr/local/include/SDL2/SDL_stdinc.h" 1
# 31 "/usr/local/include/SDL2/SDL_stdinc.h"
# 1 "/usr/local/include/SDL2/SDL_config.h" 1
# 33 "/usr/local/include/SDL2/SDL_config.h"
# 1 "/usr/local/include/SDL2/SDL_platform.h" 1
# 71 "/usr/local/include/SDL2/SDL_platform.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/AvailabilityMacros.h" 1 3 4
# 72 "/usr/local/include/SDL2/SDL_platform.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/TargetConditionals.h" 1 3 4
# 73 "/usr/local/include/SDL2/SDL_platform.h" 2
# 179 "/usr/local/include/SDL2/SDL_platform.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 180 "/usr/local/include/SDL2/SDL_platform.h" 2


extern "C" {





extern __attribute__ ((visibility("default"))) const char * SDL_GetPlatform (void);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 195 "/usr/local/include/SDL2/SDL_platform.h" 2
# 34 "/usr/local/include/SDL2/SDL_config.h" 2
# 32 "/usr/local/include/SDL2/SDL_stdinc.h" 2





# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdio.h" 1 3
# 38 "/usr/local/include/SDL2/SDL_stdinc.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdlib.h" 1 3
# 41 "/usr/local/include/SDL2/SDL_stdinc.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stddef.h" 1 3
# 44 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stddef.h" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stddef.h" 1 3 4
# 47 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stddef.h" 2 3



extern "C++" {

using std::nullptr_t;
}
# 42 "/usr/local/include/SDL2/SDL_stdinc.h" 2
# 66 "/usr/local/include/SDL2/SDL_stdinc.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/wchar.h" 1 3
# 67 "/usr/local/include/SDL2/SDL_stdinc.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/inttypes.h" 1 3
# 238 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/inttypes.h" 3
# 247 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/inttypes.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/inttypes.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/inttypes.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/inttypes.h" 1 3 4
# 227 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/inttypes.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 228 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/inttypes.h" 2 3 4



extern "C" {


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
imaxabs(intmax_t j);


typedef struct {
 intmax_t quot;
 intmax_t rem;
} imaxdiv_t;

__attribute__((availability(macosx,introduced=10.4)))
extern imaxdiv_t
imaxdiv(intmax_t __numer, intmax_t __denom);


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
strtoimax(const char * __nptr,
   char ** __endptr,
   int __base);

__attribute__((availability(macosx,introduced=10.4)))
extern uintmax_t
strtoumax(const char * __nptr,
   char ** __endptr,
   int __base);


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
wcstoimax(const wchar_t * __nptr,
   wchar_t ** __endptr,
   int __base);

__attribute__((availability(macosx,introduced=10.4)))
extern uintmax_t
wcstoumax(const wchar_t * __nptr,
   wchar_t ** __endptr,
   int __base);






}



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_inttypes.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/xlocale/_inttypes.h" 3 4
extern "C" {
intmax_t strtoimax_l(const char * nptr, char ** endptr,
  int base, locale_t);
uintmax_t strtoumax_l(const char * nptr, char ** endptr,
  int base, locale_t);
intmax_t wcstoimax_l(const wchar_t * nptr,
  wchar_t ** endptr, int base, locale_t);
uintmax_t wcstoumax_l(const wchar_t * nptr,
  wchar_t ** endptr, int base, locale_t);





}
# 283 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/inttypes.h" 2 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/inttypes.h" 2 3 4
# 248 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/inttypes.h" 2 3
# 70 "/usr/local/include/SDL2/SDL_stdinc.h" 2
# 84 "/usr/local/include/SDL2/SDL_stdinc.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/math.h" 1 3
# 299 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/math.h" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 1 3 4
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
extern "C" {
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
    typedef float float_t;
    typedef double double_t;
# 111 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
extern int __math_errhandling(void);
# 144 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
# 188 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float);
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double);
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double);
inline __attribute__ ((__always_inline__)) int __inline_isinff(float);
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double);
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnand(double);
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double);
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double);
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float);
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double);
inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double);

inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float __x) {
    return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double __x) {
    return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double __x) {
    return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isinff(float __x) {
    return __builtin_fabsf(__x) == __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double __x) {
    return __builtin_fabs(__x) == __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double __x) {
    return __builtin_fabsl(__x) == __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnand(double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float __x) {
    union { float __f; unsigned int __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 31);
}
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double __x) {
    union { double __f; unsigned long long __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}

inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double __x) {
    union {
        long double __ld;
        struct{ unsigned long long __m; unsigned short __sexp; } __p;
    } __u;
    __u.__ld = __x;
    return (int)(__u.__p.__sexp >> 15);
}







inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float __x) {
    return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435e-38F;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double __x) {
    return __inline_isfinited(__x) && __builtin_fabs(__x) >= 2.2250738585072014e-308;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double __x) {
    return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= 3.36210314311209350626e-4932L;
}
# 322 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);

extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);

extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);

extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);

extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);

extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);

extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);

extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);

extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);

extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);

extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);

extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);

extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);

extern float expf(float);
extern double exp(double);
extern long double expl(long double);

extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);

extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);

extern float logf(float);
extern double log(double);
extern long double logl(long double);

extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);

extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);

extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);

extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);

extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);

extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);

extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);

extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);

extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);

extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);

extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);

extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);

extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);

extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);

extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);

extern float erff(float);
extern double erf(double);
extern long double erfl(long double);

extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);




extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);

extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);

extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);

extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);

extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);

extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);

extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);

extern float roundf(float);
extern double round(double);
extern long double roundl(long double);

extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);




extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);

extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);


extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);

extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);

extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);

extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);

extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);

extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);

extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);

extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);

extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);

extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);

extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);

extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
# 565 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
extern float __inff(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern double __inf(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern long double __infl(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern float __nan(void) __attribute__((availability(macosx,introduced=10.0)));
# 597 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
extern float __exp10f(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __exp10(double) __attribute__((availability(macosx,introduced=10.9)));





inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp);
inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp);
# 614 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
extern float __cospif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __cospi(double) __attribute__((availability(macosx,introduced=10.9)));
extern float __sinpif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __sinpi(double) __attribute__((availability(macosx,introduced=10.9)));
extern float __tanpif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __tanpi(double) __attribute__((availability(macosx,introduced=10.9)));
# 645 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp);
inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp);






struct __float2 { float __sinval; float __cosval; };
struct __double2 { double __sinval; double __cosval; };

extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);

inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincosf_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincos_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincospif_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincospi_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}







extern double j0(double) __attribute__((availability(macosx,introduced=10.0)));
extern double j1(double) __attribute__((availability(macosx,introduced=10.0)));
extern double jn(int, double) __attribute__((availability(macosx,introduced=10.0)));
extern double y0(double) __attribute__((availability(macosx,introduced=10.0)));
extern double y1(double) __attribute__((availability(macosx,introduced=10.0)));
extern double yn(int, double) __attribute__((availability(macosx,introduced=10.0)));
extern double scalb(double, double);
extern int signgam;
# 751 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
extern long int rinttol(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern long int roundtol(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double drem(double, double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern int finite(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double gamma(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double significand(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
# 776 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/math.h" 3 4
}
# 302 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/math.h" 2 3





extern "C++" {
# 316 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/math.h" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_signbit(_A1 __lcpp_x) noexcept
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __inline_signbitf((float)(__lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? __inline_signbitd((double)(__lcpp_x)) : __inline_signbitl((long double)(__lcpp_x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) noexcept
{
    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<
    std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) noexcept
{ return __lcpp_x < 0; }

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<
    std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type
signbit(_A1) noexcept
{ return false; }
# 378 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/math.h" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
int
__libcpp_fpclassify(_A1 __lcpp_x) noexcept
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __fpclassifyf((float)(__lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? __fpclassifyd((double)(__lcpp_x)) : __fpclassifyl((long double)(__lcpp_x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_floating_point<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) noexcept
{
    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) noexcept
{ return __lcpp_x == 0 ? 3 : 4; }
# 424 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/math.h" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isfinite(_A1 __lcpp_x) noexcept
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __inline_isfinitef((float)(__lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? __inline_isfinited((double)(__lcpp_x)) : __inline_isfinitel((long double)(__lcpp_x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
    bool>::type
isfinite(_A1 __lcpp_x) noexcept
{
    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
    bool>::type
isfinite(_A1) noexcept
{ return true; }







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isinf(_A1 __lcpp_x) noexcept
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __inline_isinff((float)(__lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? __inline_isinfd((double)(__lcpp_x)) : __inline_isinfl((long double)(__lcpp_x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
    bool>::type
isinf(_A1 __lcpp_x) noexcept
{
    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
    bool>::type
isinf(_A1) noexcept
{ return false; }







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnan(_A1 __lcpp_x) noexcept
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __inline_isnanf((float)(__lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? __inline_isnand((double)(__lcpp_x)) : __inline_isnanl((long double)(__lcpp_x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
isnan(_A1 __lcpp_x) noexcept
{
    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, bool>::type
isnan(_A1) noexcept
{ return false; }







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnormal(_A1 __lcpp_x) noexcept
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __inline_isnormalf((float)(__lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? __inline_isnormald((double)(__lcpp_x)) : __inline_isnormall((long double)(__lcpp_x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) noexcept
{
    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) noexcept
{ return __lcpp_x != 0; }







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isgreater((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isgreaterequal((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isless((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_islessequal((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_islessgreater((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isunordered((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);
}






inline __attribute__ ((__visibility__("hidden"), __always_inline__))
float
abs(float __lcpp_x) noexcept {return ::fabsf(__lcpp_x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
double
abs(double __lcpp_x) noexcept {return ::fabs(__lcpp_x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long double
abs(long double __lcpp_x) noexcept {return ::fabsl(__lcpp_x);}





inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acos(float __lcpp_x) noexcept {return ::acosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acos(long double __lcpp_x) noexcept {return ::acosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acos(_A1 __lcpp_x) noexcept {return ::acos((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asin(float __lcpp_x) noexcept {return ::asinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asin(long double __lcpp_x) noexcept {return ::asinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asin(_A1 __lcpp_x) noexcept {return ::asin((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan(float __lcpp_x) noexcept {return ::atanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan(long double __lcpp_x) noexcept {return ::atanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atan(_A1 __lcpp_x) noexcept {return ::atan((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan2(float __lcpp_y, float __lcpp_x) noexcept {return ::atan2f(__lcpp_y, __lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan2(long double __lcpp_y, long double __lcpp_x) noexcept {return ::atan2l(__lcpp_y, __lcpp_x);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
atan2(_A1 __lcpp_y, _A2 __lcpp_x) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ceil(float __lcpp_x) noexcept {return ::ceilf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ceil(long double __lcpp_x) noexcept {return ::ceill(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ceil(_A1 __lcpp_x) noexcept {return ::ceil((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cos(float __lcpp_x) noexcept {return ::cosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cos(long double __lcpp_x) noexcept {return ::cosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cos(_A1 __lcpp_x) noexcept {return ::cos((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cosh(float __lcpp_x) noexcept {return ::coshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cosh(long double __lcpp_x) noexcept {return ::coshl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cosh(_A1 __lcpp_x) noexcept {return ::cosh((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp(float __lcpp_x) noexcept {return ::expf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp(long double __lcpp_x) noexcept {return ::expl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp(_A1 __lcpp_x) noexcept {return ::exp((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fabs(float __lcpp_x) noexcept {return ::fabsf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fabs(long double __lcpp_x) noexcept {return ::fabsl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
fabs(_A1 __lcpp_x) noexcept {return ::fabs((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float floor(float __lcpp_x) noexcept {return ::floorf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double floor(long double __lcpp_x) noexcept {return ::floorl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
floor(_A1 __lcpp_x) noexcept {return ::floor((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmod(float __lcpp_x, float __lcpp_y) noexcept {return ::fmodf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmod(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmodl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmod(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float frexp(float __lcpp_x, int* __lcpp_e) noexcept {return ::frexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double frexp(long double __lcpp_x, int* __lcpp_e) noexcept {return ::frexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
frexp(_A1 __lcpp_x, int* __lcpp_e) noexcept {return ::frexp((double)__lcpp_x, __lcpp_e);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ldexp(float __lcpp_x, int __lcpp_e) noexcept {return ::ldexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ldexp(long double __lcpp_x, int __lcpp_e) noexcept {return ::ldexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ldexp(_A1 __lcpp_x, int __lcpp_e) noexcept {return ::ldexp((double)__lcpp_x, __lcpp_e);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log(float __lcpp_x) noexcept {return ::logf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log(long double __lcpp_x) noexcept {return ::logl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log(_A1 __lcpp_x) noexcept {return ::log((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log10(float __lcpp_x) noexcept {return ::log10f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log10(long double __lcpp_x) noexcept {return ::log10l(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log10(_A1 __lcpp_x) noexcept {return ::log10((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float modf(float __lcpp_x, float* __lcpp_y) noexcept {return ::modff(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double modf(long double __lcpp_x, long double* __lcpp_y) noexcept {return ::modfl(__lcpp_x, __lcpp_y);}





inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float pow(float __lcpp_x, float __lcpp_y) noexcept {return ::powf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double pow(long double __lcpp_x, long double __lcpp_y) noexcept {return ::powl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
pow(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sin(float __lcpp_x) noexcept {return ::sinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sin(long double __lcpp_x) noexcept {return ::sinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sin(_A1 __lcpp_x) noexcept {return ::sin((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sinh(float __lcpp_x) noexcept {return ::sinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sinh(long double __lcpp_x) noexcept {return ::sinhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sinh(_A1 __lcpp_x) noexcept {return ::sinh((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sqrt(float __lcpp_x) noexcept {return ::sqrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sqrt(long double __lcpp_x) noexcept {return ::sqrtl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sqrt(_A1 __lcpp_x) noexcept {return ::sqrt((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tan(float __lcpp_x) noexcept {return ::tanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tan(long double __lcpp_x) noexcept {return ::tanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tan(_A1 __lcpp_x) noexcept {return ::tan((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tanh(float __lcpp_x) noexcept {return ::tanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tanh(long double __lcpp_x) noexcept {return ::tanhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tanh(_A1 __lcpp_x) noexcept {return ::tanh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acosh(float __lcpp_x) noexcept {return ::acoshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acosh(long double __lcpp_x) noexcept {return ::acoshl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acosh(_A1 __lcpp_x) noexcept {return ::acosh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asinh(float __lcpp_x) noexcept {return ::asinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asinh(long double __lcpp_x) noexcept {return ::asinhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asinh(_A1 __lcpp_x) noexcept {return ::asinh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atanh(float __lcpp_x) noexcept {return ::atanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atanh(long double __lcpp_x) noexcept {return ::atanhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atanh(_A1 __lcpp_x) noexcept {return ::atanh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cbrt(float __lcpp_x) noexcept {return ::cbrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cbrt(long double __lcpp_x) noexcept {return ::cbrtl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cbrt(_A1 __lcpp_x) noexcept {return ::cbrt((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float copysign(float __lcpp_x,
                                                float __lcpp_y) noexcept {
  return ::copysignf(__lcpp_x, __lcpp_y);
}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double
copysign(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::copysignl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
copysign(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erf(float __lcpp_x) noexcept {return ::erff(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erf(long double __lcpp_x) noexcept {return ::erfl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erf(_A1 __lcpp_x) noexcept {return ::erf((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erfc(float __lcpp_x) noexcept {return ::erfcf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erfc(long double __lcpp_x) noexcept {return ::erfcl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erfc(_A1 __lcpp_x) noexcept {return ::erfc((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp2(float __lcpp_x) noexcept {return ::exp2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp2(long double __lcpp_x) noexcept {return ::exp2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp2(_A1 __lcpp_x) noexcept {return ::exp2((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float expm1(float __lcpp_x) noexcept {return ::expm1f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double expm1(long double __lcpp_x) noexcept {return ::expm1l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
expm1(_A1 __lcpp_x) noexcept {return ::expm1((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fdim(float __lcpp_x, float __lcpp_y) noexcept {return ::fdimf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fdim(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fdiml(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fdim(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) noexcept {return ::fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) noexcept {return ::fmal(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value &&
    std::is_arithmetic<_A3>::value,
    std::__promote<_A1, _A2, _A3>
>::type
fma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
{
    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value &&
                     std::is_same<_A3, __result_type>::value)), "");
    return ::fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmax(float __lcpp_x, float __lcpp_y) noexcept {return ::fmaxf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmax(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmaxl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmax(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmin(float __lcpp_x, float __lcpp_y) noexcept {return ::fminf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmin(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fminl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmin(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float hypot(float __lcpp_x, float __lcpp_y) noexcept {return ::hypotf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double hypot(long double __lcpp_x, long double __lcpp_y) noexcept {return ::hypotl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(float __lcpp_x) noexcept {return ::ilogbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(long double __lcpp_x) noexcept {return ::ilogbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
ilogb(_A1 __lcpp_x) noexcept {return ::ilogb((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float lgamma(float __lcpp_x) noexcept {return ::lgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double lgamma(long double __lcpp_x) noexcept {return ::lgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
lgamma(_A1 __lcpp_x) noexcept {return ::lgamma((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(float __lcpp_x) noexcept {return ::llrintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(long double __lcpp_x) noexcept {return ::llrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llrint(_A1 __lcpp_x) noexcept {return ::llrint((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(float __lcpp_x) noexcept {return ::llroundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(long double __lcpp_x) noexcept {return ::llroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llround(_A1 __lcpp_x) noexcept {return ::llround((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log1p(float __lcpp_x) noexcept {return ::log1pf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log1p(long double __lcpp_x) noexcept {return ::log1pl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log1p(_A1 __lcpp_x) noexcept {return ::log1p((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log2(float __lcpp_x) noexcept {return ::log2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log2(long double __lcpp_x) noexcept {return ::log2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log2(_A1 __lcpp_x) noexcept {return ::log2((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float logb(float __lcpp_x) noexcept {return ::logbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double logb(long double __lcpp_x) noexcept {return ::logbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
logb(_A1 __lcpp_x) noexcept {return ::logb((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(float __lcpp_x) noexcept {return ::lrintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(long double __lcpp_x) noexcept {return ::lrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lrint(_A1 __lcpp_x) noexcept {return ::lrint((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(float __lcpp_x) noexcept {return ::lroundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(long double __lcpp_x) noexcept {return ::lroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lround(_A1 __lcpp_x) noexcept {return ::lround((double)__lcpp_x);}





inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nearbyint(float __lcpp_x) noexcept {return ::nearbyintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nearbyint(long double __lcpp_x) noexcept {return ::nearbyintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nearbyint(_A1 __lcpp_x) noexcept {return ::nearbyint((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nextafter(float __lcpp_x, float __lcpp_y) noexcept {return ::nextafterf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nextafter(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nextafterl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
nextafter(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nexttoward(float __lcpp_x, long double __lcpp_y) noexcept {return ::nexttowardf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nexttoward(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nexttowardl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nexttoward(_A1 __lcpp_x, long double __lcpp_y) noexcept {return ::nexttoward((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remainder(float __lcpp_x, float __lcpp_y) noexcept {return ::remainderf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remainder(long double __lcpp_x, long double __lcpp_y) noexcept {return ::remainderl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remainder(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) noexcept {return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) noexcept {return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::__lazy_enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::is_same<_A1, __result_type>::value &&
                     std::is_same<_A2, __result_type>::value)), "");
    return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float rint(float __lcpp_x) noexcept {return ::rintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double rint(long double __lcpp_x) noexcept {return ::rintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
rint(_A1 __lcpp_x) noexcept {return ::rint((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float round(float __lcpp_x) noexcept {return ::roundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double round(long double __lcpp_x) noexcept {return ::roundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
round(_A1 __lcpp_x) noexcept {return ::round((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbln(float __lcpp_x, long __lcpp_y) noexcept {return ::scalblnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbln(long double __lcpp_x, long __lcpp_y) noexcept {return ::scalblnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbln(_A1 __lcpp_x, long __lcpp_y) noexcept {return ::scalbln((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbn(float __lcpp_x, int __lcpp_y) noexcept {return ::scalbnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbn(long double __lcpp_x, int __lcpp_y) noexcept {return ::scalbnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbn(_A1 __lcpp_x, int __lcpp_y) noexcept {return ::scalbn((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tgamma(float __lcpp_x) noexcept {return ::tgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tgamma(long double __lcpp_x) noexcept {return ::tgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tgamma(_A1 __lcpp_x) noexcept {return ::tgamma((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float trunc(float __lcpp_x) noexcept {return ::truncf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double trunc(long double __lcpp_x) noexcept {return ::truncl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
trunc(_A1 __lcpp_x) noexcept {return ::trunc((double)__lcpp_x);}

}
# 85 "/usr/local/include/SDL2/SDL_stdinc.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/float.h" 1 3
# 67 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/float.h" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/float.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/float.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/float.h" 1 3 4
# 46 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/float.h" 2 3 4
# 70 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/float.h" 2 3
# 88 "/usr/local/include/SDL2/SDL_stdinc.h" 2
# 139 "/usr/local/include/SDL2/SDL_stdinc.h"
typedef enum
{
    SDL_FALSE = 0,
    SDL_TRUE = 1
} SDL_bool;







typedef int8_t Sint8;





typedef uint8_t Uint8;





typedef int16_t Sint16;





typedef uint16_t Uint16;





typedef int32_t Sint32;





typedef uint32_t Uint32;






typedef int64_t Sint64;





typedef uint64_t Uint64;
# 294 "/usr/local/include/SDL2/SDL_stdinc.h"
typedef int SDL_compile_time_assert_uint8[(sizeof(Uint8) == 1) * 2 - 1];
typedef int SDL_compile_time_assert_sint8[(sizeof(Sint8) == 1) * 2 - 1];
typedef int SDL_compile_time_assert_uint16[(sizeof(Uint16) == 2) * 2 - 1];
typedef int SDL_compile_time_assert_sint16[(sizeof(Sint16) == 2) * 2 - 1];
typedef int SDL_compile_time_assert_uint32[(sizeof(Uint32) == 4) * 2 - 1];
typedef int SDL_compile_time_assert_sint32[(sizeof(Sint32) == 4) * 2 - 1];
typedef int SDL_compile_time_assert_uint64[(sizeof(Uint64) == 8) * 2 - 1];
typedef int SDL_compile_time_assert_sint64[(sizeof(Sint64) == 8) * 2 - 1];
# 315 "/usr/local/include/SDL2/SDL_stdinc.h"
typedef enum
{
    DUMMY_ENUM_VALUE
} SDL_DUMMY_ENUM;

typedef int SDL_compile_time_assert_enum[(sizeof(SDL_DUMMY_ENUM) == sizeof(int)) * 2 - 1];





# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 326 "/usr/local/include/SDL2/SDL_stdinc.h" 2


extern "C" {
# 361 "/usr/local/include/SDL2/SDL_stdinc.h"
extern __attribute__ ((visibility("default"))) void * SDL_malloc(size_t size);
extern __attribute__ ((visibility("default"))) void * SDL_calloc(size_t nmemb, size_t size);
extern __attribute__ ((visibility("default"))) void * SDL_realloc(void *mem, size_t size);
extern __attribute__ ((visibility("default"))) void SDL_free(void *mem);

typedef void *( *SDL_malloc_func)(size_t size);
typedef void *( *SDL_calloc_func)(size_t nmemb, size_t size);
typedef void *( *SDL_realloc_func)(void *mem, size_t size);
typedef void ( *SDL_free_func)(void *mem);




extern __attribute__ ((visibility("default"))) void SDL_GetMemoryFunctions(SDL_malloc_func *malloc_func,
                                                    SDL_calloc_func *calloc_func,
                                                    SDL_realloc_func *realloc_func,
                                                    SDL_free_func *free_func);
# 387 "/usr/local/include/SDL2/SDL_stdinc.h"
extern __attribute__ ((visibility("default"))) int SDL_SetMemoryFunctions(SDL_malloc_func malloc_func,
                                                   SDL_calloc_func calloc_func,
                                                   SDL_realloc_func realloc_func,
                                                   SDL_free_func free_func);




extern __attribute__ ((visibility("default"))) int SDL_GetNumAllocations(void);

extern __attribute__ ((visibility("default"))) char * SDL_getenv(const char *name);
extern __attribute__ ((visibility("default"))) int SDL_setenv(const char *name, const char *value, int overwrite);

extern __attribute__ ((visibility("default"))) void SDL_qsort(void *base, size_t nmemb, size_t size, int (*compare) (const void *, const void *));

extern __attribute__ ((visibility("default"))) int SDL_abs(int x);






extern __attribute__ ((visibility("default"))) int SDL_isdigit(int x);
extern __attribute__ ((visibility("default"))) int SDL_isspace(int x);
extern __attribute__ ((visibility("default"))) int SDL_toupper(int x);
extern __attribute__ ((visibility("default"))) int SDL_tolower(int x);

extern __attribute__ ((visibility("default"))) void * SDL_memset( void *dst, int c, size_t len);





__attribute__((always_inline)) static __inline__ void SDL_memset4(void *dst, Uint32 val, size_t dwords)
{
# 432 "/usr/local/include/SDL2/SDL_stdinc.h"
    size_t _n = (dwords + 3) / 4;
    Uint32 *_p = static_cast<Uint32 *>(dst);
    Uint32 _val = (val);
    if (dwords == 0)
        return;
    switch (dwords % 4)
    {
        case 0: do { *_p++ = _val;
        case 3: *_p++ = _val;
        case 2: *_p++ = _val;
        case 1: *_p++ = _val;
        } while ( --_n );
    }

}


extern __attribute__ ((visibility("default"))) void * SDL_memcpy( void *dst, const void *src, size_t len);

extern __attribute__ ((visibility("default"))) void * SDL_memmove( void *dst, const void *src, size_t len);
extern __attribute__ ((visibility("default"))) int SDL_memcmp(const void *s1, const void *s2, size_t len);

extern __attribute__ ((visibility("default"))) size_t SDL_wcslen(const wchar_t *wstr);
extern __attribute__ ((visibility("default"))) size_t SDL_wcslcpy( wchar_t *dst, const wchar_t *src, size_t maxlen);
extern __attribute__ ((visibility("default"))) size_t SDL_wcslcat( wchar_t *dst, const wchar_t *src, size_t maxlen);
extern __attribute__ ((visibility("default"))) int SDL_wcscmp(const wchar_t *str1, const wchar_t *str2);

extern __attribute__ ((visibility("default"))) size_t SDL_strlen(const char *str);
extern __attribute__ ((visibility("default"))) size_t SDL_strlcpy( char *dst, const char *src, size_t maxlen);
extern __attribute__ ((visibility("default"))) size_t SDL_utf8strlcpy( char *dst, const char *src, size_t dst_bytes);
extern __attribute__ ((visibility("default"))) size_t SDL_strlcat( char *dst, const char *src, size_t maxlen);
extern __attribute__ ((visibility("default"))) char * SDL_strdup(const char *str);
extern __attribute__ ((visibility("default"))) char * SDL_strrev(char *str);
extern __attribute__ ((visibility("default"))) char * SDL_strupr(char *str);
extern __attribute__ ((visibility("default"))) char * SDL_strlwr(char *str);
extern __attribute__ ((visibility("default"))) char * SDL_strchr(const char *str, int c);
extern __attribute__ ((visibility("default"))) char * SDL_strrchr(const char *str, int c);
extern __attribute__ ((visibility("default"))) char * SDL_strstr(const char *haystack, const char *needle);
extern __attribute__ ((visibility("default"))) size_t SDL_utf8strlen(const char *str);

extern __attribute__ ((visibility("default"))) char * SDL_itoa(int value, char *str, int radix);
extern __attribute__ ((visibility("default"))) char * SDL_uitoa(unsigned int value, char *str, int radix);
extern __attribute__ ((visibility("default"))) char * SDL_ltoa(long value, char *str, int radix);
extern __attribute__ ((visibility("default"))) char * SDL_ultoa(unsigned long value, char *str, int radix);
extern __attribute__ ((visibility("default"))) char * SDL_lltoa(Sint64 value, char *str, int radix);
extern __attribute__ ((visibility("default"))) char * SDL_ulltoa(Uint64 value, char *str, int radix);

extern __attribute__ ((visibility("default"))) int SDL_atoi(const char *str);
extern __attribute__ ((visibility("default"))) double SDL_atof(const char *str);
extern __attribute__ ((visibility("default"))) long SDL_strtol(const char *str, char **endp, int base);
extern __attribute__ ((visibility("default"))) unsigned long SDL_strtoul(const char *str, char **endp, int base);
extern __attribute__ ((visibility("default"))) Sint64 SDL_strtoll(const char *str, char **endp, int base);
extern __attribute__ ((visibility("default"))) Uint64 SDL_strtoull(const char *str, char **endp, int base);
extern __attribute__ ((visibility("default"))) double SDL_strtod(const char *str, char **endp);

extern __attribute__ ((visibility("default"))) int SDL_strcmp(const char *str1, const char *str2);
extern __attribute__ ((visibility("default"))) int SDL_strncmp(const char *str1, const char *str2, size_t maxlen);
extern __attribute__ ((visibility("default"))) int SDL_strcasecmp(const char *str1, const char *str2);
extern __attribute__ ((visibility("default"))) int SDL_strncasecmp(const char *str1, const char *str2, size_t len);

extern __attribute__ ((visibility("default"))) int SDL_sscanf(const char *text, const char *fmt, ...) __attribute__ (( format( __scanf__, 2, 2 +1 )));
extern __attribute__ ((visibility("default"))) int SDL_vsscanf(const char *text, const char *fmt, va_list ap);
extern __attribute__ ((visibility("default"))) int SDL_snprintf( char *text, size_t maxlen, const char *fmt, ... ) __attribute__ (( format( __printf__, 3, 3 +1 )));
extern __attribute__ ((visibility("default"))) int SDL_vsnprintf( char *text, size_t maxlen, const char *fmt, va_list ap);







extern __attribute__ ((visibility("default"))) double SDL_acos(double x);
extern __attribute__ ((visibility("default"))) float SDL_acosf(float x);
extern __attribute__ ((visibility("default"))) double SDL_asin(double x);
extern __attribute__ ((visibility("default"))) float SDL_asinf(float x);
extern __attribute__ ((visibility("default"))) double SDL_atan(double x);
extern __attribute__ ((visibility("default"))) float SDL_atanf(float x);
extern __attribute__ ((visibility("default"))) double SDL_atan2(double x, double y);
extern __attribute__ ((visibility("default"))) float SDL_atan2f(float x, float y);
extern __attribute__ ((visibility("default"))) double SDL_ceil(double x);
extern __attribute__ ((visibility("default"))) float SDL_ceilf(float x);
extern __attribute__ ((visibility("default"))) double SDL_copysign(double x, double y);
extern __attribute__ ((visibility("default"))) float SDL_copysignf(float x, float y);
extern __attribute__ ((visibility("default"))) double SDL_cos(double x);
extern __attribute__ ((visibility("default"))) float SDL_cosf(float x);
extern __attribute__ ((visibility("default"))) double SDL_fabs(double x);
extern __attribute__ ((visibility("default"))) float SDL_fabsf(float x);
extern __attribute__ ((visibility("default"))) double SDL_floor(double x);
extern __attribute__ ((visibility("default"))) float SDL_floorf(float x);
extern __attribute__ ((visibility("default"))) double SDL_fmod(double x, double y);
extern __attribute__ ((visibility("default"))) float SDL_fmodf(float x, float y);
extern __attribute__ ((visibility("default"))) double SDL_log(double x);
extern __attribute__ ((visibility("default"))) float SDL_logf(float x);
extern __attribute__ ((visibility("default"))) double SDL_log10(double x);
extern __attribute__ ((visibility("default"))) float SDL_log10f(float x);
extern __attribute__ ((visibility("default"))) double SDL_pow(double x, double y);
extern __attribute__ ((visibility("default"))) float SDL_powf(float x, float y);
extern __attribute__ ((visibility("default"))) double SDL_scalbn(double x, int n);
extern __attribute__ ((visibility("default"))) float SDL_scalbnf(float x, int n);
extern __attribute__ ((visibility("default"))) double SDL_sin(double x);
extern __attribute__ ((visibility("default"))) float SDL_sinf(float x);
extern __attribute__ ((visibility("default"))) double SDL_sqrt(double x);
extern __attribute__ ((visibility("default"))) float SDL_sqrtf(float x);
extern __attribute__ ((visibility("default"))) double SDL_tan(double x);
extern __attribute__ ((visibility("default"))) float SDL_tanf(float x);
# 545 "/usr/local/include/SDL2/SDL_stdinc.h"
typedef struct _SDL_iconv_t *SDL_iconv_t;
extern __attribute__ ((visibility("default"))) SDL_iconv_t SDL_iconv_open(const char *tocode,
                                                   const char *fromcode);
extern __attribute__ ((visibility("default"))) int SDL_iconv_close(SDL_iconv_t cd);
extern __attribute__ ((visibility("default"))) size_t SDL_iconv(SDL_iconv_t cd, const char **inbuf,
                                         size_t * inbytesleft, char **outbuf,
                                         size_t * outbytesleft);




extern __attribute__ ((visibility("default"))) char * SDL_iconv_string(const char *tocode,
                                               const char *fromcode,
                                               const char *inbuf,
                                               size_t inbytesleft);
# 592 "/usr/local/include/SDL2/SDL_stdinc.h"
__attribute__((always_inline)) static __inline__ void *SDL_memcpy4( void *dst, const void *src, size_t dwords)
{
    return SDL_memcpy(dst, src, dwords * 4);
}



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 602 "/usr/local/include/SDL2/SDL_stdinc.h" 2
# 26 "/usr/local/include/SDL2/SDL_main.h" 2
# 117 "/usr/local/include/SDL2/SDL_main.h"
extern "C" int SDL_main(int argc, char *argv[]);



# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 121 "/usr/local/include/SDL2/SDL_main.h" 2

extern "C" {
# 132 "/usr/local/include/SDL2/SDL_main.h"
extern __attribute__ ((visibility("default"))) void SDL_SetMainReady(void);
# 162 "/usr/local/include/SDL2/SDL_main.h"
}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 165 "/usr/local/include/SDL2/SDL_main.h" 2
# 33 "/usr/local/include/SDL2/SDL.h" 2

# 1 "/usr/local/include/SDL2/SDL_assert.h" 1
# 27 "/usr/local/include/SDL2/SDL_assert.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 28 "/usr/local/include/SDL2/SDL_assert.h" 2


extern "C" {
# 102 "/usr/local/include/SDL2/SDL_assert.h"
typedef enum
{
    SDL_ASSERTION_RETRY,
    SDL_ASSERTION_BREAK,
    SDL_ASSERTION_ABORT,
    SDL_ASSERTION_IGNORE,
    SDL_ASSERTION_ALWAYS_IGNORE
} SDL_AssertState;

typedef struct SDL_AssertData
{
    int always_ignore;
    unsigned int trigger_count;
    const char *condition;
    const char *filename;
    int linenum;
    const char *function;
    const struct SDL_AssertData *next;
} SDL_AssertData;




extern __attribute__ ((visibility("default"))) SDL_AssertState SDL_ReportAssertion(SDL_AssertData *,
                                                             const char *,
                                                             const char *, int)





   __attribute__((analyzer_noreturn))


;
# 188 "/usr/local/include/SDL2/SDL_assert.h"
typedef SDL_AssertState ( *SDL_AssertionHandler)(
                                 const SDL_AssertData* data, void* userdata);
# 211 "/usr/local/include/SDL2/SDL_assert.h"
extern __attribute__ ((visibility("default"))) void SDL_SetAssertionHandler(
                                            SDL_AssertionHandler handler,
                                            void *userdata);
# 225 "/usr/local/include/SDL2/SDL_assert.h"
extern __attribute__ ((visibility("default"))) SDL_AssertionHandler SDL_GetDefaultAssertionHandler(void);
# 242 "/usr/local/include/SDL2/SDL_assert.h"
extern __attribute__ ((visibility("default"))) SDL_AssertionHandler SDL_GetAssertionHandler(void **puserdata);
# 266 "/usr/local/include/SDL2/SDL_assert.h"
extern __attribute__ ((visibility("default"))) const SDL_AssertData * SDL_GetAssertionReport(void);
# 275 "/usr/local/include/SDL2/SDL_assert.h"
extern __attribute__ ((visibility("default"))) void SDL_ResetAssertionReport(void);
# 285 "/usr/local/include/SDL2/SDL_assert.h"
}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 288 "/usr/local/include/SDL2/SDL_assert.h" 2
# 35 "/usr/local/include/SDL2/SDL.h" 2
# 1 "/usr/local/include/SDL2/SDL_atomic.h" 1
# 65 "/usr/local/include/SDL2/SDL_atomic.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 66 "/usr/local/include/SDL2/SDL_atomic.h" 2



extern "C" {
# 89 "/usr/local/include/SDL2/SDL_atomic.h"
typedef int SDL_SpinLock;
# 98 "/usr/local/include/SDL2/SDL_atomic.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_AtomicTryLock(SDL_SpinLock *lock);






extern __attribute__ ((visibility("default"))) void SDL_AtomicLock(SDL_SpinLock *lock);






extern __attribute__ ((visibility("default"))) void SDL_AtomicUnlock(SDL_SpinLock *lock);
# 155 "/usr/local/include/SDL2/SDL_atomic.h"
extern __attribute__ ((visibility("default"))) void SDL_MemoryBarrierReleaseFunction(void);
extern __attribute__ ((visibility("default"))) void SDL_MemoryBarrierAcquireFunction(void);
# 198 "/usr/local/include/SDL2/SDL_atomic.h"
typedef struct { int value; } SDL_atomic_t;
# 207 "/usr/local/include/SDL2/SDL_atomic.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_AtomicCAS(SDL_atomic_t *a, int oldval, int newval);






extern __attribute__ ((visibility("default"))) int SDL_AtomicSet(SDL_atomic_t *a, int v);




extern __attribute__ ((visibility("default"))) int SDL_AtomicGet(SDL_atomic_t *a);
# 228 "/usr/local/include/SDL2/SDL_atomic.h"
extern __attribute__ ((visibility("default"))) int SDL_AtomicAdd(SDL_atomic_t *a, int v);
# 254 "/usr/local/include/SDL2/SDL_atomic.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_AtomicCASPtr(void **a, void *oldval, void *newval);






extern __attribute__ ((visibility("default"))) void* SDL_AtomicSetPtr(void **a, void* v);




extern __attribute__ ((visibility("default"))) void* SDL_AtomicGetPtr(void **a);



}



# 1 "/usr/local/include/SDL2/close_code.h" 1
# 274 "/usr/local/include/SDL2/SDL_atomic.h" 2
# 36 "/usr/local/include/SDL2/SDL.h" 2
# 1 "/usr/local/include/SDL2/SDL_audio.h" 1
# 32 "/usr/local/include/SDL2/SDL_audio.h"
# 1 "/usr/local/include/SDL2/SDL_error.h" 1
# 33 "/usr/local/include/SDL2/SDL_error.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 34 "/usr/local/include/SDL2/SDL_error.h" 2


extern "C" {




extern __attribute__ ((visibility("default"))) int SDL_SetError( const char *fmt, ...) __attribute__ (( format( __printf__, 1, 1 +1 )));
extern __attribute__ ((visibility("default"))) const char * SDL_GetError(void);
extern __attribute__ ((visibility("default"))) void SDL_ClearError(void);
# 55 "/usr/local/include/SDL2/SDL_error.h"
typedef enum
{
    SDL_ENOMEM,
    SDL_EFREAD,
    SDL_EFWRITE,
    SDL_EFSEEK,
    SDL_UNSUPPORTED,
    SDL_LASTERROR
} SDL_errorcode;

extern __attribute__ ((visibility("default"))) int SDL_Error(SDL_errorcode code);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 73 "/usr/local/include/SDL2/SDL_error.h" 2
# 33 "/usr/local/include/SDL2/SDL_audio.h" 2
# 1 "/usr/local/include/SDL2/SDL_endian.h" 1
# 59 "/usr/local/include/SDL2/SDL_endian.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 60 "/usr/local/include/SDL2/SDL_endian.h" 2


extern "C" {
# 77 "/usr/local/include/SDL2/SDL_endian.h"
__attribute__((always_inline)) static __inline__ Uint16
SDL_Swap16(Uint16 x)
{
  __asm__("xchgb %b0,%h0": "=Q"(x):"0"(x));
    return x;
}
# 121 "/usr/local/include/SDL2/SDL_endian.h"
__attribute__((always_inline)) static __inline__ Uint32
SDL_Swap32(Uint32 x)
{
  __asm__("bswapl %0": "=r"(x):"0"(x));
    return x;
}
# 188 "/usr/local/include/SDL2/SDL_endian.h"
__attribute__((always_inline)) static __inline__ Uint64
SDL_Swap64(Uint64 x)
{
  __asm__("bswapq %0": "=r"(x):"0"(x));
    return x;
}
# 212 "/usr/local/include/SDL2/SDL_endian.h"
__attribute__((always_inline)) static __inline__ float
SDL_SwapFloat(float x)
{
    union
    {
        float f;
        Uint32 ui32;
    } swapper;
    swapper.f = x;
    swapper.ui32 = SDL_Swap32(swapper.ui32);
    return swapper.f;
}
# 254 "/usr/local/include/SDL2/SDL_endian.h"
}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 257 "/usr/local/include/SDL2/SDL_endian.h" 2
# 34 "/usr/local/include/SDL2/SDL_audio.h" 2
# 1 "/usr/local/include/SDL2/SDL_mutex.h" 1
# 34 "/usr/local/include/SDL2/SDL_mutex.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 35 "/usr/local/include/SDL2/SDL_mutex.h" 2


extern "C" {
# 58 "/usr/local/include/SDL2/SDL_mutex.h"
struct SDL_mutex;
typedef struct SDL_mutex SDL_mutex;




extern __attribute__ ((visibility("default"))) SDL_mutex * SDL_CreateMutex(void);







extern __attribute__ ((visibility("default"))) int SDL_LockMutex(SDL_mutex * mutex);






extern __attribute__ ((visibility("default"))) int SDL_TryLockMutex(SDL_mutex * mutex);
# 90 "/usr/local/include/SDL2/SDL_mutex.h"
extern __attribute__ ((visibility("default"))) int SDL_UnlockMutex(SDL_mutex * mutex);




extern __attribute__ ((visibility("default"))) void SDL_DestroyMutex(SDL_mutex * mutex);
# 106 "/usr/local/include/SDL2/SDL_mutex.h"
struct SDL_semaphore;
typedef struct SDL_semaphore SDL_sem;




extern __attribute__ ((visibility("default"))) SDL_sem * SDL_CreateSemaphore(Uint32 initial_value);




extern __attribute__ ((visibility("default"))) void SDL_DestroySemaphore(SDL_sem * sem);






extern __attribute__ ((visibility("default"))) int SDL_SemWait(SDL_sem * sem);







extern __attribute__ ((visibility("default"))) int SDL_SemTryWait(SDL_sem * sem);
# 143 "/usr/local/include/SDL2/SDL_mutex.h"
extern __attribute__ ((visibility("default"))) int SDL_SemWaitTimeout(SDL_sem * sem, Uint32 ms);






extern __attribute__ ((visibility("default"))) int SDL_SemPost(SDL_sem * sem);




extern __attribute__ ((visibility("default"))) Uint32 SDL_SemValue(SDL_sem * sem);
# 166 "/usr/local/include/SDL2/SDL_mutex.h"
struct SDL_cond;
typedef struct SDL_cond SDL_cond;
# 197 "/usr/local/include/SDL2/SDL_mutex.h"
extern __attribute__ ((visibility("default"))) SDL_cond * SDL_CreateCond(void);




extern __attribute__ ((visibility("default"))) void SDL_DestroyCond(SDL_cond * cond);






extern __attribute__ ((visibility("default"))) int SDL_CondSignal(SDL_cond * cond);






extern __attribute__ ((visibility("default"))) int SDL_CondBroadcast(SDL_cond * cond);
# 227 "/usr/local/include/SDL2/SDL_mutex.h"
extern __attribute__ ((visibility("default"))) int SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex);
# 237 "/usr/local/include/SDL2/SDL_mutex.h"
extern __attribute__ ((visibility("default"))) int SDL_CondWaitTimeout(SDL_cond * cond,
                                                SDL_mutex * mutex, Uint32 ms);






}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 248 "/usr/local/include/SDL2/SDL_mutex.h" 2
# 35 "/usr/local/include/SDL2/SDL_audio.h" 2
# 1 "/usr/local/include/SDL2/SDL_thread.h" 1
# 38 "/usr/local/include/SDL2/SDL_thread.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 39 "/usr/local/include/SDL2/SDL_thread.h" 2


extern "C" {



struct SDL_Thread;
typedef struct SDL_Thread SDL_Thread;


typedef unsigned long SDL_threadID;


typedef unsigned int SDL_TLSID;






typedef enum {
    SDL_THREAD_PRIORITY_LOW,
    SDL_THREAD_PRIORITY_NORMAL,
    SDL_THREAD_PRIORITY_HIGH
} SDL_ThreadPriority;





typedef int ( * SDL_ThreadFunction) (void *data);
# 162 "/usr/local/include/SDL2/SDL_thread.h"
extern __attribute__ ((visibility("default"))) SDL_Thread *
SDL_CreateThread(SDL_ThreadFunction fn, const char *name, void *data);
# 174 "/usr/local/include/SDL2/SDL_thread.h"
extern __attribute__ ((visibility("default"))) const char * SDL_GetThreadName(SDL_Thread *thread);




extern __attribute__ ((visibility("default"))) SDL_threadID SDL_ThreadID(void);






extern __attribute__ ((visibility("default"))) SDL_threadID SDL_GetThreadID(SDL_Thread * thread);




extern __attribute__ ((visibility("default"))) int SDL_SetThreadPriority(SDL_ThreadPriority priority);
# 211 "/usr/local/include/SDL2/SDL_thread.h"
extern __attribute__ ((visibility("default"))) void SDL_WaitThread(SDL_Thread * thread, int *status);
# 239 "/usr/local/include/SDL2/SDL_thread.h"
extern __attribute__ ((visibility("default"))) void SDL_DetachThread(SDL_Thread * thread);
# 271 "/usr/local/include/SDL2/SDL_thread.h"
extern __attribute__ ((visibility("default"))) SDL_TLSID SDL_TLSCreate(void);
# 283 "/usr/local/include/SDL2/SDL_thread.h"
extern __attribute__ ((visibility("default"))) void * SDL_TLSGet(SDL_TLSID id);
# 297 "/usr/local/include/SDL2/SDL_thread.h"
extern __attribute__ ((visibility("default"))) int SDL_TLSSet(SDL_TLSID id, const void *value, void ( *destructor)(void*));




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 305 "/usr/local/include/SDL2/SDL_thread.h" 2
# 36 "/usr/local/include/SDL2/SDL_audio.h" 2
# 1 "/usr/local/include/SDL2/SDL_rwops.h" 1
# 35 "/usr/local/include/SDL2/SDL_rwops.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 36 "/usr/local/include/SDL2/SDL_rwops.h" 2


extern "C" {
# 52 "/usr/local/include/SDL2/SDL_rwops.h"
typedef struct SDL_RWops
{



    Sint64 ( * size) (struct SDL_RWops * context);







    Sint64 ( * seek) (struct SDL_RWops * context, Sint64 offset,
                             int whence);







    size_t ( * read) (struct SDL_RWops * context, void *ptr,
                             size_t size, size_t maxnum);







    size_t ( * write) (struct SDL_RWops * context, const void *ptr,
                              size_t size, size_t num);






    int ( * close) (struct SDL_RWops * context);

    Uint32 type;
    union
    {
# 124 "/usr/local/include/SDL2/SDL_rwops.h"
        struct
        {
            SDL_bool autoclose;
            FILE *fp;
        } stdio;

        struct
        {
            Uint8 *base;
            Uint8 *here;
            Uint8 *stop;
        } mem;
        struct
        {
            void *data1;
            void *data2;
        } unknown;
    } hidden;

} SDL_RWops;
# 153 "/usr/local/include/SDL2/SDL_rwops.h"
extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromFile(const char *file,
                                                  const char *mode);


extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromFP(FILE * fp,
                                                SDL_bool autoclose);





extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromMem(void *mem, int size);
extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromConstMem(const void *mem,
                                                      int size);




extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_AllocRW(void);
extern __attribute__ ((visibility("default"))) void SDL_FreeRW(SDL_RWops * area);
# 206 "/usr/local/include/SDL2/SDL_rwops.h"
extern __attribute__ ((visibility("default"))) void * SDL_LoadFile_RW(SDL_RWops * src, size_t *datasize,
                                                    int freesrc);
# 222 "/usr/local/include/SDL2/SDL_rwops.h"
extern __attribute__ ((visibility("default"))) Uint8 SDL_ReadU8(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint16 SDL_ReadLE16(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint16 SDL_ReadBE16(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint32 SDL_ReadLE32(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint32 SDL_ReadBE32(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint64 SDL_ReadLE64(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint64 SDL_ReadBE64(SDL_RWops * src);
# 237 "/usr/local/include/SDL2/SDL_rwops.h"
extern __attribute__ ((visibility("default"))) size_t SDL_WriteU8(SDL_RWops * dst, Uint8 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteLE16(SDL_RWops * dst, Uint16 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteBE16(SDL_RWops * dst, Uint16 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteLE32(SDL_RWops * dst, Uint32 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteBE32(SDL_RWops * dst, Uint32 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteLE64(SDL_RWops * dst, Uint64 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteBE64(SDL_RWops * dst, Uint64 value);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 251 "/usr/local/include/SDL2/SDL_rwops.h" 2
# 37 "/usr/local/include/SDL2/SDL_audio.h" 2

# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 39 "/usr/local/include/SDL2/SDL_audio.h" 2


extern "C" {
# 64 "/usr/local/include/SDL2/SDL_audio.h"
typedef Uint16 SDL_AudioFormat;
# 162 "/usr/local/include/SDL2/SDL_audio.h"
typedef void ( * SDL_AudioCallback) (void *userdata, Uint8 * stream,
                                            int len);
# 177 "/usr/local/include/SDL2/SDL_audio.h"
typedef struct SDL_AudioSpec
{
    int freq;
    SDL_AudioFormat format;
    Uint8 channels;
    Uint8 silence;
    Uint16 samples;
    Uint16 padding;
    Uint32 size;
    SDL_AudioCallback callback;
    void *userdata;
} SDL_AudioSpec;


struct SDL_AudioCVT;
typedef void ( * SDL_AudioFilter) (struct SDL_AudioCVT * cvt,
                                          SDL_AudioFormat format);
# 225 "/usr/local/include/SDL2/SDL_audio.h"
typedef struct SDL_AudioCVT
{
    int needed;
    SDL_AudioFormat src_format;
    SDL_AudioFormat dst_format;
    double rate_incr;
    Uint8 *buf;
    int len;
    int len_cvt;
    int len_mult;
    double len_ratio;
    SDL_AudioFilter filters[9 + 1];
    int filter_index;
} __attribute__((packed)) SDL_AudioCVT;
# 250 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) int SDL_GetNumAudioDrivers(void);
extern __attribute__ ((visibility("default"))) const char * SDL_GetAudioDriver(int index);
# 262 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) int SDL_AudioInit(const char *driver_name);
extern __attribute__ ((visibility("default"))) void SDL_AudioQuit(void);






extern __attribute__ ((visibility("default"))) const char * SDL_GetCurrentAudioDriver(void);
# 317 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) int SDL_OpenAudio(SDL_AudioSpec * desired,
                                          SDL_AudioSpec * obtained);
# 329 "/usr/local/include/SDL2/SDL_audio.h"
typedef Uint32 SDL_AudioDeviceID;
# 343 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) int SDL_GetNumAudioDevices(int iscapture);
# 358 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) const char * SDL_GetAudioDeviceName(int index,
                                                           int iscapture);
# 375 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) SDL_AudioDeviceID SDL_OpenAudioDevice(const char
                                                              *device,
                                                              int iscapture,
                                                              const
                                                              SDL_AudioSpec *
                                                              desired,
                                                              SDL_AudioSpec *
                                                              obtained,
                                                              int
                                                              allowed_changes);
# 394 "/usr/local/include/SDL2/SDL_audio.h"
typedef enum
{
    SDL_AUDIO_STOPPED = 0,
    SDL_AUDIO_PLAYING,
    SDL_AUDIO_PAUSED
} SDL_AudioStatus;
extern __attribute__ ((visibility("default"))) SDL_AudioStatus SDL_GetAudioStatus(void);

extern __attribute__ ((visibility("default"))) SDL_AudioStatus
SDL_GetAudioDeviceStatus(SDL_AudioDeviceID dev);
# 416 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) void SDL_PauseAudio(int pause_on);
extern __attribute__ ((visibility("default"))) void SDL_PauseAudioDevice(SDL_AudioDeviceID dev,
                                                  int pause_on);
# 440 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) SDL_AudioSpec * SDL_LoadWAV_RW(SDL_RWops * src,
                                                      int freesrc,
                                                      SDL_AudioSpec * spec,
                                                      Uint8 ** audio_buf,
                                                      Uint32 * audio_len);
# 456 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) void SDL_FreeWAV(Uint8 * audio_buf);
# 467 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) int SDL_BuildAudioCVT(SDL_AudioCVT * cvt,
                                              SDL_AudioFormat src_format,
                                              Uint8 src_channels,
                                              int src_rate,
                                              SDL_AudioFormat dst_format,
                                              Uint8 dst_channels,
                                              int dst_rate);
# 487 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) int SDL_ConvertAudio(SDL_AudioCVT * cvt);
# 497 "/usr/local/include/SDL2/SDL_audio.h"
struct _SDL_AudioStream;
typedef struct _SDL_AudioStream SDL_AudioStream;
# 518 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) SDL_AudioStream * SDL_NewAudioStream(const SDL_AudioFormat src_format,
                                           const Uint8 src_channels,
                                           const int src_rate,
                                           const SDL_AudioFormat dst_format,
                                           const Uint8 dst_channels,
                                           const int dst_rate);
# 540 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) int SDL_AudioStreamPut(SDL_AudioStream *stream, const void *buf, int len);
# 557 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) int SDL_AudioStreamGet(SDL_AudioStream *stream, void *buf, int len);
# 572 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) int SDL_AudioStreamAvailable(SDL_AudioStream *stream);
# 589 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) int SDL_AudioStreamFlush(SDL_AudioStream *stream);
# 601 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) void SDL_AudioStreamClear(SDL_AudioStream *stream);
# 613 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) void SDL_FreeAudioStream(SDL_AudioStream *stream);
# 623 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) void SDL_MixAudio(Uint8 * dst, const Uint8 * src,
                                          Uint32 len, int volume);






extern __attribute__ ((visibility("default"))) void SDL_MixAudioFormat(Uint8 * dst,
                                                const Uint8 * src,
                                                SDL_AudioFormat format,
                                                Uint32 len, int volume);
# 675 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) int SDL_QueueAudio(SDL_AudioDeviceID dev, const void *data, Uint32 len);
# 721 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) Uint32 SDL_DequeueAudio(SDL_AudioDeviceID dev, void *data, Uint32 len);
# 757 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) Uint32 SDL_GetQueuedAudioSize(SDL_AudioDeviceID dev);
# 793 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) void SDL_ClearQueuedAudio(SDL_AudioDeviceID dev);
# 805 "/usr/local/include/SDL2/SDL_audio.h"
extern __attribute__ ((visibility("default"))) void SDL_LockAudio(void);
extern __attribute__ ((visibility("default"))) void SDL_LockAudioDevice(SDL_AudioDeviceID dev);
extern __attribute__ ((visibility("default"))) void SDL_UnlockAudio(void);
extern __attribute__ ((visibility("default"))) void SDL_UnlockAudioDevice(SDL_AudioDeviceID dev);





extern __attribute__ ((visibility("default"))) void SDL_CloseAudio(void);
extern __attribute__ ((visibility("default"))) void SDL_CloseAudioDevice(SDL_AudioDeviceID dev);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 822 "/usr/local/include/SDL2/SDL_audio.h" 2
# 37 "/usr/local/include/SDL2/SDL.h" 2
# 1 "/usr/local/include/SDL2/SDL_clipboard.h" 1
# 33 "/usr/local/include/SDL2/SDL_clipboard.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 34 "/usr/local/include/SDL2/SDL_clipboard.h" 2


extern "C" {
# 46 "/usr/local/include/SDL2/SDL_clipboard.h"
extern __attribute__ ((visibility("default"))) int SDL_SetClipboardText(const char *text);






extern __attribute__ ((visibility("default"))) char * SDL_GetClipboardText(void);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasClipboardText(void);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 68 "/usr/local/include/SDL2/SDL_clipboard.h" 2
# 38 "/usr/local/include/SDL2/SDL.h" 2
# 1 "/usr/local/include/SDL2/SDL_cpuinfo.h" 1
# 64 "/usr/local/include/SDL2/SDL_cpuinfo.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 1 3 4
# 28 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 1 3 4
# 27 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
typedef long long __m64 __attribute__((__vector_size__(8)));

typedef long long __v1di __attribute__((__vector_size__(8)));
typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));
# 44 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_empty(void)
{
    __builtin_ia32_emms();
}
# 61 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}
# 78 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}
# 94 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}
# 110 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}
# 140 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}
# 170 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}
# 200 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}
# 227 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}
# 250 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}
# 271 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}
# 298 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}
# 321 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}
# 342 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}
# 363 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}
# 384 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}
# 405 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}
# 427 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_adds_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}
# 450 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);
}
# 472 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_adds_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}
# 494 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_adds_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}
# 515 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}
# 536 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}
# 557 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}
# 580 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}
# 603 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}
# 627 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}
# 651 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}
# 678 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}
# 699 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}
# 720 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_mullo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}
# 743 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}
# 765 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);
}
# 788 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}
# 810 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}
# 830 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq((__v1di)__m, __count);
}
# 850 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi((__v1di)__m, __count);
}
# 874 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);
}
# 897 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}
# 921 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);
}
# 944 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}
# 967 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);
}
# 989 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);
}
# 1012 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);
}
# 1034 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}
# 1054 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq((__v1di)__m, __count);
}
# 1075 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi((__v1di)__m, __count);
}
# 1093 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand((__v1di)__m1, (__v1di)__m2);
}
# 1114 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn((__v1di)__m1, (__v1di)__m2);
}
# 1132 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por((__v1di)__m1, (__v1di)__m2);
}
# 1150 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor((__v1di)__m1, (__v1di)__m2);
}
# 1172 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}
# 1194 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}
# 1216 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}
# 1238 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}
# 1260 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}
# 1282 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}
# 1295 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_setzero_si64(void)
{
    return (__m64){ 0LL };
}
# 1316 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}
# 1339 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}
# 1370 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}
# 1390 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}
# 1408 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}
# 1426 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}
# 1447 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}
# 1470 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}
# 1501 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 29 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 1 3 4
# 29 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16)));


typedef unsigned int __v4su __attribute__((__vector_size__(16)));





# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mm_malloc.h" 1 3 4
# 27 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mm_malloc.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdlib.h" 1 3 4
# 28 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mm_malloc.h" 2 3 4
# 39 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/mm_malloc.h" 3 4
extern "C" int posix_memalign(void **__memptr, size_t __alignment, size_t __size);




static __inline__ void *__attribute__((__always_inline__, __nodebug__,
                                       __malloc__))
_mm_malloc(size_t __size, size_t __align)
{
  if (__align == 1) {
    return malloc(__size);
  }

  if (!(__align & (__align - 1)) && __align < sizeof(void *))
    __align = sizeof(void *);

  void *__mallocedMemory;





  if (posix_memalign(&__mallocedMemory, __align, __size))
    return 0;


  return __mallocedMemory;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_free(void *__p)
{
  free(__p);
}
# 40 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 2 3 4
# 60 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_add_ss(__m128 __a, __m128 __b)
{
  __a[0] += __b[0];
  return __a;
}
# 80 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_add_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a + (__v4sf)__b);
}
# 102 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_sub_ss(__m128 __a, __m128 __b)
{
  __a[0] -= __b[0];
  return __a;
}
# 123 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_sub_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a - (__v4sf)__b);
}
# 145 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_mul_ss(__m128 __a, __m128 __b)
{
  __a[0] *= __b[0];
  return __a;
}
# 165 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_mul_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a * (__v4sf)__b);
}
# 187 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_div_ss(__m128 __a, __m128 __b)
{
  __a[0] /= __b[0];
  return __a;
}
# 206 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_div_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a / (__v4sf)__b);
}
# 224 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_sqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_sqrtss((__v4sf)__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}
# 242 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_sqrt_ps(__m128 __a)
{
  return __builtin_ia32_sqrtps((__v4sf)__a);
}
# 260 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_rcp_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rcpss((__v4sf)__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}
# 278 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_rcp_ps(__m128 __a)
{
  return __builtin_ia32_rcpps((__v4sf)__a);
}
# 297 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_rsqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rsqrtss((__v4sf)__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}
# 315 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_rsqrt_ps(__m128 __a)
{
  return __builtin_ia32_rsqrtps((__v4sf)__a);
}
# 338 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_min_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minss((__v4sf)__a, (__v4sf)__b);
}
# 357 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_min_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minps((__v4sf)__a, (__v4sf)__b);
}
# 380 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_max_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxss((__v4sf)__a, (__v4sf)__b);
}
# 399 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_max_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxps((__v4sf)__a, (__v4sf)__b);
}
# 417 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_and_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a & (__v4su)__b);
}
# 439 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_andnot_ps(__m128 __a, __m128 __b)
{
  return (__m128)(~(__v4su)__a & (__v4su)__b);
}
# 457 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_or_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a | (__v4su)__b);
}
# 476 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_xor_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a ^ (__v4su)__b);
}
# 498 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpeq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqss((__v4sf)__a, (__v4sf)__b);
}
# 516 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpeq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqps((__v4sf)__a, (__v4sf)__b);
}
# 539 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmplt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltss((__v4sf)__a, (__v4sf)__b);
}
# 558 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmplt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__a, (__v4sf)__b);
}
# 582 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmple_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpless((__v4sf)__a, (__v4sf)__b);
}
# 601 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmple_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__a, (__v4sf)__b);
}
# 624 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpgt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpltss((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 645 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpgt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__b, (__v4sf)__a);
}
# 669 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpless((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 690 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__b, (__v4sf)__a);
}
# 713 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpneq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqss((__v4sf)__a, (__v4sf)__b);
}
# 732 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpneq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqps((__v4sf)__a, (__v4sf)__b);
}
# 756 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnlt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltss((__v4sf)__a, (__v4sf)__b);
}
# 776 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnlt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__a, (__v4sf)__b);
}
# 801 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnle_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnless((__v4sf)__a, (__v4sf)__b);
}
# 821 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnle_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__a, (__v4sf)__b);
}
# 846 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpngt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnltss((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 868 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpngt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__b, (__v4sf)__a);
}
# 893 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnless((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 915 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__b, (__v4sf)__a);
}
# 940 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordss((__v4sf)__a, (__v4sf)__b);
}
# 960 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordps((__v4sf)__a, (__v4sf)__b);
}
# 985 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpunord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordss((__v4sf)__a, (__v4sf)__b);
}
# 1005 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpunord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordps((__v4sf)__a, (__v4sf)__b);
}
# 1026 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comieq((__v4sf)__a, (__v4sf)__b);
}
# 1048 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comilt((__v4sf)__a, (__v4sf)__b);
}
# 1069 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comile((__v4sf)__a, (__v4sf)__b);
}
# 1090 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comigt((__v4sf)__a, (__v4sf)__b);
}
# 1111 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comige((__v4sf)__a, (__v4sf)__b);
}
# 1132 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comineq((__v4sf)__a, (__v4sf)__b);
}
# 1153 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomieq((__v4sf)__a, (__v4sf)__b);
}
# 1174 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomilt((__v4sf)__a, (__v4sf)__b);
}
# 1196 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomile((__v4sf)__a, (__v4sf)__b);
}
# 1218 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomigt((__v4sf)__a, (__v4sf)__b);
}
# 1240 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomige((__v4sf)__a, (__v4sf)__b);
}
# 1261 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomineq((__v4sf)__a, (__v4sf)__b);
}
# 1279 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtss_si32(__m128 __a)
{
  return __builtin_ia32_cvtss2si((__v4sf)__a);
}
# 1297 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvt_ss2si(__m128 __a)
{
  return _mm_cvtss_si32(__a);
}
# 1317 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtss_si64(__m128 __a)
{
  return __builtin_ia32_cvtss2si64((__v4sf)__a);
}
# 1335 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvtps2pi((__v4sf)__a);
}
# 1351 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvt_ps2pi(__m128 __a)
{
  return _mm_cvtps_pi32(__a);
}
# 1370 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvttss_si32(__m128 __a)
{
  return __builtin_ia32_cvttss2si((__v4sf)__a);
}
# 1389 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtt_ss2si(__m128 __a)
{
  return _mm_cvttss_si32(__a);
}
# 1409 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvttss_si64(__m128 __a)
{
  return __builtin_ia32_cvttss2si64((__v4sf)__a);
}
# 1428 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvttps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvttps2pi((__v4sf)__a);
}
# 1445 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtt_ps2pi(__m128 __a)
{
  return _mm_cvttps_pi32(__a);
}
# 1467 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtsi32_ss(__m128 __a, int __b)
{
  __a[0] = __b;
  return __a;
}
# 1490 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvt_si2ss(__m128 __a, int __b)
{
  return _mm_cvtsi32_ss(__a, __b);
}
# 1514 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtsi64_ss(__m128 __a, long long __b)
{
  __a[0] = __b;
  return __a;
}
# 1540 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpi32_ps(__m128 __a, __m64 __b)
{
  return __builtin_ia32_cvtpi2ps((__v4sf)__a, (__v2si)__b);
}
# 1563 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvt_pi2ps(__m128 __a, __m64 __b)
{
  return _mm_cvtpi32_ps(__a, __b);
}
# 1580 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtss_f32(__m128 __a)
{
  return __a[0];
}
# 1601 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_loadh_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 __b = ((struct __mm_loadh_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 0, 1, 4, 5);
}
# 1628 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_loadl_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 __b = ((struct __mm_loadl_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 4, 5, 2, 3);
}
# 1655 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_load_ss(const float *__p)
{
  struct __mm_load_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load_ss_struct*)__p)->__u;
  return (__m128){ __u, 0, 0, 0 };
}
# 1677 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_load1_ps(const float *__p)
{
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load1_ps_struct*)__p)->__u;
  return (__m128){ __u, __u, __u, __u };
}
# 1700 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_load_ps(const float *__p)
{
  return *(__m128*)__p;
}
# 1717 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_loadu_ps(const float *__p)
{
  struct __loadu_ps {
    __m128 __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)__p)->__v;
}
# 1739 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_loadr_ps(const float *__p)
{
  __m128 __a = _mm_load_ps(__p);
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
}
# 1753 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_undefined_ps(void)
{
  return (__m128)__builtin_ia32_undef128();
}
# 1773 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_set_ss(float __w)
{
  return (__m128){ __w, 0, 0, 0 };
}
# 1791 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_set1_ps(float __w)
{
  return (__m128){ __w, __w, __w, __w };
}
# 1810 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_set_ps1(float __w)
{
    return _mm_set1_ps(__w);
}
# 1837 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_set_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __w, __x, __y, __z };
}
# 1865 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_setr_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __z, __y, __x, __w };
}
# 1880 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_setzero_ps(void)
{
  return (__m128){ 0, 0, 0, 0 };
}
# 1897 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_storeh_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storehps((__v2si *)__p, (__v4sf)__a);
}
# 1914 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_storel_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storelps((__v2si *)__p, (__v4sf)__a);
}
# 1931 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_store_ss(float *__p, __m128 __a)
{
  struct __mm_store_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)__p)->__u = __a[0];
}
# 1952 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_storeu_ps(float *__p, __m128 __a)
{
  struct __storeu_ps {
    __m128 __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_ps*)__p)->__v = __a;
}
# 1973 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_store_ps(float *__p, __m128 __a)
{
  *(__m128*)__p = __a;
}
# 1992 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_store1_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 0, 0, 0);
  _mm_store_ps(__p, __a);
}
# 2012 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_store_ps1(float *__p, __m128 __a)
{
  return _mm_store1_ps(__p, __a);
}
# 2031 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_storer_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
  _mm_store_ps(__p, __a);
}
# 2086 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_stream_pi(__m64 *__p, __m64 __a)
{
  __builtin_ia32_movntq(__p, __a);
}
# 2105 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_stream_ps(float *__p, __m128 __a)
{
  __builtin_nontemporal_store((__v4sf)__a, (__v4sf*)__p);
}


extern "C" {
# 2124 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
void _mm_sfence(void);


}
# 2197 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_max_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)__a, (__v4hi)__b);
}
# 2216 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_max_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)__a, (__v8qi)__b);
}
# 2235 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_min_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)__a, (__v4hi)__b);
}
# 2254 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_min_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)__a, (__v8qi)__b);
}
# 2272 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_movemask_pi8(__m64 __a)
{
  return __builtin_ia32_pmovmskb((__v8qi)__a);
}
# 2291 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_mulhi_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)__a, (__v4hi)__b);
}
# 2354 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_maskmove_si64(__m64 __d, __m64 __n, char *__p)
{
  __builtin_ia32_maskmovq((__v8qi)__d, (__v8qi)__n, __p);
}
# 2373 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_avg_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)__a, (__v8qi)__b);
}
# 2392 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_avg_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)__a, (__v4hi)__b);
}
# 2414 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_sad_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)__a, (__v8qi)__b);
}


extern "C" {
# 2470 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
unsigned int _mm_getcsr(void);
# 2522 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
void _mm_setcsr(unsigned int __i);


}
# 2587 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_unpackhi_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 2, 6, 3, 7);
}
# 2609 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_unpacklo_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 4, 1, 5);
}
# 2630 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_move_ss(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 4, 1, 2, 3);
}
# 2651 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_movehl_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 6, 7, 2, 3);
}
# 2672 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_movelh_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 1, 4, 5);
}
# 2690 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpi16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi16(__b, __a);
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}
# 2720 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpu16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}
# 2749 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpi8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi8(__b, __a);
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}
# 2774 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpu8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}
# 2801 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpi32x2_ps(__m64 __a, __m64 __b)
{
  __m128 __c;

  __c = _mm_setzero_ps();
  __c = _mm_cvtpi32_ps(__c, __b);
  __c = _mm_movelh_ps(__c, __c);

  return _mm_cvtpi32_ps(__c, __a);
}
# 2830 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtps_pi16(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi32(__a);
  __a = _mm_movehl_ps(__a, __a);
  __c = _mm_cvtps_pi32(__a);

  return _mm_packs_pi32(__b, __c);
}
# 2860 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtps_pi8(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi16(__a);
  __c = _mm_setzero_si64();

  return _mm_packs_pi16(__b, __c);
}
# 2885 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_movemask_ps(__m128 __a)
{
  return __builtin_ia32_movmskps((__v4sf)__a);
}
# 2966 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 1 3 4
# 27 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 1 3 4
# 28 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 2 3 4

typedef double __m128d __attribute__((__vector_size__(16)));
typedef long long __m128i __attribute__((__vector_size__(16)));


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));


typedef unsigned long long __v2du __attribute__ ((__vector_size__ (16)));
typedef unsigned short __v8hu __attribute__((__vector_size__(16)));
typedef unsigned char __v16qu __attribute__((__vector_size__(16)));



typedef signed char __v16qs __attribute__((__vector_size__(16)));


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/f16cintrin.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/f16cintrin.h" 3 4
static inline float __attribute__((__always_inline__, __nodebug__, __target__("f16c")))
_cvtsh_ss(unsigned short __a)
{
  __v8hi v = {(short)__a, 0, 0, 0, 0, 0, 0, 0};
  __v4sf r = __builtin_ia32_vcvtph2ps(v);
  return r[0];
}
# 116 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/f16cintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("f16c")))
_mm_cvtph_ps(__m128i __a)
{
  return (__m128)__builtin_ia32_vcvtph2ps((__v8hi)__a);
}
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 2 3 4
# 67 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_sd(__m128d __a, __m128d __b)
{
  __a[0] += __b[0];
  return __a;
}
# 86 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a + (__v2df)__b);
}
# 109 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_sd(__m128d __a, __m128d __b)
{
  __a[0] -= __b[0];
  return __a;
}
# 128 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a - (__v2df)__b);
}
# 150 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mul_sd(__m128d __a, __m128d __b)
{
  __a[0] *= __b[0];
  return __a;
}
# 169 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mul_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a * (__v2df)__b);
}
# 192 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_div_sd(__m128d __a, __m128d __b)
{
  __a[0] /= __b[0];
  return __a;
}
# 212 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_div_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a / (__v2df)__b);
}
# 237 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sqrt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_sqrtsd((__v2df)__b);
  return (__m128d) { __c[0], __a[1] };
}
# 255 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sqrt_pd(__m128d __a)
{
  return __builtin_ia32_sqrtpd((__v2df)__a);
}
# 279 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_min_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minsd((__v2df)__a, (__v2df)__b);
}
# 299 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_min_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minpd((__v2df)__a, (__v2df)__b);
}
# 323 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_max_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxsd((__v2df)__a, (__v2df)__b);
}
# 343 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_max_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxpd((__v2df)__a, (__v2df)__b);
}
# 361 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_and_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2du)__a & (__v2du)__b);
}
# 382 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_andnot_pd(__m128d __a, __m128d __b)
{
  return (__m128d)(~(__v2du)__a & (__v2du)__b);
}
# 400 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_or_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2du)__a | (__v2du)__b);
}
# 418 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_xor_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2du)__a ^ (__v2du)__b);
}
# 437 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpeq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpeqpd((__v2df)__a, (__v2df)__b);
}
# 457 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmplt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltpd((__v2df)__a, (__v2df)__b);
}
# 478 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmple_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplepd((__v2df)__a, (__v2df)__b);
}
# 499 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpgt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltpd((__v2df)__b, (__v2df)__a);
}
# 520 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplepd((__v2df)__b, (__v2df)__a);
}
# 543 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpordpd((__v2df)__a, (__v2df)__b);
}
# 567 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpunord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpunordpd((__v2df)__a, (__v2df)__b);
}
# 588 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpneq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpneqpd((__v2df)__a, (__v2df)__b);
}
# 609 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnlt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltpd((__v2df)__a, (__v2df)__b);
}
# 630 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnle_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlepd((__v2df)__a, (__v2df)__b);
}
# 651 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpngt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltpd((__v2df)__b, (__v2df)__a);
}
# 672 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlepd((__v2df)__b, (__v2df)__a);
}
# 695 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpeq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpeqsd((__v2df)__a, (__v2df)__b);
}
# 720 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmplt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltsd((__v2df)__a, (__v2df)__b);
}
# 745 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmple_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplesd((__v2df)__a, (__v2df)__b);
}
# 770 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpgt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpltsd((__v2df)__b, (__v2df)__a);
  return (__m128d) { __c[0], __a[1] };
}
# 796 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmplesd((__v2df)__b, (__v2df)__a);
  return (__m128d) { __c[0], __a[1] };
}
# 824 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpordsd((__v2df)__a, (__v2df)__b);
}
# 852 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpunord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpunordsd((__v2df)__a, (__v2df)__b);
}
# 877 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpneq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpneqsd((__v2df)__a, (__v2df)__b);
}
# 902 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnlt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltsd((__v2df)__a, (__v2df)__b);
}
# 927 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnle_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlesd((__v2df)__a, (__v2df)__b);
}
# 952 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpngt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpnltsd((__v2df)__b, (__v2df)__a);
  return (__m128d) { __c[0], __a[1] };
}
# 978 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpnlesd((__v2df)__b, (__v2df)__a);
  return (__m128d) { __c[0], __a[1] };
}
# 1000 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdeq((__v2df)__a, (__v2df)__b);
}
# 1024 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdlt((__v2df)__a, (__v2df)__b);
}
# 1048 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdle((__v2df)__a, (__v2df)__b);
}
# 1072 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdgt((__v2df)__a, (__v2df)__b);
}
# 1096 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdge((__v2df)__a, (__v2df)__b);
}
# 1120 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdneq((__v2df)__a, (__v2df)__b);
}
# 1144 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdeq((__v2df)__a, (__v2df)__b);
}
# 1170 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdlt((__v2df)__a, (__v2df)__b);
}
# 1196 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdle((__v2df)__a, (__v2df)__b);
}
# 1222 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdgt((__v2df)__a, (__v2df)__b);
}
# 1248 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdge((__v2df)__a, (__v2df)__b);
}
# 1274 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdneq((__v2df)__a, (__v2df)__b);
}
# 1293 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtpd_ps(__m128d __a)
{
  return __builtin_ia32_cvtpd2ps((__v2df)__a);
}
# 1313 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtps_pd(__m128 __a)
{
  return (__m128d) __builtin_convertvector(
      __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 1), __v2df);
}
# 1336 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtepi32_pd(__m128i __a)
{
  return (__m128d) __builtin_convertvector(
      __builtin_shufflevector((__v4si)__a, (__v4si)__a, 0, 1), __v2df);
}
# 1356 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtpd_epi32(__m128d __a)
{
  return __builtin_ia32_cvtpd2dq((__v2df)__a);
}
# 1373 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsd_si32(__m128d __a)
{
  return __builtin_ia32_cvtsd2si((__v2df)__a);
}
# 1398 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsd_ss(__m128 __a, __m128d __b)
{
  return (__m128)__builtin_ia32_cvtsd2ss((__v4sf)__a, (__v2df)__b);
}
# 1421 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi32_sd(__m128d __a, int __b)
{
  __a[0] = __b;
  return __a;
}
# 1447 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtss_sd(__m128d __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}
# 1471 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvttpd_epi32(__m128d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq((__v2df)__a);
}
# 1489 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvttsd_si32(__m128d __a)
{
  return __builtin_ia32_cvttsd2si((__v2df)__a);
}
# 1506 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvtpd2pi((__v2df)__a);
}
# 1526 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvttpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvttpd2pi((__v2df)__a);
}
# 1543 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtpi32_pd(__m64 __a)
{
  return __builtin_ia32_cvtpi2pd((__v2si)__a);
}
# 1560 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsd_f64(__m128d __a)
{
  return __a[0];
}
# 1577 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_load_pd(double const *__dp)
{
  return *(__m128d*)__dp;
}
# 1595 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_load1_pd(double const *__dp)
{
  struct __mm_load1_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load1_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __u };
}
# 1621 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadr_pd(double const *__dp)
{
  __m128d __u = *(__m128d*)__dp;
  return __builtin_shufflevector((__v2df)__u, (__v2df)__u, 1, 0);
}
# 1639 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadu_pd(double const *__dp)
{
  struct __loadu_pd {
    __m128d __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_pd*)__dp)->__v;
}
# 1659 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadu_si64(void const *__a)
{
  struct __loadu_si64 {
    long long __v;
  } __attribute__((__packed__, __may_alias__));
  long long __u = ((struct __loadu_si64*)__a)->__v;
  return (__m128i){__u, 0L};
}
# 1680 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_load_sd(double const *__dp)
{
  struct __mm_load_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load_sd_struct*)__dp)->__u;
  return (__m128d){ __u, 0 };
}
# 1707 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadh_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadh_pd_struct*)__dp)->__u;
  return (__m128d){ __a[0], __u };
}
# 1734 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadl_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadl_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadl_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __a[1] };
}
# 1755 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_undefined_pd(void)
{
  return (__m128d)__builtin_ia32_undef128();
}
# 1775 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_sd(double __w)
{
  return (__m128d){ __w, 0 };
}
# 1793 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_pd(double __w)
{
  return (__m128d){ __w, __w };
}
# 1811 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_pd1(double __w)
{
  return _mm_set1_pd(__w);
}
# 1831 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_pd(double __w, double __x)
{
  return (__m128d){ __x, __w };
}
# 1852 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setr_pd(double __w, double __x)
{
  return (__m128d){ __w, __x };
}
# 1867 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setzero_pd(void)
{
  return (__m128d){ 0, 0 };
}
# 1888 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_move_sd(__m128d __a, __m128d __b)
{
  return (__m128d){ __b[0], __a[1] };
}
# 1905 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_store_sd(double *__dp, __m128d __a)
{
  struct __mm_store_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct*)__dp)->__u = __a[0];
}
# 1927 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_store_pd(double *__dp, __m128d __a)
{
  *(__m128d*)__dp = __a;
}
# 1946 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_store1_pd(double *__dp, __m128d __a)
{
  __a = __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 0);
  _mm_store_pd(__dp, __a);
}
# 1965 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_store_pd1(double *__dp, __m128d __a)
{
  return _mm_store1_pd(__dp, __a);
}
# 1983 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storeu_pd(double *__dp, __m128d __a)
{
  struct __storeu_pd {
    __m128d __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_pd*)__dp)->__v = __a;
}
# 2006 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storer_pd(double *__dp, __m128d __a)
{
  __a = __builtin_shufflevector((__v2df)__a, (__v2df)__a, 1, 0);
  *(__m128d *)__dp = __a;
}
# 2024 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storeh_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[1];
}
# 2044 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storel_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[0];
}
# 2069 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qu)__a + (__v16qu)__b);
}
# 2091 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hu)__a + (__v8hu)__b);
}
# 2113 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4su)__a + (__v4su)__b);
}
# 2131 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_si64(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_paddq((__v1di)__a, (__v1di)__b);
}
# 2153 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a + (__v2du)__b);
}
# 2174 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_adds_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsb128((__v16qi)__a, (__v16qi)__b);
}
# 2196 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_adds_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsw128((__v8hi)__a, (__v8hi)__b);
}
# 2217 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_adds_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusb128((__v16qi)__a, (__v16qi)__b);
}
# 2238 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_adds_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusw128((__v8hi)__a, (__v8hi)__b);
}
# 2258 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_avg_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)__a, (__v16qi)__b);
}
# 2278 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_avg_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)__a, (__v8hi)__b);
}
# 2304 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_madd_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)__a, (__v8hi)__b);
}
# 2324 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_max_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxsw128((__v8hi)__a, (__v8hi)__b);
}
# 2344 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_max_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxub128((__v16qi)__a, (__v16qi)__b);
}
# 2364 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_min_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminsw128((__v8hi)__a, (__v8hi)__b);
}
# 2384 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_min_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminub128((__v16qi)__a, (__v16qi)__b);
}
# 2404 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mulhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)__a, (__v8hi)__b);
}
# 2424 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mulhi_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)__a, (__v8hi)__b);
}
# 2444 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mullo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hu)__a * (__v8hu)__b);
}
# 2463 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mul_su32(__m64 __a, __m64 __b)
{
  return __builtin_ia32_pmuludq((__v2si)__a, (__v2si)__b);
}
# 2482 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mul_epu32(__m128i __a, __m128i __b)
{
  return __builtin_ia32_pmuludq128((__v4si)__a, (__v4si)__b);
}
# 2504 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sad_epu8(__m128i __a, __m128i __b)
{
  return __builtin_ia32_psadbw128((__v16qi)__a, (__v16qi)__b);
}
# 2522 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qu)__a - (__v16qu)__b);
}
# 2540 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hu)__a - (__v8hu)__b);
}
# 2558 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4su)__a - (__v4su)__b);
}
# 2577 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_si64(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psubq((__v1di)__a, (__v1di)__b);
}
# 2595 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a - (__v2du)__b);
}
# 2616 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_subs_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsb128((__v16qi)__a, (__v16qi)__b);
}
# 2637 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_subs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsw128((__v8hi)__a, (__v8hi)__b);
}
# 2657 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_subs_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusb128((__v16qi)__a, (__v16qi)__b);
}
# 2677 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_subs_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusw128((__v8hi)__a, (__v8hi)__b);
}
# 2695 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_and_si128(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a & (__v2du)__b);
}
# 2715 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_andnot_si128(__m128i __a, __m128i __b)
{
  return (__m128i)(~(__v2du)__a & (__v2du)__b);
}
# 2732 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_or_si128(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a | (__v2du)__b);
}
# 2750 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_xor_si128(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a ^ (__v2du)__b);
}
# 2810 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_slli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)__a, __count);
}
# 2829 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sll_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__a, (__v8hi)__count);
}
# 2848 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_slli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_pslldi128((__v4si)__a, __count);
}
# 2867 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sll_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__a, (__v4si)__count);
}
# 2886 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_slli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psllqi128((__v2di)__a, __count);
}
# 2905 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sll_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psllq128((__v2di)__a, (__v2di)__count);
}
# 2925 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srai_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)__a, __count);
}
# 2945 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sra_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psraw128((__v8hi)__a, (__v8hi)__count);
}
# 2965 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srai_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psradi128((__v4si)__a, __count);
}
# 2985 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sra_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrad128((__v4si)__a, (__v4si)__count);
}
# 3045 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)__a, __count);
}
# 3064 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srl_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)__a, (__v8hi)__count);
}
# 3083 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrldi128((__v4si)__a, __count);
}
# 3102 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srl_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrld128((__v4si)__a, (__v4si)__count);
}
# 3121 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psrlqi128((__v2di)__a, __count);
}
# 3140 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srl_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psrlq128((__v2di)__a, (__v2di)__count);
}
# 3159 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpeq_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a == (__v16qi)__b);
}
# 3178 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpeq_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a == (__v8hi)__b);
}
# 3197 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpeq_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a == (__v4si)__b);
}
# 3217 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpgt_epi8(__m128i __a, __m128i __b)
{


  return (__m128i)((__v16qs)__a > (__v16qs)__b);
}
# 3240 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpgt_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a > (__v8hi)__b);
}
# 3261 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpgt_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a > (__v4si)__b);
}
# 3282 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmplt_epi8(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi8(__b, __a);
}
# 3303 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmplt_epi16(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi16(__b, __a);
}
# 3324 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmplt_epi32(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi32(__b, __a);
}
# 3348 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi64_sd(__m128d __a, long long __b)
{
  __a[0] = __b;
  return __a;
}
# 3366 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsd_si64(__m128d __a)
{
  return __builtin_ia32_cvtsd2si64((__v2df)__a);
}
# 3384 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvttsd_si64(__m128d __a)
{
  return __builtin_ia32_cvttsd2si64((__v2df)__a);
}
# 3400 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtepi32_ps(__m128i __a)
{
  return __builtin_ia32_cvtdq2ps((__v4si)__a);
}
# 3416 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvtps2dq((__v4sf)__a);
}
# 3433 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvttps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvttps2dq((__v4sf)__a);
}
# 3449 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi32_si128(int __a)
{
  return (__m128i)(__v4si){ __a, 0, 0, 0 };
}
# 3466 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi64_si128(long long __a)
{
  return (__m128i){ __a, 0 };
}
# 3484 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi128_si32(__m128i __a)
{
  __v4si __b = (__v4si)__a;
  return __b[0];
}
# 3503 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi128_si64(__m128i __a)
{
  return __a[0];
}
# 3520 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_load_si128(__m128i const *__p)
{
  return *__p;
}
# 3536 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadu_si128(__m128i const *__p)
{
  struct __loadu_si128 {
    __m128i __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_si128*)__p)->__v;
}
# 3557 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadl_epi64(__m128i const *__p)
{
  struct __mm_loadl_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  return (__m128i) { ((struct __mm_loadl_epi64_struct*)__p)->__u, 0};
}
# 3575 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_undefined_si128(void)
{
  return (__m128i)__builtin_ia32_undef128();
}
# 3597 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_epi64x(long long __q1, long long __q0)
{
  return (__m128i){ __q0, __q1 };
}
# 3619 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_epi64(__m64 __q1, __m64 __q0)
{
  return (__m128i){ (long long)__q0, (long long)__q1 };
}
# 3647 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_epi32(int __i3, int __i2, int __i1, int __i0)
{
  return (__m128i)(__v4si){ __i0, __i1, __i2, __i3};
}
# 3687 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_epi16(short __w7, short __w6, short __w5, short __w4, short __w3, short __w2, short __w1, short __w0)
{
  return (__m128i)(__v8hi){ __w0, __w1, __w2, __w3, __w4, __w5, __w6, __w7 };
}
# 3735 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_epi8(char __b15, char __b14, char __b13, char __b12, char __b11, char __b10, char __b9, char __b8, char __b7, char __b6, char __b5, char __b4, char __b3, char __b2, char __b1, char __b0)
{
  return (__m128i)(__v16qi){ __b0, __b1, __b2, __b3, __b4, __b5, __b6, __b7, __b8, __b9, __b10, __b11, __b12, __b13, __b14, __b15 };
}
# 3754 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_epi64x(long long __q)
{
  return (__m128i){ __q, __q };
}
# 3773 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_epi64(__m64 __q)
{
  return (__m128i){ (long long)__q, (long long)__q };
}
# 3792 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_epi32(int __i)
{
  return (__m128i)(__v4si){ __i, __i, __i, __i };
}
# 3811 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_epi16(short __w)
{
  return (__m128i)(__v8hi){ __w, __w, __w, __w, __w, __w, __w, __w };
}
# 3830 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_epi8(char __b)
{
  return (__m128i)(__v16qi){ __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b };
}
# 3851 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setr_epi64(__m64 __q0, __m64 __q1)
{
  return (__m128i){ (long long)__q0, (long long)__q1 };
}
# 3874 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setr_epi32(int __i0, int __i1, int __i2, int __i3)
{
  return (__m128i)(__v4si){ __i0, __i1, __i2, __i3};
}
# 3905 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setr_epi16(short __w0, short __w1, short __w2, short __w3, short __w4, short __w5, short __w6, short __w7)
{
  return (__m128i)(__v8hi){ __w0, __w1, __w2, __w3, __w4, __w5, __w6, __w7 };
}
# 3952 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setr_epi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5, char __b6, char __b7, char __b8, char __b9, char __b10, char __b11, char __b12, char __b13, char __b14, char __b15)
{
  return (__m128i)(__v16qi){ __b0, __b1, __b2, __b3, __b4, __b5, __b6, __b7, __b8, __b9, __b10, __b11, __b12, __b13, __b14, __b15 };
}
# 3966 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setzero_si128(void)
{
  return (__m128i){ 0LL, 0LL };
}
# 3984 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_store_si128(__m128i *__p, __m128i __b)
{
  *__p = __b;
}
# 4000 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storeu_si128(__m128i *__p, __m128i __b)
{
  struct __storeu_si128 {
    __m128i __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si128*)__p)->__v = __b;
}
# 4030 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_maskmoveu_si128(__m128i __d, __m128i __n, char *__p)
{
  __builtin_ia32_maskmovdqu((__v16qi)__d, (__v16qi)__n, __p);
}
# 4049 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storel_epi64(__m128i *__p, __m128i __a)
{
  struct __mm_storel_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storel_epi64_struct*)__p)->__u = __a[0];
}
# 4072 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_pd(double *__p, __m128d __a)
{
  __builtin_nontemporal_store((__v2df)__a, (__v2df*)__p);
}
# 4091 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_si128(__m128i *__p, __m128i __a)
{
  __builtin_nontemporal_store((__v2di)__a, (__v2di*)__p);
}
# 4110 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_si32(int *__p, int __a)
{
  __builtin_ia32_movnti(__p, __a);
}
# 4130 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_si64(long long *__p, long long __a)
{
  __builtin_ia32_movnti64(__p, __a);
}



extern "C" {
# 4151 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
void _mm_clflush(void const * __p);
# 4162 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
void _mm_lfence(void);
# 4173 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
void _mm_mfence(void);


}
# 4201 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_packs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)__a, (__v8hi)__b);
}
# 4229 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_packs_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packssdw128((__v4si)__a, (__v4si)__b);
}
# 4257 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_packus_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)__a, (__v8hi)__b);
}
# 4285 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_extract_epi16(__m128i __a, int __imm)
{
  __v8hi __b = (__v8hi)__a;
  return (unsigned short)__b[__imm & 7];
}
# 4312 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_insert_epi16(__m128i __a, int __b, int __imm)
{
  __v8hi __c = (__v8hi)__a;
  __c[__imm & 7] = __b;
  return (__m128i)__c;
}
# 4332 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_movemask_epi8(__m128i __a)
{
  return __builtin_ia32_pmovmskb128((__v16qi)__a);
}
# 4471 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpackhi_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}
# 4498 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpackhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 4, 8+4, 5, 8+5, 6, 8+6, 7, 8+7);
}
# 4521 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpackhi_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 2, 4+2, 3, 4+3);
}
# 4542 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpackhi_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v2di)__a, (__v2di)__b, 1, 2+1);
}
# 4577 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpacklo_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7);
}
# 4605 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpacklo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 0, 8+0, 1, 8+1, 2, 8+2, 3, 8+3);
}
# 4628 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpacklo_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 0, 4+0, 1, 4+1);
}
# 4649 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpacklo_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v2di)__a, (__v2di)__b, 0, 2+0);
}
# 4666 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_movepi64_pi64(__m128i __a)
{
  return (__m64)__a[0];
}
# 4683 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_movpi64_epi64(__m64 __a)
{
  return (__m128i){ (long long)__a, 0 };
}
# 4701 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_move_epi64(__m128i __a)
{
  return __builtin_shufflevector((__v2di)__a, (__m128i){ 0 }, 0, 2);
}
# 4722 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpackhi_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__b, 1, 2+1);
}
# 4743 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpacklo_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__b, 0, 2+0);
}
# 4762 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_movemask_pd(__m128d __a)
{
  return __builtin_ia32_movmskpd((__v2df)__a);
}
# 4809 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castpd_ps(__m128d __a)
{
  return (__m128)__a;
}
# 4826 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castpd_si128(__m128d __a)
{
  return (__m128i)__a;
}
# 4843 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castps_pd(__m128 __a)
{
  return (__m128d)__a;
}
# 4860 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castps_si128(__m128 __a)
{
  return (__m128i)__a;
}
# 4877 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castsi128_ps(__m128i __a)
{
  return (__m128)__a;
}
# 4894 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castsi128_pd(__m128i __a)
{
  return (__m128d)__a;
}


extern "C" {
# 4911 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/emmintrin.h" 3 4
void _mm_pause(void);


}
# 2967 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xmmintrin.h" 2 3 4
# 33 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4







# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 1 3 4
# 47 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_lddqu_si128(__m128i const *__p)
{
  return (__m128i)__builtin_ia32_lddqu((char const *)__p);
}
# 66 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_addsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_addsubps((__v4sf)__a, (__v4sf)__b);
}
# 89 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_hadd_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_haddps((__v4sf)__a, (__v4sf)__b);
}
# 112 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_hsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_hsubps((__v4sf)__a, (__v4sf)__b);
}
# 134 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_movehdup_ps(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 1, 1, 3, 3);
}
# 155 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_moveldup_ps(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 0, 2, 2);
}
# 174 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_addsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_addsubpd((__v2df)__a, (__v2df)__b);
}
# 197 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_hadd_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_haddpd((__v2df)__a, (__v2df)__b);
}
# 220 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_hsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_hsubpd((__v2df)__a, (__v2df)__b);
}
# 256 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_movedup_pd(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 0);
}
# 277 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_monitor(void const *__p, unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_monitor((void *)__p, __extensions, __hints);
}
# 296 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_mwait(unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_mwait(__extensions, __hints);
}
# 41 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_pi8(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsb((__v8qi)__a);
}
# 62 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_epi8(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsb128((__v16qi)__a);
}
# 80 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_pi16(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsw((__v4hi)__a);
}
# 98 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_epi16(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsw128((__v8hi)__a);
}
# 116 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_pi32(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsd((__v2si)__a);
}
# 134 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_epi32(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsd128((__v4si)__a);
}
# 203 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadd_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddw128((__v8hi)__a, (__v8hi)__b);
}
# 226 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadd_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddd128((__v4si)__a, (__v4si)__b);
}
# 249 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadd_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddw((__v4hi)__a, (__v4hi)__b);
}
# 272 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadd_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddd((__v2si)__a, (__v2si)__b);
}
# 296 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadds_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddsw128((__v8hi)__a, (__v8hi)__b);
}
# 320 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadds_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddsw((__v4hi)__a, (__v4hi)__b);
}
# 343 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsub_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubw128((__v8hi)__a, (__v8hi)__b);
}
# 366 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsub_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubd128((__v4si)__a, (__v4si)__b);
}
# 389 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsub_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubw((__v4hi)__a, (__v4hi)__b);
}
# 412 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsub_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubd((__v2si)__a, (__v2si)__b);
}
# 437 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubsw128((__v8hi)__a, (__v8hi)__b);
}
# 462 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubsw((__v4hi)__a, (__v4hi)__b);
}
# 496 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_maddubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmaddubsw128((__v16qi)__a, (__v16qi)__b);
}
# 526 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_maddubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmaddubsw((__v8qi)__a, (__v8qi)__b);
}
# 546 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_mulhrs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmulhrsw128((__v8hi)__a, (__v8hi)__b);
}
# 566 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_mulhrs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmulhrsw((__v4hi)__a, (__v4hi)__b);
}
# 592 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_shuffle_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pshufb128((__v16qi)__a, (__v16qi)__b);
}
# 617 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_shuffle_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pshufb((__v8qi)__a, (__v8qi)__b);
}
# 643 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignb128((__v16qi)__a, (__v16qi)__b);
}
# 669 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignw128((__v8hi)__a, (__v8hi)__b);
}
# 695 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignd128((__v4si)__a, (__v4si)__b);
}
# 721 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignb((__v8qi)__a, (__v8qi)__b);
}
# 747 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignw((__v4hi)__a, (__v4hi)__b);
}
# 773 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignd((__v2si)__a, (__v2si)__b);
}
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 1 3 4
# 449 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_blendv_pd (__m128d __V1, __m128d __V2, __m128d __M)
{
  return (__m128d) __builtin_ia32_blendvpd ((__v2df)__V1, (__v2df)__V2,
                                            (__v2df)__M);
}
# 476 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_blendv_ps (__m128 __V1, __m128 __V2, __m128 __M)
{
  return (__m128) __builtin_ia32_blendvps ((__v4sf)__V1, (__v4sf)__V2,
                                           (__v4sf)__M);
}
# 503 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_blendv_epi8 (__m128i __V1, __m128i __V2, __m128i __M)
{
  return (__m128i) __builtin_ia32_pblendvb128 ((__v16qi)__V1, (__v16qi)__V2,
                                               (__v16qi)__M);
}
# 560 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_mullo_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) ((__v4su)__V1 * (__v4su)__V2);
}
# 580 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_mul_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmuldq128 ((__v4si)__V1, (__v4si)__V2);
}
# 671 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_stream_load_si128 (__m128i const *__V)
{
  return (__m128i) __builtin_nontemporal_load ((const __v2di *) __V);
}
# 691 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_min_epi8 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminsb128 ((__v16qi) __V1, (__v16qi) __V2);
}
# 710 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_max_epi8 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxsb128 ((__v16qi) __V1, (__v16qi) __V2);
}
# 729 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_min_epu16 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminuw128 ((__v8hi) __V1, (__v8hi) __V2);
}
# 748 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_max_epu16 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxuw128 ((__v8hi) __V1, (__v8hi) __V2);
}
# 767 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_min_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminsd128 ((__v4si) __V1, (__v4si) __V2);
}
# 786 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_max_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxsd128 ((__v4si) __V1, (__v4si) __V2);
}
# 805 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_min_epu32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminud128((__v4si) __V1, (__v4si) __V2);
}
# 824 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_max_epu32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxud128((__v4si) __V1, (__v4si) __V2);
}
# 1132 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_testz_si128(__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestz128((__v2di)__M, (__v2di)__V);
}
# 1150 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_testc_si128(__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestc128((__v2di)__M, (__v2di)__V);
}
# 1169 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_testnzc_si128(__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestnzc128((__v2di)__M, (__v2di)__V);
}
# 1242 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cmpeq_epi64(__m128i __V1, __m128i __V2)
{
  return (__m128i)((__v2di)__V1 == (__v2di)__V2);
}
# 1262 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi8_epi16(__m128i __V)
{


  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3, 4, 5, 6, 7), __v8hi);
}
# 1283 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi8_epi32(__m128i __V)
{


  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3), __v4si);
}
# 1304 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi8_epi64(__m128i __V)
{


  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1), __v2di);
}
# 1325 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi16_epi32(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v8hi)__V, (__v8hi)__V, 0, 1, 2, 3), __v4si);
}
# 1344 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi16_epi64(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v8hi)__V, (__v8hi)__V, 0, 1), __v2di);
}
# 1363 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi32_epi64(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v4si)__V, (__v4si)__V, 0, 1), __v2di);
}
# 1383 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu8_epi16(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1, 2, 3, 4, 5, 6, 7), __v8hi);
}
# 1402 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu8_epi32(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1, 2, 3), __v4si);
}
# 1421 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu8_epi64(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1), __v2di);
}
# 1440 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu16_epi32(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v8hu)__V, (__v8hu)__V, 0, 1, 2, 3), __v4si);
}
# 1459 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu16_epi64(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v8hu)__V, (__v8hu)__V, 0, 1), __v2di);
}
# 1478 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu32_epi64(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v4su)__V, (__v4su)__V, 0, 1), __v2di);
}
# 1507 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_packus_epi32(__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_packusdw128((__v4si)__V1, (__v4si)__V2);
}
# 1566 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_minpos_epu16(__m128i __V)
{
  return (__m128i) __builtin_ia32_phminposuw128((__v8hi)__V);
}
# 2370 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
_mm_cmpgt_epi64(__m128i __V1, __m128i __V2)
{
  return (__m128i)((__v2di)__V1 > (__v2di)__V2);
}
# 2391 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
_mm_crc32_u8(unsigned int __C, unsigned char __D)
{
  return __builtin_ia32_crc32qi(__C, __D);
}
# 2411 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
_mm_crc32_u16(unsigned int __C, unsigned short __D)
{
  return __builtin_ia32_crc32hi(__C, __D);
}
# 2431 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
_mm_crc32_u32(unsigned int __C, unsigned int __D)
{
  return __builtin_ia32_crc32si(__C, __D);
}
# 2452 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/smmintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
_mm_crc32_u64(unsigned long long __C, unsigned long long __D)
{
  return __builtin_ia32_crc32di(__C, __D);
}
# 50 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/wmmintrin.h" 1 3 4
# 29 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/wmmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/__wmmintrin_aes.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes")))
_mm_aesenc_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesenc128((__v2di)__V, (__v2di)__R);
}
# 65 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes")))
_mm_aesenclast_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesenclast128((__v2di)__V, (__v2di)__R);
}
# 85 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes")))
_mm_aesdec_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesdec128((__v2di)__V, (__v2di)__R);
}
# 105 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes")))
_mm_aesdeclast_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesdeclast128((__v2di)__V, (__v2di)__R);
}
# 122 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes")))
_mm_aesimc_si128(__m128i __V)
{
  return (__m128i)__builtin_ia32_aesimc128((__v2di)__V);
}
# 30 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/wmmintrin.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/__wmmintrin_pclmul.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/wmmintrin.h" 2 3 4
# 55 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/clflushoptintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/clflushoptintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("clflushopt")))
_mm_clflushopt(char * __m) {
  __builtin_ia32_clflushopt(__m);
}
# 59 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
typedef double __v4df __attribute__ ((__vector_size__ (32)));
typedef float __v8sf __attribute__ ((__vector_size__ (32)));
typedef long long __v4di __attribute__ ((__vector_size__ (32)));
typedef int __v8si __attribute__ ((__vector_size__ (32)));
typedef short __v16hi __attribute__ ((__vector_size__ (32)));
typedef char __v32qi __attribute__ ((__vector_size__ (32)));


typedef unsigned long long __v4du __attribute__ ((__vector_size__ (32)));
typedef unsigned int __v8su __attribute__ ((__vector_size__ (32)));
typedef unsigned short __v16hu __attribute__ ((__vector_size__ (32)));
typedef unsigned char __v32qu __attribute__ ((__vector_size__ (32)));



typedef signed char __v32qs __attribute__((__vector_size__(32)));

typedef float __m256 __attribute__ ((__vector_size__ (32)));
typedef double __m256d __attribute__((__vector_size__(32)));
typedef long long __m256i __attribute__((__vector_size__(32)));
# 68 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_add_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a+(__v4df)__b);
}
# 86 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_add_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a+(__v8sf)__b);
}
# 104 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_sub_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a-(__v4df)__b);
}
# 122 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_sub_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a-(__v8sf)__b);
}
# 141 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_addsub_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_addsubpd256((__v4df)__a, (__v4df)__b);
}
# 160 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_addsub_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_addsubps256((__v8sf)__a, (__v8sf)__b);
}
# 178 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_div_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a/(__v4df)__b);
}
# 196 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_div_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a/(__v8sf)__b);
}
# 215 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_max_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_maxpd256((__v4df)__a, (__v4df)__b);
}
# 234 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_max_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_maxps256((__v8sf)__a, (__v8sf)__b);
}
# 253 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_min_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_minpd256((__v4df)__a, (__v4df)__b);
}
# 272 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_min_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_minps256((__v8sf)__a, (__v8sf)__b);
}
# 290 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_mul_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a * (__v4df)__b);
}
# 308 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_mul_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a * (__v8sf)__b);
}
# 325 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_sqrt_pd(__m256d __a)
{
  return (__m256d)__builtin_ia32_sqrtpd256((__v4df)__a);
}
# 342 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_sqrt_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_sqrtps256((__v8sf)__a);
}
# 359 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_rsqrt_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_rsqrtps256((__v8sf)__a);
}
# 376 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_rcp_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_rcpps256((__v8sf)__a);
}
# 528 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_and_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4du)__a & (__v4du)__b);
}
# 546 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_and_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8su)__a & (__v8su)__b);
}
# 567 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_andnot_pd(__m256d __a, __m256d __b)
{
  return (__m256d)(~(__v4du)__a & (__v4du)__b);
}
# 588 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_andnot_ps(__m256 __a, __m256 __b)
{
  return (__m256)(~(__v8su)__a & (__v8su)__b);
}
# 606 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_or_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4du)__a | (__v4du)__b);
}
# 624 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_or_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8su)__a | (__v8su)__b);
}
# 642 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_xor_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4du)__a ^ (__v4du)__b);
}
# 660 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_xor_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8su)__a ^ (__v8su)__b);
}
# 684 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_hadd_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_haddpd256((__v4df)__a, (__v4df)__b);
}
# 707 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_hadd_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_haddps256((__v8sf)__a, (__v8sf)__b);
}
# 730 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_hsub_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_hsubpd256((__v4df)__a, (__v4df)__b);
}
# 753 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_hsub_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_hsubps256((__v8sf)__a, (__v8sf)__b);
}
# 783 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_permutevar_pd(__m128d __a, __m128i __c)
{
  return (__m128d)__builtin_ia32_vpermilvarpd((__v2df)__a, (__v2di)__c);
}
# 822 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_permutevar_pd(__m256d __a, __m256i __c)
{
  return (__m256d)__builtin_ia32_vpermilvarpd256((__v4df)__a, (__v4di)__c);
}
# 876 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_permutevar_ps(__m128 __a, __m128i __c)
{
  return (__m128)__builtin_ia32_vpermilvarps((__v4sf)__a, (__v4si)__c);
}
# 967 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_permutevar_ps(__m256 __a, __m256i __c)
{
  return (__m256)__builtin_ia32_vpermilvarps256((__v8sf)__a, (__v8si)__c);
}
# 1422 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_blendv_pd(__m256d __a, __m256d __b, __m256d __c)
{
  return (__m256d)__builtin_ia32_blendvpd256(
    (__v4df)__a, (__v4df)__b, (__v4df)__c);
}
# 1450 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_blendv_ps(__m256 __a, __m256 __b, __m256 __c)
{
  return (__m256)__builtin_ia32_blendvps256(
    (__v8sf)__a, (__v8sf)__b, (__v8sf)__c);
}
# 2018 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_extract_epi32(__m256i __a, const int __imm)
{
  __v8si __b = (__v8si)__a;
  return __b[__imm & 7];
}
# 2040 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_extract_epi16(__m256i __a, const int __imm)
{
  __v16hi __b = (__v16hi)__a;
  return (unsigned short)__b[__imm & 15];
}
# 2062 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_extract_epi8(__m256i __a, const int __imm)
{
  __v32qi __b = (__v32qi)__a;
  return (unsigned char)__b[__imm & 31];
}
# 2085 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline long long __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_extract_epi64(__m256i __a, const int __imm)
{
  __v4di __b = (__v4di)__a;
  return __b[__imm & 3];
}
# 2111 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_insert_epi32(__m256i __a, int __b, int const __imm)
{
  __v8si __c = (__v8si)__a;
  __c[__imm & 7] = __b;
  return (__m256i)__c;
}
# 2138 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_insert_epi16(__m256i __a, int __b, int const __imm)
{
  __v16hi __c = (__v16hi)__a;
  __c[__imm & 15] = __b;
  return (__m256i)__c;
}
# 2164 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_insert_epi8(__m256i __a, int __b, int const __imm)
{
  __v32qi __c = (__v32qi)__a;
  __c[__imm & 31] = __b;
  return (__m256i)__c;
}
# 2191 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_insert_epi64(__m256i __a, long long __b, int const __imm)
{
  __v4di __c = (__v4di)__a;
  __c[__imm & 3] = __b;
  return (__m256i)__c;
}
# 2210 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtepi32_pd(__m128i __a)
{
  return (__m256d)__builtin_convertvector((__v4si)__a, __v4df);
}
# 2225 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtepi32_ps(__m256i __a)
{
  return (__m256)__builtin_ia32_cvtdq2ps256((__v8si) __a);
}
# 2241 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtpd_ps(__m256d __a)
{
  return (__m128)__builtin_ia32_cvtpd2ps256((__v4df) __a);
}
# 2256 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtps_epi32(__m256 __a)
{
  return (__m256i)__builtin_ia32_cvtps2dq256((__v8sf) __a);
}
# 2272 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtps_pd(__m128 __a)
{
  return (__m256d)__builtin_convertvector((__v4sf)__a, __v4df);
}
# 2289 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvttpd_epi32(__m256d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq256((__v4df) __a);
}
# 2306 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtpd_epi32(__m256d __a)
{
  return (__m128i)__builtin_ia32_cvtpd2dq256((__v4df) __a);
}
# 2322 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvttps_epi32(__m256 __a)
{
  return (__m256i)__builtin_ia32_cvttps2dq256((__v8sf) __a);
}
# 2338 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline double __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtsd_f64(__m256d __a)
{
 return __a[0];
}
# 2354 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtsi256_si32(__m256i __a)
{
 __v8si __b = (__v8si)__a;
 return __b[0];
}
# 2371 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline float __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtss_f32(__m256 __a)
{
 return __a[0];
}
# 2398 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_movehdup_ps(__m256 __a)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__a, 1, 1, 3, 3, 5, 5, 7, 7);
}
# 2423 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_moveldup_ps(__m256 __a)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__a, 0, 0, 2, 2, 4, 4, 6, 6);
}
# 2445 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_movedup_pd(__m256d __a)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__a, 0, 0, 2, 2);
}
# 2468 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_unpackhi_pd(__m256d __a, __m256d __b)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__b, 1, 5, 1+2, 5+2);
}
# 2490 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_unpacklo_pd(__m256d __a, __m256d __b)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__b, 0, 4, 0+2, 4+2);
}
# 2517 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_unpackhi_ps(__m256 __a, __m256 __b)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__b, 2, 10, 2+1, 10+1, 6, 14, 6+1, 14+1);
}
# 2544 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_unpacklo_ps(__m256 __a, __m256 __b)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__b, 0, 8, 0+1, 8+1, 4, 12, 4+1, 12+1);
}
# 2574 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testz_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestzpd((__v2df)__a, (__v2df)__b);
}
# 2603 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testc_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestcpd((__v2df)__a, (__v2df)__b);
}
# 2633 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testnzc_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestnzcpd((__v2df)__a, (__v2df)__b);
}
# 2662 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testz_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestzps((__v4sf)__a, (__v4sf)__b);
}
# 2691 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testc_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestcps((__v4sf)__a, (__v4sf)__b);
}
# 2721 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testnzc_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestnzcps((__v4sf)__a, (__v4sf)__b);
}
# 2750 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testz_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestzpd256((__v4df)__a, (__v4df)__b);
}
# 2779 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testc_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestcpd256((__v4df)__a, (__v4df)__b);
}
# 2809 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testnzc_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestnzcpd256((__v4df)__a, (__v4df)__b);
}
# 2838 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testz_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestzps256((__v8sf)__a, (__v8sf)__b);
}
# 2867 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testc_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestcps256((__v8sf)__a, (__v8sf)__b);
}
# 2897 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testnzc_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestnzcps256((__v8sf)__a, (__v8sf)__b);
}
# 2923 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testz_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestz256((__v4di)__a, (__v4di)__b);
}
# 2949 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testc_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestc256((__v4di)__a, (__v4di)__b);
}
# 2976 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testnzc_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestnzc256((__v4di)__a, (__v4di)__b);
}
# 2995 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_movemask_pd(__m256d __a)
{
  return __builtin_ia32_movmskpd256((__v4df)__a);
}
# 3013 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_movemask_ps(__m256 __a)
{
  return __builtin_ia32_movmskps256((__v8sf)__a);
}







static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_zeroall(void)
{
  __builtin_ia32_vzeroall();
}






static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_zeroupper(void)
{
  __builtin_ia32_vzeroupper();
}
# 3055 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_broadcast_ss(float const *__a)
{
  float __f = *__a;
  return (__m128)(__v4sf){ __f, __f, __f, __f };
}
# 3074 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_broadcast_sd(double const *__a)
{
  double __d = *__a;
  return (__m256d)(__v4df){ __d, __d, __d, __d };
}
# 3093 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_broadcast_ss(float const *__a)
{
  float __f = *__a;
  return (__m256)(__v8sf){ __f, __f, __f, __f, __f, __f, __f, __f };
}
# 3112 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_broadcast_pd(__m128d const *__a)
{
  return (__m256d)__builtin_ia32_vbroadcastf128_pd256((__v2df const *)__a);
}
# 3130 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_broadcast_ps(__m128 const *__a)
{
  return (__m256)__builtin_ia32_vbroadcastf128_ps256((__v4sf const *)__a);
}
# 3148 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_load_pd(double const *__p)
{
  return *(__m256d *)__p;
}
# 3164 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_load_ps(float const *__p)
{
  return *(__m256 *)__p;
}
# 3181 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu_pd(double const *__p)
{
  struct __loadu_pd {
    __m256d __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_pd*)__p)->__v;
}
# 3201 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu_ps(float const *__p)
{
  struct __loadu_ps {
    __m256 __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)__p)->__v;
}
# 3221 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_load_si256(__m256i const *__p)
{
  return *__p;
}
# 3237 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu_si256(__m256i const *__p)
{
  struct __loadu_si256 {
    __m256i __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_si256*)__p)->__v;
}
# 3258 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_lddqu_si256(__m256i const *__p)
{
  return (__m256i)__builtin_ia32_lddqu256((char const *)__p);
}
# 3278 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_store_pd(double *__p, __m256d __a)
{
  *(__m256d *)__p = __a;
}
# 3296 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_store_ps(float *__p, __m256 __a)
{
  *(__m256 *)__p = __a;
}
# 3314 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu_pd(double *__p, __m256d __a)
{
  struct __storeu_pd {
    __m256d __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_pd*)__p)->__v = __a;
}
# 3334 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu_ps(float *__p, __m256 __a)
{
  struct __storeu_ps {
    __m256 __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_ps*)__p)->__v = __a;
}
# 3355 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_store_si256(__m256i *__p, __m256i __a)
{
  *__p = __a;
}
# 3372 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu_si256(__m256i *__p, __m256i __a)
{
  struct __storeu_si256 {
    __m256i __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si256*)__p)->__v = __a;
}
# 3400 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_maskload_pd(double const *__p, __m128i __m)
{
  return (__m128d)__builtin_ia32_maskloadpd((const __v2df *)__p, (__v2di)__m);
}
# 3424 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_maskload_pd(double const *__p, __m256i __m)
{
  return (__m256d)__builtin_ia32_maskloadpd256((const __v4df *)__p,
                                               (__v4di)__m);
}
# 3449 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_maskload_ps(float const *__p, __m128i __m)
{
  return (__m128)__builtin_ia32_maskloadps((const __v4sf *)__p, (__v4si)__m);
}
# 3473 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_maskload_ps(float const *__p, __m256i __m)
{
  return (__m256)__builtin_ia32_maskloadps256((const __v8sf *)__p, (__v8si)__m);
}
# 3498 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_maskstore_ps(float *__p, __m256i __m, __m256 __a)
{
  __builtin_ia32_maskstoreps256((__v8sf *)__p, (__v8si)__m, (__v8sf)__a);
}
# 3522 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_maskstore_pd(double *__p, __m128i __m, __m128d __a)
{
  __builtin_ia32_maskstorepd((__v2df *)__p, (__v2di)__m, (__v2df)__a);
}
# 3546 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_maskstore_pd(double *__p, __m256i __m, __m256d __a)
{
  __builtin_ia32_maskstorepd256((__v4df *)__p, (__v4di)__m, (__v4df)__a);
}
# 3570 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_maskstore_ps(float *__p, __m128i __m, __m128 __a)
{
  __builtin_ia32_maskstoreps((__v4sf *)__p, (__v4si)__m, (__v4sf)__a);
}
# 3590 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_stream_si256(__m256i *__a, __m256i __b)
{
  typedef __v4di __v4di_aligned __attribute__((aligned(32)));
  __builtin_nontemporal_store((__v4di_aligned)__b, (__v4di_aligned*)__a);
}
# 3610 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_stream_pd(double *__a, __m256d __b)
{
  typedef __v4df __v4df_aligned __attribute__((aligned(32)));
  __builtin_nontemporal_store((__v4df_aligned)__b, (__v4df_aligned*)__a);
}
# 3631 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_stream_ps(float *__p, __m256 __a)
{
  typedef __v8sf __v8sf_aligned __attribute__((aligned(32)));
  __builtin_nontemporal_store((__v8sf_aligned)__a, (__v8sf_aligned*)__p);
}
# 3646 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_undefined_pd(void)
{
  return (__m256d)__builtin_ia32_undef256();
}
# 3659 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_undefined_ps(void)
{
  return (__m256)__builtin_ia32_undef256();
}
# 3672 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_undefined_si256(void)
{
  return (__m256i)__builtin_ia32_undef256();
}
# 3699 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_pd(double __a, double __b, double __c, double __d)
{
  return (__m256d){ __d, __c, __b, __a };
}
# 3738 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_ps(float __a, float __b, float __c, float __d,
              float __e, float __f, float __g, float __h)
{
  return (__m256){ __h, __g, __f, __e, __d, __c, __b, __a };
}
# 3770 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_epi32(int __i0, int __i1, int __i2, int __i3,
                 int __i4, int __i5, int __i6, int __i7)
{
  return (__m256i)(__v8si){ __i7, __i6, __i5, __i4, __i3, __i2, __i1, __i0 };
}
# 3818 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_epi16(short __w15, short __w14, short __w13, short __w12,
                 short __w11, short __w10, short __w09, short __w08,
                 short __w07, short __w06, short __w05, short __w04,
                 short __w03, short __w02, short __w01, short __w00)
{
  return (__m256i)(__v16hi){ __w00, __w01, __w02, __w03, __w04, __w05, __w06,
    __w07, __w08, __w09, __w10, __w11, __w12, __w13, __w14, __w15 };
}
# 3901 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_epi8(char __b31, char __b30, char __b29, char __b28,
                char __b27, char __b26, char __b25, char __b24,
                char __b23, char __b22, char __b21, char __b20,
                char __b19, char __b18, char __b17, char __b16,
                char __b15, char __b14, char __b13, char __b12,
                char __b11, char __b10, char __b09, char __b08,
                char __b07, char __b06, char __b05, char __b04,
                char __b03, char __b02, char __b01, char __b00)
{
  return (__m256i)(__v32qi){
    __b00, __b01, __b02, __b03, __b04, __b05, __b06, __b07,
    __b08, __b09, __b10, __b11, __b12, __b13, __b14, __b15,
    __b16, __b17, __b18, __b19, __b20, __b21, __b22, __b23,
    __b24, __b25, __b26, __b27, __b28, __b29, __b30, __b31
  };
}
# 3936 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_epi64x(long long __a, long long __b, long long __c, long long __d)
{
  return (__m256i)(__v4di){ __d, __c, __b, __a };
}
# 3965 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_pd(double __a, double __b, double __c, double __d)
{
  return (__m256d){ __a, __b, __c, __d };
}
# 4005 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_ps(float __a, float __b, float __c, float __d,
               float __e, float __f, float __g, float __h)
{
  return (__m256){ __a, __b, __c, __d, __e, __f, __g, __h };
}
# 4037 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_epi32(int __i0, int __i1, int __i2, int __i3,
                  int __i4, int __i5, int __i6, int __i7)
{
  return (__m256i)(__v8si){ __i0, __i1, __i2, __i3, __i4, __i5, __i6, __i7 };
}
# 4085 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_epi16(short __w15, short __w14, short __w13, short __w12,
       short __w11, short __w10, short __w09, short __w08,
       short __w07, short __w06, short __w05, short __w04,
       short __w03, short __w02, short __w01, short __w00)
{
  return (__m256i)(__v16hi){ __w15, __w14, __w13, __w12, __w11, __w10, __w09,
    __w08, __w07, __w06, __w05, __w04, __w03, __w02, __w01, __w00 };
}
# 4168 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_epi8(char __b31, char __b30, char __b29, char __b28,
                 char __b27, char __b26, char __b25, char __b24,
                 char __b23, char __b22, char __b21, char __b20,
                 char __b19, char __b18, char __b17, char __b16,
                 char __b15, char __b14, char __b13, char __b12,
                 char __b11, char __b10, char __b09, char __b08,
                 char __b07, char __b06, char __b05, char __b04,
                 char __b03, char __b02, char __b01, char __b00)
{
  return (__m256i)(__v32qi){
    __b31, __b30, __b29, __b28, __b27, __b26, __b25, __b24,
    __b23, __b22, __b21, __b20, __b19, __b18, __b17, __b16,
    __b15, __b14, __b13, __b12, __b11, __b10, __b09, __b08,
    __b07, __b06, __b05, __b04, __b03, __b02, __b01, __b00 };
}
# 4202 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_epi64x(long long __a, long long __b, long long __c, long long __d)
{
  return (__m256i)(__v4di){ __a, __b, __c, __d };
}
# 4221 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_pd(double __w)
{
  return (__m256d){ __w, __w, __w, __w };
}
# 4240 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_ps(float __w)
{
  return (__m256){ __w, __w, __w, __w, __w, __w, __w, __w };
}
# 4259 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_epi32(int __i)
{
  return (__m256i)(__v8si){ __i, __i, __i, __i, __i, __i, __i, __i };
}
# 4277 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_epi16(short __w)
{
  return (__m256i)(__v16hi){ __w, __w, __w, __w, __w, __w, __w, __w, __w, __w,
    __w, __w, __w, __w, __w, __w };
}
# 4295 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_epi8(char __b)
{
  return (__m256i)(__v32qi){ __b, __b, __b, __b, __b, __b, __b, __b, __b, __b,
    __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b,
    __b, __b, __b, __b, __b, __b, __b };
}
# 4315 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_epi64x(long long __q)
{
  return (__m256i)(__v4di){ __q, __q, __q, __q };
}
# 4330 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setzero_pd(void)
{
  return (__m256d){ 0, 0, 0, 0 };
}
# 4344 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setzero_ps(void)
{
  return (__m256){ 0, 0, 0, 0, 0, 0, 0, 0 };
}
# 4357 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setzero_si256(void)
{
  return (__m256i){ 0LL, 0LL, 0LL, 0LL };
}
# 4375 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castpd_ps(__m256d __a)
{
  return (__m256)__a;
}
# 4392 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castpd_si256(__m256d __a)
{
  return (__m256i)__a;
}
# 4409 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castps_pd(__m256 __a)
{
  return (__m256d)__a;
}
# 4426 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castps_si256(__m256 __a)
{
  return (__m256i)__a;
}
# 4443 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castsi256_ps(__m256i __a)
{
  return (__m256)__a;
}
# 4460 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castsi256_pd(__m256i __a)
{
  return (__m256d)__a;
}
# 4477 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castpd256_pd128(__m256d __a)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__a, 0, 1);
}
# 4494 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castps256_ps128(__m256 __a)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__a, 0, 1, 2, 3);
}
# 4510 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castsi256_si128(__m256i __a)
{
  return __builtin_shufflevector((__v4di)__a, (__v4di)__a, 0, 1);
}
# 4531 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castpd128_pd256(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 1, -1, -1);
}
# 4552 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castps128_ps256(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 1, 2, 3, -1, -1, -1, -1);
}
# 4571 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castsi128_si256(__m128i __a)
{
  return __builtin_shufflevector((__v2di)__a, (__v2di)__a, 0, 1, -1, -1);
}
# 4590 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_zextpd128_pd256(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)_mm_setzero_pd(), 0, 1, 2, 3);
}
# 4608 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_zextps128_ps256(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)_mm_setzero_ps(), 0, 1, 2, 3, 4, 5, 6, 7);
}
# 4626 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_zextsi128_si256(__m128i __a)
{
  return __builtin_shufflevector((__v2di)__a, (__v2di)_mm_setzero_si128(), 0, 1, 2, 3);
}
# 4883 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu2_m128(float const *__addr_hi, float const *__addr_lo)
{
  __m256 __v256 = _mm256_castps128_ps256(_mm_loadu_ps(__addr_lo));
  return __extension__ ({ (__m256)__builtin_shufflevector( (__v8sf)(__m256)(__v256), (__v8sf)_mm256_castps128_ps256((__m128)(_mm_loadu_ps(__addr_hi))), (((1) & 1) ? 0 : 8), (((1) & 1) ? 1 : 9), (((1) & 1) ? 2 : 10), (((1) & 1) ? 3 : 11), (((1) & 1) ? 8 : 4), (((1) & 1) ? 9 : 5), (((1) & 1) ? 10 : 6), (((1) & 1) ? 11 : 7) );});
}
# 4911 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu2_m128d(double const *__addr_hi, double const *__addr_lo)
{
  __m256d __v256 = _mm256_castpd128_pd256(_mm_loadu_pd(__addr_lo));
  return __extension__ ({ (__m256d)__builtin_shufflevector( (__v4df)(__m256d)(__v256), (__v4df)_mm256_castpd128_pd256((__m128d)(_mm_loadu_pd(__addr_hi))), (((1) & 1) ? 0 : 4), (((1) & 1) ? 1 : 5), (((1) & 1) ? 4 : 2), (((1) & 1) ? 5 : 3) );});
}
# 4936 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu2_m128i(__m128i const *__addr_hi, __m128i const *__addr_lo)
{
  __m256i __v256 = _mm256_castsi128_si256(_mm_loadu_si128(__addr_lo));
  return __extension__ ({ (__m256i)__builtin_shufflevector( (__v4di)(__m256i)(__v256), (__v4di)_mm256_castsi128_si256((__m128i)(_mm_loadu_si128(__addr_hi))), (((1) & 1) ? 0 : 4), (((1) & 1) ? 1 : 5), (((1) & 1) ? 4 : 2), (((1) & 1) ? 5 : 3) );});
}
# 4962 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu2_m128(float *__addr_hi, float *__addr_lo, __m256 __a)
{
  __m128 __v128;

  __v128 = _mm256_castps256_ps128(__a);
  _mm_storeu_ps(__addr_lo, __v128);
  __v128 = __extension__ ({ (__m128)__builtin_shufflevector( (__v8sf)(__m256)(__a), (__v8sf)(_mm256_undefined_ps()), (((1) & 1) ? 4 : 0), (((1) & 1) ? 5 : 1), (((1) & 1) ? 6 : 2), (((1) & 1) ? 7 : 3) );});
  _mm_storeu_ps(__addr_hi, __v128);
}
# 4991 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu2_m128d(double *__addr_hi, double *__addr_lo, __m256d __a)
{
  __m128d __v128;

  __v128 = _mm256_castpd256_pd128(__a);
  _mm_storeu_pd(__addr_lo, __v128);
  __v128 = __extension__ ({ (__m128d)__builtin_shufflevector( (__v4df)(__m256d)(__a), (__v4df)(_mm256_undefined_pd()), (((1) & 1) ? 2 : 0), (((1) & 1) ? 3 : 1) );});
  _mm_storeu_pd(__addr_hi, __v128);
}
# 5020 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu2_m128i(__m128i *__addr_hi, __m128i *__addr_lo, __m256i __a)
{
  __m128i __v128;

  __v128 = _mm256_castsi256_si128(__a);
  _mm_storeu_si128(__addr_lo, __v128);
  __v128 = __extension__ ({ (__m128i)__builtin_shufflevector( (__v4di)(__m256i)(__a), (__v4di)(_mm256_undefined_si256()), (((1) & 1) ? 2 : 0), (((1) & 1) ? 3 : 1) );});
  _mm_storeu_si128(__addr_hi, __v128);
}
# 5046 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_m128 (__m128 __hi, __m128 __lo)
{
  return (__m256) __builtin_shufflevector((__v4sf)__lo, (__v4sf)__hi, 0, 1, 2, 3, 4, 5, 6, 7);
}
# 5067 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_m128d (__m128d __hi, __m128d __lo)
{
  return (__m256d)_mm256_set_m128((__m128)__hi, (__m128)__lo);
}
# 5087 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_m128i (__m128i __hi, __m128i __lo)
{
  return (__m256i)_mm256_set_m128((__m128)__hi, (__m128)__lo);
}
# 5110 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_m128 (__m128 __lo, __m128 __hi)
{
  return _mm256_set_m128(__hi, __lo);
}
# 5133 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_m128d (__m128d __lo, __m128d __hi)
{
  return (__m256d)_mm256_set_m128((__m128)__hi, (__m128)__lo);
}
# 5154 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_m128i (__m128i __lo, __m128i __hi)
{
  return (__m256i)_mm256_set_m128((__m128)__hi, (__m128)__lo);
}
# 63 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx2intrin.h" 1 3 4
# 39 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx2intrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_abs_epi8(__m256i __a)
{
    return (__m256i)__builtin_ia32_pabsb256((__v32qi)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_abs_epi16(__m256i __a)
{
    return (__m256i)__builtin_ia32_pabsw256((__v16hi)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_abs_epi32(__m256i __a)
{
    return (__m256i)__builtin_ia32_pabsd256((__v8si)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_packs_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_packsswb256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_packs_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_packssdw256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_packus_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_packuswb256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_packus_epi32(__m256i __V1, __m256i __V2)
{
  return (__m256i) __builtin_ia32_packusdw256((__v8si)__V1, (__v8si)__V2);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_add_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)((__v32qu)__a + (__v32qu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_add_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hu)__a + (__v16hu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_add_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8su)__a + (__v8su)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_add_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4du)__a + (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_adds_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_paddsb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_adds_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_paddsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_adds_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_paddusb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_adds_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_paddusw256((__v16hi)__a, (__v16hi)__b);
}





static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_and_si256(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4du)__a & (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_andnot_si256(__m256i __a, __m256i __b)
{
  return (__m256i)(~(__v4du)__a & (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_avg_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pavgb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_avg_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pavgw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_blendv_epi8(__m256i __V1, __m256i __V2, __m256i __M)
{
  return (__m256i)__builtin_ia32_pblendvb256((__v32qi)__V1, (__v32qi)__V2,
                                              (__v32qi)__M);
}
# 184 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx2intrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpeq_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)((__v32qi)__a == (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpeq_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hi)__a == (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpeq_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8si)__a == (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpeq_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4di)__a == (__v4di)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpgt_epi8(__m256i __a, __m256i __b)
{


  return (__m256i)((__v32qs)__a > (__v32qs)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpgt_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hi)__a > (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpgt_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8si)__a > (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpgt_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4di)__a > (__v4di)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hadd_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phaddw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hadd_epi32(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phaddd256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hadds_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phaddsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hsub_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phsubw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hsub_epi32(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phsubd256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hsubs_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phsubsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_maddubs_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_pmaddubsw256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_madd_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaddwd256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxsb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxsd256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxub256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxuw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epu32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxud256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminsb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminsd256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminub256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminuw256 ((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epu32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminud256((__v8si)__a, (__v8si)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_movemask_epi8(__m256i __a)
{
  return __builtin_ia32_pmovmskb256((__v32qi)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi8_epi16(__m128i __V)
{


  return (__m256i)__builtin_convertvector((__v16qs)__V, __v16hi);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi8_epi32(__m128i __V)
{


  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3, 4, 5, 6, 7), __v8si);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi8_epi64(__m128i __V)
{


  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3), __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi16_epi32(__m128i __V)
{
  return (__m256i)__builtin_convertvector((__v8hi)__V, __v8si);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi16_epi64(__m128i __V)
{
  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v8hi)__V, (__v8hi)__V, 0, 1, 2, 3), __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi32_epi64(__m128i __V)
{
  return (__m256i)__builtin_convertvector((__v4si)__V, __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu8_epi16(__m128i __V)
{
  return (__m256i)__builtin_convertvector((__v16qu)__V, __v16hi);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu8_epi32(__m128i __V)
{
  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1, 2, 3, 4, 5, 6, 7), __v8si);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu8_epi64(__m128i __V)
{
  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1, 2, 3), __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu16_epi32(__m128i __V)
{
  return (__m256i)__builtin_convertvector((__v8hu)__V, __v8si);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu16_epi64(__m128i __V)
{
  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v8hu)__V, (__v8hu)__V, 0, 1, 2, 3), __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu32_epi64(__m128i __V)
{
  return (__m256i)__builtin_convertvector((__v4su)__V, __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mul_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmuldq256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mulhrs_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmulhrsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mulhi_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmulhuw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mulhi_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmulhw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mullo_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hu)__a * (__v16hu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mullo_epi32 (__m256i __a, __m256i __b)
{
  return (__m256i)((__v8su)__a * (__v8su)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mul_epu32(__m256i __a, __m256i __b)
{
  return __builtin_ia32_pmuludq256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_or_si256(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4du)__a | (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sad_epu8(__m256i __a, __m256i __b)
{
  return __builtin_ia32_psadbw256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_shuffle_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pshufb256((__v32qi)__a, (__v32qi)__b);
}
# 538 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx2intrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sign_epi8(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_psignb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sign_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_psignw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sign_epi32(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_psignd256((__v8si)__a, (__v8si)__b);
}
# 595 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx2intrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_slli_epi16(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psllwi256((__v16hi)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sll_epi16(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psllw256((__v16hi)__a, (__v8hi)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_slli_epi32(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_pslldi256((__v8si)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sll_epi32(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_pslld256((__v8si)__a, (__v4si)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_slli_epi64(__m256i __a, int __count)
{
  return __builtin_ia32_psllqi256((__v4di)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sll_epi64(__m256i __a, __m128i __count)
{
  return __builtin_ia32_psllq256((__v4di)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srai_epi16(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psrawi256((__v16hi)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sra_epi16(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psraw256((__v16hi)__a, (__v8hi)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srai_epi32(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psradi256((__v8si)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sra_epi32(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psrad256((__v8si)__a, (__v4si)__count);
}
# 694 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx2intrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srli_epi16(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psrlwi256((__v16hi)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srl_epi16(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psrlw256((__v16hi)__a, (__v8hi)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srli_epi32(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psrldi256((__v8si)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srl_epi32(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psrld256((__v8si)__a, (__v4si)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srli_epi64(__m256i __a, int __count)
{
  return __builtin_ia32_psrlqi256((__v4di)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srl_epi64(__m256i __a, __m128i __count)
{
  return __builtin_ia32_psrlq256((__v4di)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sub_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)((__v32qu)__a - (__v32qu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sub_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hu)__a - (__v16hu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sub_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8su)__a - (__v8su)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sub_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4du)__a - (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_subs_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_psubsb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_subs_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_psubsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_subs_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_psubusb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_subs_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_psubusw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpackhi_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v32qi)__a, (__v32qi)__b, 8, 32+8, 9, 32+9, 10, 32+10, 11, 32+11, 12, 32+12, 13, 32+13, 14, 32+14, 15, 32+15, 24, 32+24, 25, 32+25, 26, 32+26, 27, 32+27, 28, 32+28, 29, 32+29, 30, 32+30, 31, 32+31);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpackhi_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v16hi)__a, (__v16hi)__b, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpackhi_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v8si)__a, (__v8si)__b, 2, 8+2, 3, 8+3, 6, 8+6, 7, 8+7);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpackhi_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v4di)__a, (__v4di)__b, 1, 4+1, 3, 4+3);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpacklo_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v32qi)__a, (__v32qi)__b, 0, 32+0, 1, 32+1, 2, 32+2, 3, 32+3, 4, 32+4, 5, 32+5, 6, 32+6, 7, 32+7, 16, 32+16, 17, 32+17, 18, 32+18, 19, 32+19, 20, 32+20, 21, 32+21, 22, 32+22, 23, 32+23);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpacklo_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v16hi)__a, (__v16hi)__b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpacklo_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v8si)__a, (__v8si)__b, 0, 8+0, 1, 8+1, 4, 8+4, 5, 8+5);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpacklo_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v4di)__a, (__v4di)__b, 0, 4+0, 2, 4+2);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_xor_si256(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4du)__a ^ (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_stream_load_si256(__m256i const *__V)
{
  typedef __v4di __v4di_aligned __attribute__((aligned(32)));
  return (__m256i)__builtin_nontemporal_load((const __v4di_aligned *)__V);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastss_ps(__m128 __X)
{
  return (__m128)__builtin_shufflevector((__v4sf)__X, (__v4sf)__X, 0, 0, 0, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastsd_pd(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 0);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastss_ps(__m128 __X)
{
  return (__m256)__builtin_shufflevector((__v4sf)__X, (__v4sf)__X, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastsd_pd(__m128d __X)
{
  return (__m256d)__builtin_shufflevector((__v2df)__X, (__v2df)__X, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastsi128_si256(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v2di)__X, (__v2di)__X, 0, 1, 0, 1);
}
# 889 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx2intrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastb_epi8(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v16qi)__X, (__v16qi)__X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastw_epi16(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v8hi)__X, (__v8hi)__X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastd_epi32(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v4si)__X, (__v4si)__X, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastq_epi64(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v2di)__X, (__v2di)__X, 0, 0, 0, 0);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastb_epi8(__m128i __X)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__X, (__v16qi)__X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastw_epi16(__m128i __X)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__X, (__v8hi)__X, 0, 0, 0, 0, 0, 0, 0, 0);
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastd_epi32(__m128i __X)
{
  return (__m128i)__builtin_shufflevector((__v4si)__X, (__v4si)__X, 0, 0, 0, 0);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastq_epi64(__m128i __X)
{
  return (__m128i)__builtin_shufflevector((__v2di)__X, (__v2di)__X, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_permutevar8x32_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_permvarsi256((__v8si)__a, (__v8si)__b);
}
# 952 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx2intrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_permutevar8x32_ps(__m256 __a, __m256i __b)
{
  return (__m256)__builtin_ia32_permvarsf256((__v8sf)__a, (__v8si)__b);
}
# 983 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx2intrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_maskload_epi32(int const *__X, __m256i __M)
{
  return (__m256i)__builtin_ia32_maskloadd256((const __v8si *)__X, (__v8si)__M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_maskload_epi64(long long const *__X, __m256i __M)
{
  return (__m256i)__builtin_ia32_maskloadq256((const __v4di *)__X, (__v4di)__M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_maskload_epi32(int const *__X, __m128i __M)
{
  return (__m128i)__builtin_ia32_maskloadd((const __v4si *)__X, (__v4si)__M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_maskload_epi64(long long const *__X, __m128i __M)
{
  return (__m128i)__builtin_ia32_maskloadq((const __v2di *)__X, (__v2di)__M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_maskstore_epi32(int *__X, __m256i __M, __m256i __Y)
{
  __builtin_ia32_maskstored256((__v8si *)__X, (__v8si)__M, (__v8si)__Y);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_maskstore_epi64(long long *__X, __m256i __M, __m256i __Y)
{
  __builtin_ia32_maskstoreq256((__v4di *)__X, (__v4di)__M, (__v4di)__Y);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_maskstore_epi32(int *__X, __m128i __M, __m128i __Y)
{
  __builtin_ia32_maskstored((__v4si *)__X, (__v4si)__M, (__v4si)__Y);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_maskstore_epi64(long long *__X, __m128i __M, __m128i __Y)
{
  __builtin_ia32_maskstoreq(( __v2di *)__X, (__v2di)__M, (__v2di)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sllv_epi32(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psllv8si((__v8si)__X, (__v8si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_sllv_epi32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psllv4si((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sllv_epi64(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psllv4di((__v4di)__X, (__v4di)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_sllv_epi64(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psllv2di((__v2di)__X, (__v2di)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srav_epi32(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psrav8si((__v8si)__X, (__v8si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_srav_epi32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psrav4si((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srlv_epi32(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psrlv8si((__v8si)__X, (__v8si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_srlv_epi32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psrlv4si((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srlv_epi64(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psrlv4di((__v4di)__X, (__v4di)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_srlv_epi64(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psrlv2di((__v2di)__X, (__v2di)__Y);
}
# 67 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4
# 110 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("f16c")))
_mm256_cvtph_ps(__m128i __a)
{
  return (__m256)__builtin_ia32_vcvtph2ps256((__v8hi)__a);
}




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 1 3 4
# 62 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__))
__tzcnt_u16(unsigned short __X)
{
  return __X ? __builtin_ctzs(__X) : 16;
}
# 81 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__andn_u32(unsigned int __X, unsigned int __Y)
{
  return ~__X & __Y;
}
# 103 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__bextr_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_bextr_u32(__X, __Y);
}
# 127 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr_u32(unsigned int __X, unsigned int __Y, unsigned int __Z)
{
  return __builtin_ia32_bextr_u32 (__X, ((__Y & 0xff) | ((__Z & 0xff) << 8)));
}
# 144 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsi_u32(unsigned int __X)
{
  return __X & -__X;
}
# 161 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsmsk_u32(unsigned int __X)
{
  return __X ^ (__X - 1);
}
# 178 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsr_u32(unsigned int __X)
{
  return __X & (__X - 1);
}
# 194 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
__tzcnt_u32(unsigned int __X)
{
  return __X ? __builtin_ctz(__X) : 32;
}
# 210 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_tzcnt_32(unsigned int __X)
{
  return __X ? __builtin_ctz(__X) : 32;
}
# 242 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__andn_u64 (unsigned long long __X, unsigned long long __Y)
{
  return ~__X & __Y;
}
# 264 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__bextr_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_bextr_u64(__X, __Y);
}
# 288 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr_u64(unsigned long long __X, unsigned int __Y, unsigned int __Z)
{
  return __builtin_ia32_bextr_u64 (__X, ((__Y & 0xff) | ((__Z & 0xff) << 8)));
}
# 305 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsi_u64(unsigned long long __X)
{
  return __X & -__X;
}
# 322 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsmsk_u64(unsigned long long __X)
{
  return __X ^ (__X - 1);
}
# 339 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsr_u64(unsigned long long __X)
{
  return __X & (__X - 1);
}
# 355 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__tzcnt_u64(unsigned long long __X)
{
  return __X ? __builtin_ctzll(__X) : 64;
}
# 371 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmiintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_tzcnt_64(unsigned long long __X)
{
  return __X ? __builtin_ctzll(__X) : 64;
}
# 119 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmi2intrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/bmi2intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_bzhi_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_bzhi_si(__X, __Y);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pdep_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_pdep_si(__X, __Y);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pext_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_pext_si(__X, __Y);
}



static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_bzhi_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_bzhi_di(__X, __Y);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pdep_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_pdep_di(__X, __Y);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pext_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_pext_di(__X, __Y);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_mulx_u64 (unsigned long long __X, unsigned long long __Y,
    unsigned long long *__P)
{
  unsigned __int128 __res = (unsigned __int128) __X * __Y;
  *__P = (unsigned long long) (__res >> 64);
  return (unsigned long long) __res;
}
# 123 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/lzcntintrin.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/lzcntintrin.h" 3 4
static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
__lzcnt16(unsigned short __X)
{
  return __X ? __builtin_clzs(__X) : 16;
}
# 60 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/lzcntintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
__lzcnt32(unsigned int __X)
{
  return __X ? __builtin_clz(__X) : 32;
}
# 76 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/lzcntintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
_lzcnt_u32(unsigned int __X)
{
  return __X ? __builtin_clz(__X) : 32;
}
# 93 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/lzcntintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
__lzcnt64(unsigned long long __X)
{
  return __X ? __builtin_clzll(__X) : 64;
}
# 109 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/lzcntintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
_lzcnt_u64(unsigned long long __X)
{
  return __X ? __builtin_clzll(__X) : 64;
}
# 127 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/fmaintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/fmaintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmadd_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddps((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmadd_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddpd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmadd_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddss((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmadd_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmsubps((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmsubpd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsub_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmsubss((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsub_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmsubsd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmadd_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmaddps((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmadd_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmaddpd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmadd_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmaddss((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmadd_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmaddsd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmsub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmsubps((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmsub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmsubpd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmsub_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmsubss((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmsub_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmsubsd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmaddsub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddsubps((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmaddsub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsubpd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsubadd_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmsubaddps((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsubadd_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmsubaddpd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmadd_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddps256((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmadd_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddpd256((__v4df)__A, (__v4df)__B, (__v4df)__C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmsub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmsubps256((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmsub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmsubpd256((__v4df)__A, (__v4df)__B, (__v4df)__C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fnmadd_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfnmaddps256((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fnmadd_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfnmaddpd256((__v4df)__A, (__v4df)__B, (__v4df)__C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fnmsub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfnmsubps256((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fnmsub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfnmsubpd256((__v4df)__A, (__v4df)__B, (__v4df)__C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmaddsub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddsubps256((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmaddsub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddsubpd256((__v4df)__A, (__v4df)__B, (__v4df)__C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmsubadd_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmsubaddps256((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmsubadd_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmsubaddpd256((__v4df)__A, (__v4df)__B, (__v4df)__C);
}
# 131 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
typedef char __v64qi __attribute__((__vector_size__(64)));
typedef short __v32hi __attribute__((__vector_size__(64)));
typedef double __v8df __attribute__((__vector_size__(64)));
typedef float __v16sf __attribute__((__vector_size__(64)));
typedef long long __v8di __attribute__((__vector_size__(64)));
typedef int __v16si __attribute__((__vector_size__(64)));


typedef unsigned char __v64qu __attribute__((__vector_size__(64)));
typedef unsigned short __v32hu __attribute__((__vector_size__(64)));
typedef unsigned long long __v8du __attribute__((__vector_size__(64)));
typedef unsigned int __v16su __attribute__((__vector_size__(64)));

typedef float __m512 __attribute__((__vector_size__(64)));
typedef double __m512d __attribute__((__vector_size__(64)));
typedef long long __m512i __attribute__((__vector_size__(64)));

typedef unsigned char __mmask8;
typedef unsigned short __mmask16;
# 58 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
typedef enum {
    _MM_CMPINT_EQ,
    _MM_CMPINT_LT,
    _MM_CMPINT_LE,
    _MM_CMPINT_UNUSED,
    _MM_CMPINT_NE,
    _MM_CMPINT_NLT,

    _MM_CMPINT_NLE

} _MM_CMPINT_ENUM;

typedef enum
{
  _MM_PERM_AAAA = 0x00, _MM_PERM_AAAB = 0x01, _MM_PERM_AAAC = 0x02,
  _MM_PERM_AAAD = 0x03, _MM_PERM_AABA = 0x04, _MM_PERM_AABB = 0x05,
  _MM_PERM_AABC = 0x06, _MM_PERM_AABD = 0x07, _MM_PERM_AACA = 0x08,
  _MM_PERM_AACB = 0x09, _MM_PERM_AACC = 0x0A, _MM_PERM_AACD = 0x0B,
  _MM_PERM_AADA = 0x0C, _MM_PERM_AADB = 0x0D, _MM_PERM_AADC = 0x0E,
  _MM_PERM_AADD = 0x0F, _MM_PERM_ABAA = 0x10, _MM_PERM_ABAB = 0x11,
  _MM_PERM_ABAC = 0x12, _MM_PERM_ABAD = 0x13, _MM_PERM_ABBA = 0x14,
  _MM_PERM_ABBB = 0x15, _MM_PERM_ABBC = 0x16, _MM_PERM_ABBD = 0x17,
  _MM_PERM_ABCA = 0x18, _MM_PERM_ABCB = 0x19, _MM_PERM_ABCC = 0x1A,
  _MM_PERM_ABCD = 0x1B, _MM_PERM_ABDA = 0x1C, _MM_PERM_ABDB = 0x1D,
  _MM_PERM_ABDC = 0x1E, _MM_PERM_ABDD = 0x1F, _MM_PERM_ACAA = 0x20,
  _MM_PERM_ACAB = 0x21, _MM_PERM_ACAC = 0x22, _MM_PERM_ACAD = 0x23,
  _MM_PERM_ACBA = 0x24, _MM_PERM_ACBB = 0x25, _MM_PERM_ACBC = 0x26,
  _MM_PERM_ACBD = 0x27, _MM_PERM_ACCA = 0x28, _MM_PERM_ACCB = 0x29,
  _MM_PERM_ACCC = 0x2A, _MM_PERM_ACCD = 0x2B, _MM_PERM_ACDA = 0x2C,
  _MM_PERM_ACDB = 0x2D, _MM_PERM_ACDC = 0x2E, _MM_PERM_ACDD = 0x2F,
  _MM_PERM_ADAA = 0x30, _MM_PERM_ADAB = 0x31, _MM_PERM_ADAC = 0x32,
  _MM_PERM_ADAD = 0x33, _MM_PERM_ADBA = 0x34, _MM_PERM_ADBB = 0x35,
  _MM_PERM_ADBC = 0x36, _MM_PERM_ADBD = 0x37, _MM_PERM_ADCA = 0x38,
  _MM_PERM_ADCB = 0x39, _MM_PERM_ADCC = 0x3A, _MM_PERM_ADCD = 0x3B,
  _MM_PERM_ADDA = 0x3C, _MM_PERM_ADDB = 0x3D, _MM_PERM_ADDC = 0x3E,
  _MM_PERM_ADDD = 0x3F, _MM_PERM_BAAA = 0x40, _MM_PERM_BAAB = 0x41,
  _MM_PERM_BAAC = 0x42, _MM_PERM_BAAD = 0x43, _MM_PERM_BABA = 0x44,
  _MM_PERM_BABB = 0x45, _MM_PERM_BABC = 0x46, _MM_PERM_BABD = 0x47,
  _MM_PERM_BACA = 0x48, _MM_PERM_BACB = 0x49, _MM_PERM_BACC = 0x4A,
  _MM_PERM_BACD = 0x4B, _MM_PERM_BADA = 0x4C, _MM_PERM_BADB = 0x4D,
  _MM_PERM_BADC = 0x4E, _MM_PERM_BADD = 0x4F, _MM_PERM_BBAA = 0x50,
  _MM_PERM_BBAB = 0x51, _MM_PERM_BBAC = 0x52, _MM_PERM_BBAD = 0x53,
  _MM_PERM_BBBA = 0x54, _MM_PERM_BBBB = 0x55, _MM_PERM_BBBC = 0x56,
  _MM_PERM_BBBD = 0x57, _MM_PERM_BBCA = 0x58, _MM_PERM_BBCB = 0x59,
  _MM_PERM_BBCC = 0x5A, _MM_PERM_BBCD = 0x5B, _MM_PERM_BBDA = 0x5C,
  _MM_PERM_BBDB = 0x5D, _MM_PERM_BBDC = 0x5E, _MM_PERM_BBDD = 0x5F,
  _MM_PERM_BCAA = 0x60, _MM_PERM_BCAB = 0x61, _MM_PERM_BCAC = 0x62,
  _MM_PERM_BCAD = 0x63, _MM_PERM_BCBA = 0x64, _MM_PERM_BCBB = 0x65,
  _MM_PERM_BCBC = 0x66, _MM_PERM_BCBD = 0x67, _MM_PERM_BCCA = 0x68,
  _MM_PERM_BCCB = 0x69, _MM_PERM_BCCC = 0x6A, _MM_PERM_BCCD = 0x6B,
  _MM_PERM_BCDA = 0x6C, _MM_PERM_BCDB = 0x6D, _MM_PERM_BCDC = 0x6E,
  _MM_PERM_BCDD = 0x6F, _MM_PERM_BDAA = 0x70, _MM_PERM_BDAB = 0x71,
  _MM_PERM_BDAC = 0x72, _MM_PERM_BDAD = 0x73, _MM_PERM_BDBA = 0x74,
  _MM_PERM_BDBB = 0x75, _MM_PERM_BDBC = 0x76, _MM_PERM_BDBD = 0x77,
  _MM_PERM_BDCA = 0x78, _MM_PERM_BDCB = 0x79, _MM_PERM_BDCC = 0x7A,
  _MM_PERM_BDCD = 0x7B, _MM_PERM_BDDA = 0x7C, _MM_PERM_BDDB = 0x7D,
  _MM_PERM_BDDC = 0x7E, _MM_PERM_BDDD = 0x7F, _MM_PERM_CAAA = 0x80,
  _MM_PERM_CAAB = 0x81, _MM_PERM_CAAC = 0x82, _MM_PERM_CAAD = 0x83,
  _MM_PERM_CABA = 0x84, _MM_PERM_CABB = 0x85, _MM_PERM_CABC = 0x86,
  _MM_PERM_CABD = 0x87, _MM_PERM_CACA = 0x88, _MM_PERM_CACB = 0x89,
  _MM_PERM_CACC = 0x8A, _MM_PERM_CACD = 0x8B, _MM_PERM_CADA = 0x8C,
  _MM_PERM_CADB = 0x8D, _MM_PERM_CADC = 0x8E, _MM_PERM_CADD = 0x8F,
  _MM_PERM_CBAA = 0x90, _MM_PERM_CBAB = 0x91, _MM_PERM_CBAC = 0x92,
  _MM_PERM_CBAD = 0x93, _MM_PERM_CBBA = 0x94, _MM_PERM_CBBB = 0x95,
  _MM_PERM_CBBC = 0x96, _MM_PERM_CBBD = 0x97, _MM_PERM_CBCA = 0x98,
  _MM_PERM_CBCB = 0x99, _MM_PERM_CBCC = 0x9A, _MM_PERM_CBCD = 0x9B,
  _MM_PERM_CBDA = 0x9C, _MM_PERM_CBDB = 0x9D, _MM_PERM_CBDC = 0x9E,
  _MM_PERM_CBDD = 0x9F, _MM_PERM_CCAA = 0xA0, _MM_PERM_CCAB = 0xA1,
  _MM_PERM_CCAC = 0xA2, _MM_PERM_CCAD = 0xA3, _MM_PERM_CCBA = 0xA4,
  _MM_PERM_CCBB = 0xA5, _MM_PERM_CCBC = 0xA6, _MM_PERM_CCBD = 0xA7,
  _MM_PERM_CCCA = 0xA8, _MM_PERM_CCCB = 0xA9, _MM_PERM_CCCC = 0xAA,
  _MM_PERM_CCCD = 0xAB, _MM_PERM_CCDA = 0xAC, _MM_PERM_CCDB = 0xAD,
  _MM_PERM_CCDC = 0xAE, _MM_PERM_CCDD = 0xAF, _MM_PERM_CDAA = 0xB0,
  _MM_PERM_CDAB = 0xB1, _MM_PERM_CDAC = 0xB2, _MM_PERM_CDAD = 0xB3,
  _MM_PERM_CDBA = 0xB4, _MM_PERM_CDBB = 0xB5, _MM_PERM_CDBC = 0xB6,
  _MM_PERM_CDBD = 0xB7, _MM_PERM_CDCA = 0xB8, _MM_PERM_CDCB = 0xB9,
  _MM_PERM_CDCC = 0xBA, _MM_PERM_CDCD = 0xBB, _MM_PERM_CDDA = 0xBC,
  _MM_PERM_CDDB = 0xBD, _MM_PERM_CDDC = 0xBE, _MM_PERM_CDDD = 0xBF,
  _MM_PERM_DAAA = 0xC0, _MM_PERM_DAAB = 0xC1, _MM_PERM_DAAC = 0xC2,
  _MM_PERM_DAAD = 0xC3, _MM_PERM_DABA = 0xC4, _MM_PERM_DABB = 0xC5,
  _MM_PERM_DABC = 0xC6, _MM_PERM_DABD = 0xC7, _MM_PERM_DACA = 0xC8,
  _MM_PERM_DACB = 0xC9, _MM_PERM_DACC = 0xCA, _MM_PERM_DACD = 0xCB,
  _MM_PERM_DADA = 0xCC, _MM_PERM_DADB = 0xCD, _MM_PERM_DADC = 0xCE,
  _MM_PERM_DADD = 0xCF, _MM_PERM_DBAA = 0xD0, _MM_PERM_DBAB = 0xD1,
  _MM_PERM_DBAC = 0xD2, _MM_PERM_DBAD = 0xD3, _MM_PERM_DBBA = 0xD4,
  _MM_PERM_DBBB = 0xD5, _MM_PERM_DBBC = 0xD6, _MM_PERM_DBBD = 0xD7,
  _MM_PERM_DBCA = 0xD8, _MM_PERM_DBCB = 0xD9, _MM_PERM_DBCC = 0xDA,
  _MM_PERM_DBCD = 0xDB, _MM_PERM_DBDA = 0xDC, _MM_PERM_DBDB = 0xDD,
  _MM_PERM_DBDC = 0xDE, _MM_PERM_DBDD = 0xDF, _MM_PERM_DCAA = 0xE0,
  _MM_PERM_DCAB = 0xE1, _MM_PERM_DCAC = 0xE2, _MM_PERM_DCAD = 0xE3,
  _MM_PERM_DCBA = 0xE4, _MM_PERM_DCBB = 0xE5, _MM_PERM_DCBC = 0xE6,
  _MM_PERM_DCBD = 0xE7, _MM_PERM_DCCA = 0xE8, _MM_PERM_DCCB = 0xE9,
  _MM_PERM_DCCC = 0xEA, _MM_PERM_DCCD = 0xEB, _MM_PERM_DCDA = 0xEC,
  _MM_PERM_DCDB = 0xED, _MM_PERM_DCDC = 0xEE, _MM_PERM_DCDD = 0xEF,
  _MM_PERM_DDAA = 0xF0, _MM_PERM_DDAB = 0xF1, _MM_PERM_DDAC = 0xF2,
  _MM_PERM_DDAD = 0xF3, _MM_PERM_DDBA = 0xF4, _MM_PERM_DDBB = 0xF5,
  _MM_PERM_DDBC = 0xF6, _MM_PERM_DDBD = 0xF7, _MM_PERM_DDCA = 0xF8,
  _MM_PERM_DDCB = 0xF9, _MM_PERM_DDCC = 0xFA, _MM_PERM_DDCD = 0xFB,
  _MM_PERM_DDDA = 0xFC, _MM_PERM_DDDB = 0xFD, _MM_PERM_DDDC = 0xFE,
  _MM_PERM_DDDD = 0xFF
} _MM_PERM_ENUM;

typedef enum
{
  _MM_MANT_NORM_1_2,
  _MM_MANT_NORM_p5_2,
  _MM_MANT_NORM_p5_1,
  _MM_MANT_NORM_p75_1p5
} _MM_MANTISSA_NORM_ENUM;

typedef enum
{
  _MM_MANT_SIGN_src,
  _MM_MANT_SIGN_zero,
  _MM_MANT_SIGN_nan
} _MM_MANTISSA_SIGN_ENUM;






static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_setzero_si512(void)
{
  return (__m512i)(__v8di){ 0, 0, 0, 0, 0, 0, 0, 0 };
}



static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_undefined_pd(void)
{
  return (__m512d)__builtin_ia32_undef512();
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_undefined(void)
{
  return (__m512)__builtin_ia32_undef512();
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_undefined_ps(void)
{
  return (__m512)__builtin_ia32_undef512();
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_undefined_epi32(void)
{
  return (__m512i)__builtin_ia32_undef512();
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_broadcastd_epi32 (__m128i __A)
{
  return (__m512i)__builtin_shufflevector((__v4si) __A,
                                          (__v4si)_mm_undefined_si128(),
                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_broadcastd_epi32 (__m512i __O, __mmask16 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectd_512(__M,
                                             (__v16si) _mm512_broadcastd_epi32(__A),
                                             (__v16si) __O);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_broadcastd_epi32 (__mmask16 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectd_512(__M,
                                             (__v16si) _mm512_broadcastd_epi32(__A),
                                             (__v16si) _mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_broadcastq_epi64 (__m128i __A)
{
  return (__m512i)__builtin_shufflevector((__v2di) __A,
                                          (__v2di) _mm_undefined_si128(),
                                          0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_broadcastq_epi64 (__m512i __O, __mmask8 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512(__M,
                                             (__v8di) _mm512_broadcastq_epi64(__A),
                                             (__v8di) __O);

}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_broadcastq_epi64 (__mmask8 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512(__M,
                                             (__v8di) _mm512_broadcastq_epi64(__A),
                                             (__v8di) _mm512_setzero_si512());
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_set1_epi32(__mmask16 __M, int __A)
{
  return (__m512i) __builtin_ia32_pbroadcastd512_gpr_mask (__A,
                 (__v16si)
                 _mm512_setzero_si512 (),
                 __M);
}


static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_set1_epi64(__mmask8 __M, long long __A)
{
  return (__m512i) __builtin_ia32_pbroadcastq512_gpr_mask (__A,
                 (__v8di)
                 _mm512_setzero_si512 (),
                 __M);
}


static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_setzero_ps(void)
{
  return (__m512){ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
}



static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_setzero_pd(void)
{
  return (__m512d){ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set1_ps(float __w)
{
  return (__m512){ __w, __w, __w, __w, __w, __w, __w, __w,
                   __w, __w, __w, __w, __w, __w, __w, __w };
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set1_pd(double __w)
{
  return (__m512d){ __w, __w, __w, __w, __w, __w, __w, __w };
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set1_epi8(char __w)
{
  return (__m512i)(__v64qi){ __w, __w, __w, __w, __w, __w, __w, __w,
                             __w, __w, __w, __w, __w, __w, __w, __w,
                             __w, __w, __w, __w, __w, __w, __w, __w,
                             __w, __w, __w, __w, __w, __w, __w, __w,
                             __w, __w, __w, __w, __w, __w, __w, __w,
                             __w, __w, __w, __w, __w, __w, __w, __w,
                             __w, __w, __w, __w, __w, __w, __w, __w,
                             __w, __w, __w, __w, __w, __w, __w, __w };
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set1_epi16(short __w)
{
  return (__m512i)(__v32hi){ __w, __w, __w, __w, __w, __w, __w, __w,
                             __w, __w, __w, __w, __w, __w, __w, __w,
                             __w, __w, __w, __w, __w, __w, __w, __w,
                             __w, __w, __w, __w, __w, __w, __w, __w };
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set1_epi32(int __s)
{
  return (__m512i)(__v16si){ __s, __s, __s, __s, __s, __s, __s, __s,
                             __s, __s, __s, __s, __s, __s, __s, __s };
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set1_epi64(long long __d)
{
  return (__m512i)(__v8di){ __d, __d, __d, __d, __d, __d, __d, __d };
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_broadcastss_ps(__m128 __A)
{
  return (__m512)__builtin_shufflevector((__v4sf) __A,
                                         (__v4sf)_mm_undefined_ps(),
                                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set4_epi32 (int __A, int __B, int __C, int __D)
{
  return (__m512i)(__v16si)
   { __D, __C, __B, __A, __D, __C, __B, __A,
     __D, __C, __B, __A, __D, __C, __B, __A };
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set4_epi64 (long long __A, long long __B, long long __C,
       long long __D)
{
  return (__m512i) (__v8di)
   { __D, __C, __B, __A, __D, __C, __B, __A };
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set4_pd (double __A, double __B, double __C, double __D)
{
  return (__m512d)
   { __D, __C, __B, __A, __D, __C, __B, __A };
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set4_ps (float __A, float __B, float __C, float __D)
{
  return (__m512)
   { __D, __C, __B, __A, __D, __C, __B, __A,
     __D, __C, __B, __A, __D, __C, __B, __A };
}
# 395 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_broadcastsd_pd(__m128d __A)
{
  return (__m512d)__builtin_shufflevector((__v2df) __A,
                                          (__v2df) _mm_undefined_pd(),
                                          0, 0, 0, 0, 0, 0, 0, 0);
}



static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castpd256_pd512(__m256d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1, 2, 3, -1, -1, -1, -1);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castps256_ps512(__m256 __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1, 2, 3, 4, 5, 6, 7,
                                          -1, -1, -1, -1, -1, -1, -1, -1);
}

static inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castpd512_pd128(__m512d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1);
}

static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castpd512_pd256 (__m512d __A)
{
  return __builtin_shufflevector(__A, __A, 0, 1, 2, 3);
}

static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castps512_ps128(__m512 __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1, 2, 3);
}

static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castps512_ps256 (__m512 __A)
{
  return __builtin_shufflevector(__A, __A, 0, 1, 2, 3, 4, 5, 6, 7);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castpd_ps (__m512d __A)
{
  return (__m512) (__A);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castpd_si512 (__m512d __A)
{
  return (__m512i) (__A);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castpd128_pd512 (__m128d __A)
{
  return __builtin_shufflevector( __A, __A, 0, 1, -1, -1, -1, -1, -1, -1);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castps_pd (__m512 __A)
{
  return (__m512d) (__A);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castps_si512 (__m512 __A)
{
  return (__m512i) (__A);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castps128_ps512 (__m128 __A)
{
    return __builtin_shufflevector( __A, __A, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castsi128_si512 (__m128i __A)
{
   return __builtin_shufflevector( __A, __A, 0, 1, -1, -1, -1, -1, -1, -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castsi256_si512 (__m256i __A)
{
   return __builtin_shufflevector( __A, __A, 0, 1, 2, 3, -1, -1, -1, -1);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castsi512_ps (__m512i __A)
{
  return (__m512) (__A);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castsi512_pd (__m512i __A)
{
  return (__m512d) (__A);
}

static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castsi512_si128 (__m512i __A)
{
  return (__m128i)__builtin_shufflevector(__A, __A , 0, 1);
}

static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castsi512_si256 (__m512i __A)
{
  return (__m256i)__builtin_shufflevector(__A, __A , 0, 1, 2, 3);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_int2mask(int __a)
{
  return (__mmask16)__a;
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask2int(__mmask16 __a)
{
  return (int)__a;
}
# 539 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_zextpd128_pd512(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)_mm_setzero_pd(), 0, 1, 2, 3, 2, 3, 2, 3);
}
# 558 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_zextpd256_pd512(__m256d __a)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)_mm256_setzero_pd(), 0, 1, 2, 3, 4, 5, 6, 7);
}
# 576 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_zextps128_ps512(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)_mm_setzero_ps(), 0, 1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7);
}
# 594 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_zextps256_ps512(__m256 __a)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)_mm256_setzero_ps(), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
}
# 612 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_zextsi128_si512(__m128i __a)
{
  return __builtin_shufflevector((__v2di)__a, (__v2di)_mm_setzero_si128(), 0, 1, 2, 3, 2, 3, 2, 3);
}
# 630 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_zextsi256_si512(__m256i __a)
{
  return __builtin_shufflevector((__v4di)__a, (__v4di)_mm256_setzero_si256(), 0, 1, 2, 3, 4, 5, 6, 7);
}


static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_and_epi32(__m512i __a, __m512i __b)
{
  return (__m512i)((__v16su)__a & (__v16su)__b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_and_epi32(__m512i __src, __mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__k,
                (__v16si) _mm512_and_epi32(__a, __b),
                (__v16si) __src);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_and_epi32(__mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i) _mm512_mask_and_epi32(_mm512_setzero_si512 (),
                                         __k, __a, __b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_and_epi64(__m512i __a, __m512i __b)
{
  return (__m512i)((__v8du)__a & (__v8du)__b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_and_epi64(__m512i __src, __mmask8 __k, __m512i __a, __m512i __b)
{
    return (__m512i) __builtin_ia32_selectq_512 ((__mmask8) __k,
                (__v8di) _mm512_and_epi64(__a, __b),
                (__v8di) __src);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_and_epi64(__mmask8 __k, __m512i __a, __m512i __b)
{
  return (__m512i) _mm512_mask_and_epi64(_mm512_setzero_si512 (),
                                         __k, __a, __b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_andnot_si512 (__m512i __A, __m512i __B)
{
  return (__m512i)(~(__v8du)(__A) & (__v8du)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_andnot_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i)(~(__v16su)(__A) & (__v16su)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_andnot_epi32(__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                         (__v16si)_mm512_andnot_epi32(__A, __B),
                                         (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_andnot_epi32(__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i)_mm512_mask_andnot_epi32(_mm512_setzero_si512(),
                                           __U, __A, __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_andnot_epi64(__m512i __A, __m512i __B)
{
  return (__m512i)(~(__v8du)(__A) & (__v8du)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_andnot_epi64(__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                          (__v8di)_mm512_andnot_epi64(__A, __B),
                                          (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_andnot_epi64(__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i)_mm512_mask_andnot_epi64(_mm512_setzero_si512(),
                                           __U, __A, __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_or_epi32(__m512i __a, __m512i __b)
{
  return (__m512i)((__v16su)__a | (__v16su)__b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_or_epi32(__m512i __src, __mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__k,
                                             (__v16si)_mm512_or_epi32(__a, __b),
                                             (__v16si)__src);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_or_epi32(__mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i)_mm512_mask_or_epi32(_mm512_setzero_si512(), __k, __a, __b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_or_epi64(__m512i __a, __m512i __b)
{
  return (__m512i)((__v8du)__a | (__v8du)__b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_or_epi64(__m512i __src, __mmask8 __k, __m512i __a, __m512i __b)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__k,
                                             (__v8di)_mm512_or_epi64(__a, __b),
                                             (__v8di)__src);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_or_epi64(__mmask8 __k, __m512i __a, __m512i __b)
{
  return (__m512i)_mm512_mask_or_epi64(_mm512_setzero_si512(), __k, __a, __b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_xor_epi32(__m512i __a, __m512i __b)
{
  return (__m512i)((__v16su)__a ^ (__v16su)__b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_xor_epi32(__m512i __src, __mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__k,
                                            (__v16si)_mm512_xor_epi32(__a, __b),
                                            (__v16si)__src);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_xor_epi32(__mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i)_mm512_mask_xor_epi32(_mm512_setzero_si512(), __k, __a, __b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_xor_epi64(__m512i __a, __m512i __b)
{
  return (__m512i)((__v8du)__a ^ (__v8du)__b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_xor_epi64(__m512i __src, __mmask8 __k, __m512i __a, __m512i __b)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__k,
                                             (__v8di)_mm512_xor_epi64(__a, __b),
                                             (__v8di)__src);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_xor_epi64(__mmask8 __k, __m512i __a, __m512i __b)
{
  return (__m512i)_mm512_mask_xor_epi64(_mm512_setzero_si512(), __k, __a, __b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_and_si512(__m512i __a, __m512i __b)
{
  return (__m512i)((__v8du)__a & (__v8du)__b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_or_si512(__m512i __a, __m512i __b)
{
  return (__m512i)((__v8du)__a | (__v8du)__b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_xor_si512(__m512i __a, __m512i __b)
{
  return (__m512i)((__v8du)__a ^ (__v8du)__b);
}



static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_add_pd(__m512d __a, __m512d __b)
{
  return (__m512d)((__v8df)__a + (__v8df)__b);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_add_ps(__m512 __a, __m512 __b)
{
  return (__m512)((__v16sf)__a + (__v16sf)__b);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mul_pd(__m512d __a, __m512d __b)
{
  return (__m512d)((__v8df)__a * (__v8df)__b);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mul_ps(__m512 __a, __m512 __b)
{
  return (__m512)((__v16sf)__a * (__v16sf)__b);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sub_pd(__m512d __a, __m512d __b)
{
  return (__m512d)((__v8df)__a - (__v8df)__b);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sub_ps(__m512 __a, __m512 __b)
{
  return (__m512)((__v16sf)__a - (__v16sf)__b);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_add_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v8du) __A + (__v8du) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_add_epi64(__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_add_epi64(__A, __B),
                                             (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_add_epi64(__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_add_epi64(__A, __B),
                                             (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sub_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v8du) __A - (__v8du) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sub_epi64(__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_sub_epi64(__A, __B),
                                             (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sub_epi64(__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_sub_epi64(__A, __B),
                                             (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_add_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A + (__v16su) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_add_epi32(__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                             (__v16si)_mm512_add_epi32(__A, __B),
                                             (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_add_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                             (__v16si)_mm512_add_epi32(__A, __B),
                                             (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sub_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A - (__v16su) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sub_epi32(__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                             (__v16si)_mm512_sub_epi32(__A, __B),
                                             (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sub_epi32(__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                             (__v16si)_mm512_sub_epi32(__A, __B),
                                             (__v16si)_mm512_setzero_si512());
}
# 969 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_pd(__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_maxpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df)
             _mm512_setzero_pd (),
             (__mmask8) -1,
             0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_max_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_maxpd512_mask ((__v8df) __A,
                  (__v8df) __B,
                  (__v8df) __W,
                  (__mmask8) __U,
                  0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_max_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_maxpd512_mask ((__v8df) __A,
                  (__v8df) __B,
                  (__v8df)
                  _mm512_setzero_pd (),
                  (__mmask8) __U,
                  0x04);
}
# 1019 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_ps(__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_maxps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf)
            _mm512_setzero_ps (),
            (__mmask16) -1,
            0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_max_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_maxps512_mask ((__v16sf) __A,
                 (__v16sf) __B,
                 (__v16sf) __W,
                 (__mmask16) __U,
                 0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_max_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_maxps512_mask ((__v16sf) __A,
                 (__v16sf) __B,
                 (__v16sf)
                 _mm512_setzero_ps (),
                 (__mmask16) __U,
                 0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_max_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_maxss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_max_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_maxss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
# 1087 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_max_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_maxsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_max_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_maxsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
# 1123 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512i
__attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_epi32(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_max_epi32 (__m512i __W, __mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsd512_mask ((__v16si) __A,
                   (__v16si) __B,
                   (__v16si) __W, __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_max_epi32 (__mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsd512_mask ((__v16si) __A,
                   (__v16si) __B,
                   (__v16si)
                   _mm512_setzero_si512 (),
                   __M);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_epu32(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxud512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_max_epu32 (__m512i __W, __mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxud512_mask ((__v16si) __A,
                   (__v16si) __B,
                   (__v16si) __W, __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_max_epu32 (__mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxud512_mask ((__v16si) __A,
                   (__v16si) __B,
                   (__v16si)
                   _mm512_setzero_si512 (),
                   __M);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_epi64(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_max_epi64 (__m512i __W, __mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsq512_mask ((__v8di) __A,
                   (__v8di) __B,
                   (__v8di) __W, __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_max_epi64 (__mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsq512_mask ((__v8di) __A,
                   (__v8di) __B,
                   (__v8di)
                   _mm512_setzero_si512 (),
                   __M);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_epu64(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_max_epu64 (__m512i __W, __mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuq512_mask ((__v8di) __A,
                   (__v8di) __B,
                   (__v8di) __W, __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_max_epu64 (__mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuq512_mask ((__v8di) __A,
                   (__v8di) __B,
                   (__v8di)
                   _mm512_setzero_si512 (),
                   __M);
}
# 1254 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_pd(__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_minpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df)
             _mm512_setzero_pd (),
             (__mmask8) -1,
             0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_min_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_minpd512_mask ((__v8df) __A,
                  (__v8df) __B,
                  (__v8df) __W,
                  (__mmask8) __U,
                  0x04);
}
# 1293 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_min_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_minpd512_mask ((__v8df) __A,
                  (__v8df) __B,
                  (__v8df)
                  _mm512_setzero_pd (),
                  (__mmask8) __U,
                  0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_ps(__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_minps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf)
            _mm512_setzero_ps (),
            (__mmask16) -1,
            0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_min_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_minps512_mask ((__v16sf) __A,
                 (__v16sf) __B,
                 (__v16sf) __W,
                 (__mmask16) __U,
                 0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_min_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_minps512_mask ((__v16sf) __A,
                 (__v16sf) __B,
                 (__v16sf)
                 _mm512_setzero_ps (),
                 (__mmask16) __U,
                 0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_min_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_minss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_min_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_minss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
# 1372 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_min_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_minsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_min_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_minsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
# 1408 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512i
__attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_epi32(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_min_epi32 (__m512i __W, __mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsd512_mask ((__v16si) __A,
                   (__v16si) __B,
                   (__v16si) __W, __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_min_epi32 (__mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsd512_mask ((__v16si) __A,
                   (__v16si) __B,
                   (__v16si)
                   _mm512_setzero_si512 (),
                   __M);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_epu32(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminud512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_min_epu32 (__m512i __W, __mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminud512_mask ((__v16si) __A,
                   (__v16si) __B,
                   (__v16si) __W, __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_min_epu32 (__mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminud512_mask ((__v16si) __A,
                   (__v16si) __B,
                   (__v16si)
                   _mm512_setzero_si512 (),
                   __M);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_epi64(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_min_epi64 (__m512i __W, __mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsq512_mask ((__v8di) __A,
                   (__v8di) __B,
                   (__v8di) __W, __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_min_epi64 (__mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsq512_mask ((__v8di) __A,
                   (__v8di) __B,
                   (__v8di)
                   _mm512_setzero_si512 (),
                   __M);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_epu64(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_min_epu64 (__m512i __W, __mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuq512_mask ((__v8di) __A,
                   (__v8di) __B,
                   (__v8di) __W, __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_min_epu64 (__mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuq512_mask ((__v8di) __A,
                   (__v8di) __B,
                   (__v8di)
                   _mm512_setzero_si512 (),
                   __M);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mul_epi32(__m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_pmuldq512((__v16si)__X, (__v16si) __Y);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mul_epi32(__m512i __W, __mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__M,
                                             (__v8di)_mm512_mul_epi32(__X, __Y),
                                             (__v8di)__W);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mul_epi32(__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__M,
                                             (__v8di)_mm512_mul_epi32(__X, __Y),
                                             (__v8di)_mm512_setzero_si512 ());
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mul_epu32(__m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_pmuludq512((__v16si)__X, (__v16si)__Y);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mul_epu32(__m512i __W, __mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__M,
                                             (__v8di)_mm512_mul_epu32(__X, __Y),
                                             (__v8di)__W);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mul_epu32(__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__M,
                                             (__v8di)_mm512_mul_epu32(__X, __Y),
                                             (__v8di)_mm512_setzero_si512 ());
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mullo_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A * (__v16su) __B);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mullo_epi32(__mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__M,
                                             (__v16si)_mm512_mullo_epi32(__A, __B),
                                             (__v16si)_mm512_setzero_si512());
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mullo_epi32(__m512i __W, __mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__M,
                                             (__v16si)_mm512_mullo_epi32(__A, __B),
                                             (__v16si)__W);
}
# 1602 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sqrt_pd(__m512d __a)
{
  return (__m512d)__builtin_ia32_sqrtpd512_mask((__v8df)__a,
                                                (__v8df) _mm512_setzero_pd (),
                                                (__mmask8) -1,
                                                0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sqrt_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_sqrtpd512_mask ((__v8df) __A,
                   (__v8df) __W,
                   (__mmask8) __U,
                   0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sqrt_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_sqrtpd512_mask ((__v8df) __A,
                   (__v8df)
                   _mm512_setzero_pd (),
                   (__mmask8) __U,
                   0x04);
}
# 1645 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sqrt_ps(__m512 __a)
{
  return (__m512)__builtin_ia32_sqrtps512_mask((__v16sf)__a,
                                               (__v16sf) _mm512_setzero_ps (),
                                               (__mmask16) -1,
                                               0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sqrt_ps(__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512)__builtin_ia32_sqrtps512_mask((__v16sf)__A,
                                               (__v16sf) __W,
                                               (__mmask16) __U,
                                               0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sqrt_ps( __mmask16 __U, __m512 __A)
{
  return (__m512)__builtin_ia32_sqrtps512_mask((__v16sf)__A,
                                               (__v16sf) _mm512_setzero_ps (),
                                               (__mmask16) __U,
                                               0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rsqrt14_pd(__m512d __A)
{
  return (__m512d) __builtin_ia32_rsqrt14pd512_mask ((__v8df) __A,
                 (__v8df)
                 _mm512_setzero_pd (),
                 (__mmask8) -1);}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_rsqrt14_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rsqrt14pd512_mask ((__v8df) __A,
                  (__v8df) __W,
                  (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_rsqrt14_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rsqrt14pd512_mask ((__v8df) __A,
                  (__v8df)
                  _mm512_setzero_pd (),
                  (__mmask8) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rsqrt14_ps(__m512 __A)
{
  return (__m512) __builtin_ia32_rsqrt14ps512_mask ((__v16sf) __A,
                (__v16sf)
                _mm512_setzero_ps (),
                (__mmask16) -1);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_rsqrt14_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rsqrt14ps512_mask ((__v16sf) __A,
                 (__v16sf) __W,
                 (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_rsqrt14_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rsqrt14ps512_mask ((__v16sf) __A,
                 (__v16sf)
                 _mm512_setzero_ps (),
                 (__mmask16) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_rsqrt14_ss(__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_rsqrt14ss_mask ((__v4sf) __A,
             (__v4sf) __B,
             (__v4sf)
             _mm_setzero_ps (),
             (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_rsqrt14_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_rsqrt14ss_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __W,
          (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_rsqrt14_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_rsqrt14ss_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) _mm_setzero_ps (),
          (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_rsqrt14_sd(__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_rsqrt14sd_mask ((__v2df) __A,
              (__v2df) __B,
              (__v2df)
              _mm_setzero_pd (),
              (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_rsqrt14_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_rsqrt14sd_mask ( (__v2df) __A,
          (__v2df) __B,
          (__v2df) __W,
          (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_rsqrt14_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_rsqrt14sd_mask ( (__v2df) __A,
          (__v2df) __B,
          (__v2df) _mm_setzero_pd (),
          (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rcp14_pd(__m512d __A)
{
  return (__m512d) __builtin_ia32_rcp14pd512_mask ((__v8df) __A,
               (__v8df)
               _mm512_setzero_pd (),
               (__mmask8) -1);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_rcp14_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rcp14pd512_mask ((__v8df) __A,
                (__v8df) __W,
                (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_rcp14_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rcp14pd512_mask ((__v8df) __A,
                (__v8df)
                _mm512_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rcp14_ps(__m512 __A)
{
  return (__m512) __builtin_ia32_rcp14ps512_mask ((__v16sf) __A,
              (__v16sf)
              _mm512_setzero_ps (),
              (__mmask16) -1);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_rcp14_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rcp14ps512_mask ((__v16sf) __A,
                   (__v16sf) __W,
                   (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_rcp14_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rcp14ps512_mask ((__v16sf) __A,
                   (__v16sf)
                   _mm512_setzero_ps (),
                   (__mmask16) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_rcp14_ss(__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_rcp14ss_mask ((__v4sf) __A,
                 (__v4sf) __B,
                 (__v4sf)
                 _mm_setzero_ps (),
                 (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_rcp14_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_rcp14ss_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __W,
          (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_rcp14_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_rcp14ss_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) _mm_setzero_ps (),
          (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_rcp14_sd(__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_rcp14sd_mask ((__v2df) __A,
            (__v2df) __B,
            (__v2df)
            _mm_setzero_pd (),
            (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_rcp14_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_rcp14sd_mask ( (__v2df) __A,
          (__v2df) __B,
          (__v2df) __W,
          (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_rcp14_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_rcp14sd_mask ( (__v2df) __A,
          (__v2df) __B,
          (__v2df) _mm_setzero_pd (),
          (__mmask8) __U);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_floor_ps(__m512 __A)
{
  return (__m512) __builtin_ia32_rndscaleps_mask ((__v16sf) __A,
                                                  (0x00 | 0x01),
                                                  (__v16sf) __A, -1,
                                                  0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_floor_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rndscaleps_mask ((__v16sf) __A,
                   (0x00 | 0x01),
                   (__v16sf) __W, __U,
                   0x04);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_floor_pd(__m512d __A)
{
  return (__m512d) __builtin_ia32_rndscalepd_mask ((__v8df) __A,
                                                   (0x00 | 0x01),
                                                   (__v8df) __A, -1,
                                                   0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_floor_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rndscalepd_mask ((__v8df) __A,
                (0x00 | 0x01),
                (__v8df) __W, __U,
                0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_ceil_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rndscaleps_mask ((__v16sf) __A,
                   (0x00 | 0x02),
                   (__v16sf) __W, __U,
                   0x04);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_ceil_ps(__m512 __A)
{
  return (__m512) __builtin_ia32_rndscaleps_mask ((__v16sf) __A,
                                                  (0x00 | 0x02),
                                                  (__v16sf) __A, -1,
                                                  0x04);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_ceil_pd(__m512d __A)
{
  return (__m512d) __builtin_ia32_rndscalepd_mask ((__v8df) __A,
                                                   (0x00 | 0x02),
                                                   (__v8df) __A, -1,
                                                   0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_ceil_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rndscalepd_mask ((__v8df) __A,
                (0x00 | 0x02),
                (__v8df) __W, __U,
                0x04);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_abs_epi64(__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsq512_mask ((__v8di) __A,
             (__v8di)
             _mm512_setzero_si512 (),
             (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_abs_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsq512_mask ((__v8di) __A,
                  (__v8di) __W,
                  (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_abs_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsq512_mask ((__v8di) __A,
                  (__v8di)
                  _mm512_setzero_si512 (),
                  (__mmask8) __U);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_abs_epi32(__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsd512_mask ((__v16si) __A,
             (__v16si)
             _mm512_setzero_si512 (),
             (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_abs_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsd512_mask ((__v16si) __A,
                  (__v16si) __W,
                  (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_abs_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsd512_mask ((__v16si) __A,
                  (__v16si)
                  _mm512_setzero_si512 (),
                  (__mmask16) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_add_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_addss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_add_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_addss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
# 2047 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_add_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_addsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_add_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_addsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
# 2082 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_add_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_add_pd(__A, __B),
                                              (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_add_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_add_pd(__A, __B),
                                              (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_add_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_add_ps(__A, __B),
                                             (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_add_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_add_ps(__A, __B),
                                             (__v16sf)_mm512_setzero_ps());
}
# 2146 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_sub_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_subss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_sub_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_subss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
# 2181 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_sub_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_subsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_sub_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_subsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
# 2217 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sub_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_sub_pd(__A, __B),
                                              (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sub_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_sub_pd(__A, __B),
                                              (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sub_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_sub_ps(__A, __B),
                                             (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sub_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_sub_ps(__A, __B),
                                             (__v16sf)_mm512_setzero_ps());
}
# 2281 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_mul_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_mulss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_mul_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_mulss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
# 2316 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_mul_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_mulsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_mul_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_mulsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
# 2352 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mul_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_mul_pd(__A, __B),
                                              (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mul_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_mul_pd(__A, __B),
                                              (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mul_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_mul_ps(__A, __B),
                                             (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mul_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_mul_ps(__A, __B),
                                             (__v16sf)_mm512_setzero_ps());
}
# 2416 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_div_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_divss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_div_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_divss_round_mask ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
# 2452 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_div_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_divsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_div_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_divsd_round_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
# 2488 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_div_pd(__m512d __a, __m512d __b)
{
  return (__m512d)((__v8df)__a/(__v8df)__b);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_div_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_div_pd(__A, __B),
                                              (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_div_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_div_pd(__A, __B),
                                              (__v8df)_mm512_setzero_pd());
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_div_ps(__m512 __a, __m512 __b)
{
  return (__m512)((__v16sf)__a/(__v16sf)__b);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_div_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_div_ps(__A, __B),
                                             (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_div_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_div_ps(__A, __B),
                                             (__v16sf)_mm512_setzero_ps());
}
# 2710 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmadd_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask ((__v8df) __A,
                                                    (__v8df) __B,
                                                    (__v8df) __C,
                                                    (__mmask8) -1,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmadd_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask ((__v8df) __A,
                                                    (__v8df) __B,
                                                    (__v8df) __C,
                                                    (__mmask8) __U,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmadd_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask3 ((__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmadd_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_maskz ((__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmsub_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask ((__v8df) __A,
                                                    (__v8df) __B,
                                                    -(__v8df) __C,
                                                    (__mmask8) -1,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmsub_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask ((__v8df) __A,
                                                    (__v8df) __B,
                                                    -(__v8df) __C,
                                                    (__mmask8) __U,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmsub_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_maskz ((__v8df) __A,
                                                     (__v8df) __B,
                                                     -(__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fnmadd_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask (-(__v8df) __A,
                                                    (__v8df) __B,
                                                    (__v8df) __C,
                                                    (__mmask8) -1,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fnmadd_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask3 (-(__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fnmadd_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_maskz (-(__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fnmsub_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask (-(__v8df) __A,
                                                    (__v8df) __B,
                                                    -(__v8df) __C,
                                                    (__mmask8) -1,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fnmsub_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_maskz (-(__v8df) __A,
                                                     (__v8df) __B,
                                                     -(__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}
# 2914 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmadd_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask ((__v16sf) __A,
                                                   (__v16sf) __B,
                                                   (__v16sf) __C,
                                                   (__mmask16) -1,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmadd_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask ((__v16sf) __A,
                                                   (__v16sf) __B,
                                                   (__v16sf) __C,
                                                   (__mmask16) __U,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmadd_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask3 ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmadd_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_maskz ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmsub_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask ((__v16sf) __A,
                                                   (__v16sf) __B,
                                                   -(__v16sf) __C,
                                                   (__mmask16) -1,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmsub_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask ((__v16sf) __A,
                                                   (__v16sf) __B,
                                                   -(__v16sf) __C,
                                                   (__mmask16) __U,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmsub_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_maskz ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    -(__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fnmadd_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask (-(__v16sf) __A,
                                                   (__v16sf) __B,
                                                   (__v16sf) __C,
                                                   (__mmask16) -1,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fnmadd_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask3 (-(__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fnmadd_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_maskz (-(__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fnmsub_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask (-(__v16sf) __A,
                                                   (__v16sf) __B,
                                                   -(__v16sf) __C,
                                                   (__mmask16) -1,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fnmsub_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_maskz (-(__v16sf) __A,
                                                    (__v16sf) __B,
                                                    -(__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}
# 3083 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmaddsub_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
                                                       (__v8df) __B,
                                                       (__v8df) __C,
                                                       (__mmask8) -1,
                                                       0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmaddsub_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
                                                       (__v8df) __B,
                                                       (__v8df) __C,
                                                       (__mmask8) __U,
                                                       0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmaddsub_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask3 ((__v8df) __A,
                                                        (__v8df) __B,
                                                        (__v8df) __C,
                                                        (__mmask8) __U,
                                                        0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmaddsub_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_maskz ((__v8df) __A,
                                                        (__v8df) __B,
                                                        (__v8df) __C,
                                                        (__mmask8) __U,
                                                        0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmsubadd_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
                                                       (__v8df) __B,
                                                       -(__v8df) __C,
                                                       (__mmask8) -1,
                                                       0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmsubadd_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
                                                       (__v8df) __B,
                                                       -(__v8df) __C,
                                                       (__mmask8) __U,
                                                       0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmsubadd_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_maskz ((__v8df) __A,
                                                        (__v8df) __B,
                                                        -(__v8df) __C,
                                                        (__mmask8) __U,
                                                        0x04);
}
# 3202 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmaddsub_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
                                                      (__v16sf) __B,
                                                      (__v16sf) __C,
                                                      (__mmask16) -1,
                                                      0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmaddsub_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
                                                      (__v16sf) __B,
                                                      (__v16sf) __C,
                                                      (__mmask16) __U,
                                                      0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmaddsub_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask3 ((__v16sf) __A,
                                                       (__v16sf) __B,
                                                       (__v16sf) __C,
                                                       (__mmask16) __U,
                                                       0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmaddsub_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_maskz ((__v16sf) __A,
                                                       (__v16sf) __B,
                                                       (__v16sf) __C,
                                                       (__mmask16) __U,
                                                       0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmsubadd_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
                                                      (__v16sf) __B,
                                                      -(__v16sf) __C,
                                                      (__mmask16) -1,
                                                      0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmsubadd_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
                                                      (__v16sf) __B,
                                                      -(__v16sf) __C,
                                                      (__mmask16) __U,
                                                      0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmsubadd_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_maskz ((__v16sf) __A,
                                                       (__v16sf) __B,
                                                       -(__v16sf) __C,
                                                       (__mmask16) __U,
                                                       0x04);
}
# 3279 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmsub_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmsubpd512_mask3 ((__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}
# 3296 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmsub_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmsubps512_mask3 ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}
# 3313 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmsubadd_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmsubaddpd512_mask3 ((__v8df) __A,
                                                        (__v8df) __B,
                                                        (__v8df) __C,
                                                        (__mmask8) __U,
                                                        0x04);
}
# 3330 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmsubadd_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmsubaddps512_mask3 ((__v16sf) __A,
                                                       (__v16sf) __B,
                                                       (__v16sf) __C,
                                                       (__mmask16) __U,
                                                       0x04);
}
# 3347 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fnmadd_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfnmaddpd512_mask ((__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}
# 3364 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fnmadd_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfnmaddps512_mask ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}
# 3388 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fnmsub_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfnmsubpd512_mask ((__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fnmsub_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfnmsubpd512_mask3 ((__v8df) __A,
                                                      (__v8df) __B,
                                                      (__v8df) __C,
                                                      (__mmask8) __U,
                                                      0x04);
}
# 3422 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fnmsub_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfnmsubps512_mask ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fnmsub_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfnmsubps512_mask3 ((__v16sf) __A,
                                                     (__v16sf) __B,
                                                     (__v16sf) __C,
                                                     (__mmask16) __U,
                                                     0x04);
}





static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutex2var_epi32(__m512i __A, __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2vard512_mask ((__v16si) __I
                                                                 ,
                                                       (__v16si) __A,
                                                       (__v16si) __B,
                                                       (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_permutex2var_epi32 (__m512i __A, __mmask16 __U,
                                __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2vard512_mask ((__v16si) __I
                                                                  ,
                                                        (__v16si) __A,
                                                        (__v16si) __B,
                                                        (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_permutex2var_epi32 (__mmask16 __U, __m512i __A,
                                 __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2vard512_maskz ((__v16si) __I
                                                                  ,
                                                        (__v16si) __A,
                                                        (__v16si) __B,
                                                        (__mmask16) __U);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutex2var_epi64(__m512i __A, __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varq512_mask ((__v8di) __I
                                                                 ,
                                                       (__v8di) __A,
                                                       (__v8di) __B,
                                                       (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_permutex2var_epi64 (__m512i __A, __mmask8 __U, __m512i __I,
                                __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varq512_mask ((__v8di) __I
                                                                 ,
                                                       (__v8di) __A,
                                                       (__v8di) __B,
                                                       (__mmask8) __U);
}


static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_permutex2var_epi64 (__mmask8 __U, __m512i __A,
         __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varq512_maskz ((__v8di) __I
                                                                  ,
                                                        (__v8di) __A,
                                                        (__v8di) __B,
                                                        (__mmask8) __U);
}
# 3602 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_blend_pd(__mmask8 __U, __m512d __A, __m512d __W)
{
  return (__m512d) __builtin_ia32_selectpd_512 ((__mmask8) __U,
                 (__v8df) __W,
                 (__v8df) __A);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_blend_ps(__mmask16 __U, __m512 __A, __m512 __W)
{
  return (__m512) __builtin_ia32_selectps_512 ((__mmask16) __U,
                (__v16sf) __W,
                (__v16sf) __A);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_blend_epi64(__mmask8 __U, __m512i __A, __m512i __W)
{
  return (__m512i) __builtin_ia32_selectq_512 ((__mmask8) __U,
                (__v8di) __W,
                (__v8di) __A);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_blend_epi32(__mmask16 __U, __m512i __A, __m512i __W)
{
  return (__m512i) __builtin_ia32_selectd_512 ((__mmask16) __U,
                (__v16si) __W,
                (__v16si) __A);
}
# 3764 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvttps_epu32(__m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2udq512_mask ((__v16sf) __A,
                  (__v16si)
                  _mm512_setzero_si512 (),
                  (__mmask16) -1,
                  0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvttps_epu32 (__m512i __W, __mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2udq512_mask ((__v16sf) __A,
                   (__v16si) __W,
                   (__mmask16) __U,
                   0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvttps_epu32 (__mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2udq512_mask ((__v16sf) __A,
                   (__v16si) _mm512_setzero_si512 (),
                   (__mmask16) __U,
                   0x04);
}
# 3822 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepu32_ps (__m512i __A)
{
  return (__m512) __builtin_ia32_cvtudq2ps512_mask ((__v16si) __A,
                 (__v16sf) _mm512_undefined_ps (),
                 (__mmask16) -1,
                 0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepu32_ps (__m512 __W, __mmask16 __U, __m512i __A)
{
  return (__m512) __builtin_ia32_cvtudq2ps512_mask ((__v16si) __A,
                 (__v16sf) __W,
                 (__mmask16) __U,
                 0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepu32_ps (__mmask16 __U, __m512i __A)
{
  return (__m512) __builtin_ia32_cvtudq2ps512_mask ((__v16si) __A,
                 (__v16sf) _mm512_setzero_ps (),
                 (__mmask16) __U,
                 0x04);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi32_pd(__m256i __A)
{
  return (__m512d)__builtin_convertvector((__v8si)__A, __v8df);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi32_pd (__m512d __W, __mmask8 __U, __m256i __A)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8) __U,
                                              (__v8df)_mm512_cvtepi32_pd(__A),
                                              (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi32_pd (__mmask8 __U, __m256i __A)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8) __U,
                                              (__v8df)_mm512_cvtepi32_pd(__A),
                                              (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi32lo_pd(__m512i __A)
{
  return (__m512d) _mm512_cvtepi32_pd(_mm512_castsi512_si256(__A));
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi32lo_pd(__m512d __W, __mmask8 __U,__m512i __A)
{
  return (__m512d) _mm512_mask_cvtepi32_pd(__W, __U, _mm512_castsi512_si256(__A));
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi32_ps (__m512i __A)
{
  return (__m512) __builtin_ia32_cvtdq2ps512_mask ((__v16si) __A,
                (__v16sf) _mm512_undefined_ps (),
                (__mmask16) -1,
                0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi32_ps (__m512 __W, __mmask16 __U, __m512i __A)
{
  return (__m512) __builtin_ia32_cvtdq2ps512_mask ((__v16si) __A,
                (__v16sf) __W,
                (__mmask16) __U,
                0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi32_ps (__mmask16 __U, __m512i __A)
{
  return (__m512) __builtin_ia32_cvtdq2ps512_mask ((__v16si) __A,
                (__v16sf) _mm512_setzero_ps (),
                (__mmask16) __U,
                0x04);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepu32_pd(__m256i __A)
{
  return (__m512d)__builtin_convertvector((__v8su)__A, __v8df);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepu32_pd (__m512d __W, __mmask8 __U, __m256i __A)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8) __U,
                                              (__v8df)_mm512_cvtepu32_pd(__A),
                                              (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepu32_pd (__mmask8 __U, __m256i __A)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8) __U,
                                              (__v8df)_mm512_cvtepu32_pd(__A),
                                              (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepu32lo_pd(__m512i __A)
{
  return (__m512d) _mm512_cvtepu32_pd(_mm512_castsi512_si256(__A));
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepu32lo_pd(__m512d __W, __mmask8 __U,__m512i __A)
{
  return (__m512d) _mm512_mask_cvtepu32_pd(__W, __U, _mm512_castsi512_si256(__A));
}
# 3959 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtpd_ps (__m512d __A)
{
  return (__m256) __builtin_ia32_cvtpd2ps512_mask ((__v8df) __A,
                (__v8sf) _mm256_undefined_ps (),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtpd_ps (__m256 __W, __mmask8 __U, __m512d __A)
{
  return (__m256) __builtin_ia32_cvtpd2ps512_mask ((__v8df) __A,
                (__v8sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtpd_ps (__mmask8 __U, __m512d __A)
{
  return (__m256) __builtin_ia32_cvtpd2ps512_mask ((__v8df) __A,
                (__v8sf) _mm256_setzero_ps (),
                (__mmask8) __U,
                0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtpd_pslo (__m512d __A)
{
  return (__m512) __builtin_shufflevector((__v8sf) _mm512_cvtpd_ps(__A),
                (__v8sf) _mm256_setzero_ps (),
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtpd_pslo (__m512 __W, __mmask8 __U,__m512d __A)
{
  return (__m512) __builtin_shufflevector (
                (__v8sf) _mm512_mask_cvtpd_ps (_mm512_castps512_ps256(__W),
                                               __U, __A),
                (__v8sf) _mm256_setzero_ps (),
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
}
# 4050 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtph_ps(__m256i __A)
{
  return (__m512) __builtin_ia32_vcvtph2ps512_mask ((__v16hi) __A,
                (__v16sf)
                _mm512_setzero_ps (),
                (__mmask16) -1,
                0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtph_ps (__m512 __W, __mmask16 __U, __m256i __A)
{
  return (__m512) __builtin_ia32_vcvtph2ps512_mask ((__v16hi) __A,
                 (__v16sf) __W,
                 (__mmask16) __U,
                 0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtph_ps (__mmask16 __U, __m256i __A)
{
  return (__m512) __builtin_ia32_vcvtph2ps512_mask ((__v16hi) __A,
                 (__v16sf) _mm512_setzero_ps (),
                 (__mmask16) __U,
                 0x04);
}
# 4093 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvttpd_epi32(__m512d __a)
{
  return (__m256i)__builtin_ia32_cvttpd2dq512_mask((__v8df) __a,
                                                   (__v8si)_mm256_setzero_si256(),
                                                   (__mmask8) -1,
                                                    0x04);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvttpd_epi32 (__m256i __W, __mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2dq512_mask ((__v8df) __A,
                  (__v8si) __W,
                  (__mmask8) __U,
                  0x04);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvttpd_epi32 (__mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2dq512_mask ((__v8df) __A,
                  (__v8si) _mm256_setzero_si256 (),
                  (__mmask8) __U,
                  0x04);
}
# 4135 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvttps_epi32(__m512 __a)
{
  return (__m512i)
    __builtin_ia32_cvttps2dq512_mask((__v16sf) __a,
                                     (__v16si) _mm512_setzero_si512 (),
                                     (__mmask16) -1, 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvttps_epi32 (__m512i __W, __mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2dq512_mask ((__v16sf) __A,
                  (__v16si) __W,
                  (__mmask16) __U,
                  0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvttps_epi32 (__mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2dq512_mask ((__v16sf) __A,
                  (__v16si) _mm512_setzero_si512 (),
                  (__mmask16) __U,
                  0x04);
}
# 4177 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtps_epi32 (__m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2dq512_mask ((__v16sf) __A,
                 (__v16si) _mm512_undefined_epi32 (),
                 (__mmask16) -1,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtps_epi32 (__m512i __W, __mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2dq512_mask ((__v16sf) __A,
                 (__v16si) __W,
                 (__mmask16) __U,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtps_epi32 (__mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2dq512_mask ((__v16sf) __A,
                 (__v16si)
                 _mm512_setzero_si512 (),
                 (__mmask16) __U,
                 0x04);
}
# 4220 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtpd_epi32 (__m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2dq512_mask ((__v8df) __A,
                 (__v8si)
                 _mm256_undefined_si256 (),
                 (__mmask8) -1,
                 0x04);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtpd_epi32 (__m256i __W, __mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2dq512_mask ((__v8df) __A,
                 (__v8si) __W,
                 (__mmask8) __U,
                 0x04);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtpd_epi32 (__mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2dq512_mask ((__v8df) __A,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U,
                 0x04);
}
# 4264 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtps_epu32 ( __m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2udq512_mask ((__v16sf) __A, (__v16si) _mm512_undefined_epi32 (), (__mmask16) -1, 0x04);}






static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtps_epu32 (__m512i __W, __mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2udq512_mask ((__v16sf) __A,
                  (__v16si) __W,
                  (__mmask16) __U,
                  0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtps_epu32 ( __mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2udq512_mask ((__v16sf) __A,
                  (__v16si)
                  _mm512_setzero_si512 (),
                  (__mmask16) __U ,
                  0x04);
}
# 4308 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtpd_epu32 (__m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2udq512_mask ((__v8df) __A,
                  (__v8si)
                  _mm256_undefined_si256 (),
                  (__mmask8) -1,
                  0x04);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtpd_epu32 (__m256i __W, __mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2udq512_mask ((__v8df) __A,
                  (__v8si) __W,
                  (__mmask8) __U,
                  0x04);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtpd_epu32 (__mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2udq512_mask ((__v8df) __A,
                  (__v8si)
                  _mm256_setzero_si256 (),
                  (__mmask8) __U,
                  0x04);
}

static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtsd_f64(__m512d __a)
{
  return __a[0];
}

static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtss_f32(__m512 __a)
{
  return __a[0];
}



static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpackhi_pd(__m512d __a, __m512d __b)
{
  return (__m512d)__builtin_shufflevector((__v8df)__a, (__v8df)__b,
                                          1, 9, 1+2, 9+2, 1+4, 9+4, 1+6, 9+6);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_unpackhi_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8) __U,
                                           (__v8df)_mm512_unpackhi_pd(__A, __B),
                                           (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_unpackhi_pd(__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8) __U,
                                           (__v8df)_mm512_unpackhi_pd(__A, __B),
                                           (__v8df)_mm512_setzero_pd());
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpacklo_pd(__m512d __a, __m512d __b)
{
  return (__m512d)__builtin_shufflevector((__v8df)__a, (__v8df)__b,
                                          0, 8, 0+2, 8+2, 0+4, 8+4, 0+6, 8+6);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_unpacklo_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8) __U,
                                           (__v8df)_mm512_unpacklo_pd(__A, __B),
                                           (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_unpacklo_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8) __U,
                                           (__v8df)_mm512_unpacklo_pd(__A, __B),
                                           (__v8df)_mm512_setzero_pd());
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpackhi_ps(__m512 __a, __m512 __b)
{
  return (__m512)__builtin_shufflevector((__v16sf)__a, (__v16sf)__b,
                                         2, 18, 3, 19,
                                         2+4, 18+4, 3+4, 19+4,
                                         2+8, 18+8, 3+8, 19+8,
                                         2+12, 18+12, 3+12, 19+12);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_unpackhi_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16) __U,
                                          (__v16sf)_mm512_unpackhi_ps(__A, __B),
                                          (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_unpackhi_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16) __U,
                                          (__v16sf)_mm512_unpackhi_ps(__A, __B),
                                          (__v16sf)_mm512_setzero_ps());
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpacklo_ps(__m512 __a, __m512 __b)
{
  return (__m512)__builtin_shufflevector((__v16sf)__a, (__v16sf)__b,
                                         0, 16, 1, 17,
                                         0+4, 16+4, 1+4, 17+4,
                                         0+8, 16+8, 1+8, 17+8,
                                         0+12, 16+12, 1+12, 17+12);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_unpacklo_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16) __U,
                                          (__v16sf)_mm512_unpacklo_ps(__A, __B),
                                          (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_unpacklo_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16) __U,
                                          (__v16sf)_mm512_unpacklo_ps(__A, __B),
                                          (__v16sf)_mm512_setzero_ps());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpackhi_epi32(__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_shufflevector((__v16si)__A, (__v16si)__B,
                                          2, 18, 3, 19,
                                          2+4, 18+4, 3+4, 19+4,
                                          2+8, 18+8, 3+8, 19+8,
                                          2+12, 18+12, 3+12, 19+12);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_unpackhi_epi32(__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16) __U,
                                       (__v16si)_mm512_unpackhi_epi32(__A, __B),
                                       (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_unpackhi_epi32(__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16) __U,
                                       (__v16si)_mm512_unpackhi_epi32(__A, __B),
                                       (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpacklo_epi32(__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_shufflevector((__v16si)__A, (__v16si)__B,
                                          0, 16, 1, 17,
                                          0+4, 16+4, 1+4, 17+4,
                                          0+8, 16+8, 1+8, 17+8,
                                          0+12, 16+12, 1+12, 17+12);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_unpacklo_epi32(__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16) __U,
                                       (__v16si)_mm512_unpacklo_epi32(__A, __B),
                                       (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_unpacklo_epi32(__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16) __U,
                                       (__v16si)_mm512_unpacklo_epi32(__A, __B),
                                       (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpackhi_epi64(__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_shufflevector((__v8di)__A, (__v8di)__B,
                                          1, 9, 1+2, 9+2, 1+4, 9+4, 1+6, 9+6);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_unpackhi_epi64(__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8) __U,
                                        (__v8di)_mm512_unpackhi_epi64(__A, __B),
                                        (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_unpackhi_epi64(__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8) __U,
                                        (__v8di)_mm512_unpackhi_epi64(__A, __B),
                                        (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpacklo_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_shufflevector((__v8di)__A, (__v8di)__B,
                                          0, 8, 0+2, 8+2, 0+4, 8+4, 0+6, 8+6);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_unpacklo_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8) __U,
                                        (__v8di)_mm512_unpacklo_epi64(__A, __B),
                                        (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_unpacklo_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8) __U,
                                        (__v8di)_mm512_unpacklo_epi64(__A, __B),
                                        (__v8di)_mm512_setzero_si512());
}



static inline __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_test_epi32_mask(__m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ptestmd512 ((__v16si) __A,
            (__v16si) __B,
            (__mmask16) -1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_test_epi32_mask (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ptestmd512 ((__v16si) __A,
                 (__v16si) __B, __U);
}

static inline __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_test_epi64_mask(__m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq512 ((__v8di) __A,
                 (__v8di) __B,
                 (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_test_epi64_mask (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq512 ((__v8di) __A, (__v8di) __B, __U);
}




static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_loadu_si512 (void const *__P)
{
  return (__m512i) __builtin_ia32_loaddqusi512_mask ((const int *) __P,
                  (__v16si)
                  _mm512_setzero_si512 (),
                  (__mmask16) -1);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_loadu_epi32 (__m512i __W, __mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddqusi512_mask ((const int *) __P,
                  (__v16si) __W,
                  (__mmask16) __U);
}


static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_loadu_epi32(__mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddqusi512_mask ((const int *)__P,
                                                     (__v16si)
                                                     _mm512_setzero_si512 (),
                                                     (__mmask16) __U);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_loadu_epi64 (__m512i __W, __mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddqudi512_mask ((const long long *) __P,
                  (__v8di) __W,
                  (__mmask8) __U);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_loadu_epi64(__mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddqudi512_mask ((const long long *)__P,
                                                     (__v8di)
                                                     _mm512_setzero_si512 (),
                                                     (__mmask8) __U);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_loadu_ps (__m512 __W, __mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_loadups512_mask ((const float *) __P,
                   (__v16sf) __W,
                   (__mmask16) __U);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_loadu_ps(__mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_loadups512_mask ((const float *)__P,
                                                  (__v16sf)
                                                  _mm512_setzero_ps (),
                                                  (__mmask16) __U);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_loadu_pd (__m512d __W, __mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_loadupd512_mask ((const double *) __P,
                (__v8df) __W,
                (__mmask8) __U);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_loadu_pd(__mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_loadupd512_mask ((const double *)__P,
                                                   (__v8df)
                                                   _mm512_setzero_pd (),
                                                   (__mmask8) __U);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_loadu_pd(void const *__p)
{
  struct __loadu_pd {
    __m512d __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_pd*)__p)->__v;
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_loadu_ps(void const *__p)
{
  struct __loadu_ps {
    __m512 __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)__p)->__v;
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_load_ps(void const *__p)
{
  return (__m512) __builtin_ia32_loadaps512_mask ((const __v16sf *)__p,
                                                  (__v16sf)
                                                  _mm512_setzero_ps (),
                                                  (__mmask16) -1);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_load_ps (__m512 __W, __mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_loadaps512_mask ((const __v16sf *) __P,
                   (__v16sf) __W,
                   (__mmask16) __U);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_load_ps(__mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_loadaps512_mask ((const __v16sf *)__P,
                                                  (__v16sf)
                                                  _mm512_setzero_ps (),
                                                  (__mmask16) __U);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_load_pd(void const *__p)
{
  return (__m512d) __builtin_ia32_loadapd512_mask ((const __v8df *)__p,
                                                   (__v8df)
                                                   _mm512_setzero_pd (),
                                                   (__mmask8) -1);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_load_pd (__m512d __W, __mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_loadapd512_mask ((const __v8df *) __P,
                          (__v8df) __W,
                          (__mmask8) __U);
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_load_pd(__mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_loadapd512_mask ((const __v8df *)__P,
                                                   (__v8df)
                                                   _mm512_setzero_pd (),
                                                   (__mmask8) __U);
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_load_si512 (void const *__P)
{
  return *(__m512i *) __P;
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_load_epi32 (void const *__P)
{
  return *(__m512i *) __P;
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_load_epi64 (void const *__P)
{
  return *(__m512i *) __P;
}



static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_storeu_epi64(void *__P, __mmask8 __U, __m512i __A)
{
  __builtin_ia32_storedqudi512_mask ((long long *)__P, (__v8di) __A,
                                     (__mmask8) __U);
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_storeu_si512 (void *__P, __m512i __A)
{
  __builtin_ia32_storedqusi512_mask ((int *) __P, (__v16si) __A,
            (__mmask16) -1);
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_storeu_epi32(void *__P, __mmask16 __U, __m512i __A)
{
  __builtin_ia32_storedqusi512_mask ((int *)__P, (__v16si) __A,
                                     (__mmask16) __U);
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_storeu_pd(void *__P, __mmask8 __U, __m512d __A)
{
  __builtin_ia32_storeupd512_mask ((double *)__P, (__v8df) __A, (__mmask8) __U);
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_storeu_pd(void *__P, __m512d __A)
{
  __builtin_ia32_storeupd512_mask((double *)__P, (__v8df)__A, (__mmask8)-1);
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_storeu_ps(void *__P, __mmask16 __U, __m512 __A)
{
  __builtin_ia32_storeups512_mask ((float *)__P, (__v16sf) __A,
                                   (__mmask16) __U);
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_storeu_ps(void *__P, __m512 __A)
{
  __builtin_ia32_storeups512_mask((float *)__P, (__v16sf)__A, (__mmask16)-1);
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_store_pd(void *__P, __mmask8 __U, __m512d __A)
{
  __builtin_ia32_storeapd512_mask ((__v8df *)__P, (__v8df) __A, (__mmask8) __U);
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_store_pd(void *__P, __m512d __A)
{
  *(__m512d*)__P = __A;
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_store_ps(void *__P, __mmask16 __U, __m512 __A)
{
  __builtin_ia32_storeaps512_mask ((__v16sf *)__P, (__v16sf) __A,
                                   (__mmask16) __U);
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_store_ps(void *__P, __m512 __A)
{
  *(__m512*)__P = __A;
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_store_si512 (void *__P, __m512i __A)
{
  *(__m512i *) __P = __A;
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_store_epi32 (void *__P, __m512i __A)
{
  *(__m512i *) __P = __A;
}

static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_store_epi64 (void *__P, __m512i __A)
{
  *(__m512i *) __P = __A;
}



static inline __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_knot(__mmask16 __M)
{
  return __builtin_ia32_knothi(__M);
}



static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpeq_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqd512_mask((__v16si)__a, (__v16si)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpeq_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqd512_mask((__v16si)__a, (__v16si)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpeq_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 0,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpeq_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 0,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpeq_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq512_mask((__v8di)__a, (__v8di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpeq_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq512_mask((__v8di)__a, (__v8di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpeq_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpeq_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 0,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpge_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 5,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpge_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 5,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpge_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 5,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpge_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 5,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpge_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpge_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpge_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpge_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 5,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpgt_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtd512_mask((__v16si)__a, (__v16si)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpgt_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtd512_mask((__v16si)__a, (__v16si)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpgt_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 6,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpgt_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 6,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpgt_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq512_mask((__v8di)__a, (__v8di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpgt_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq512_mask((__v8di)__a, (__v8di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpgt_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpgt_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 6,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmple_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 2,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmple_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 2,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmple_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 2,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmple_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 2,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmple_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmple_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmple_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmple_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 2,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmplt_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 1,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmplt_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 1,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmplt_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 1,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmplt_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 1,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmplt_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmplt_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmplt_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmplt_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 1,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpneq_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 4,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpneq_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 4,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpneq_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 4,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpneq_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 4,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpneq_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpneq_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpneq_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpneq_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 4,
                                                __u);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi8_epi32(__m128i __A)
{


  return (__m512i)__builtin_convertvector((__v16qs)__A, __v16si);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi8_epi32(__m512i __W, __mmask16 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                             (__v16si)_mm512_cvtepi8_epi32(__A),
                                             (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi8_epi32(__mmask16 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                             (__v16si)_mm512_cvtepi8_epi32(__A),
                                             (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi8_epi64(__m128i __A)
{


  return (__m512i)__builtin_convertvector(__builtin_shufflevector((__v16qs)__A, (__v16qs)__A, 0, 1, 2, 3, 4, 5, 6, 7), __v8di);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi8_epi64(__m512i __W, __mmask8 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepi8_epi64(__A),
                                             (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi8_epi64(__mmask8 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepi8_epi64(__A),
                                             (__v8di)_mm512_setzero_si512 ());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi32_epi64(__m256i __X)
{
  return (__m512i)__builtin_convertvector((__v8si)__X, __v8di);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi32_epi64(__m512i __W, __mmask8 __U, __m256i __X)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepi32_epi64(__X),
                                             (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi32_epi64(__mmask8 __U, __m256i __X)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepi32_epi64(__X),
                                             (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi16_epi32(__m256i __A)
{
  return (__m512i)__builtin_convertvector((__v16hi)__A, __v16si);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi16_epi32(__m512i __W, __mmask16 __U, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                            (__v16si)_mm512_cvtepi16_epi32(__A),
                                            (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi16_epi32(__mmask16 __U, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                            (__v16si)_mm512_cvtepi16_epi32(__A),
                                            (__v16si)_mm512_setzero_si512 ());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi16_epi64(__m128i __A)
{
  return (__m512i)__builtin_convertvector((__v8hi)__A, __v8di);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi16_epi64(__m512i __W, __mmask8 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepi16_epi64(__A),
                                             (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi16_epi64(__mmask8 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepi16_epi64(__A),
                                             (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepu8_epi32(__m128i __A)
{
  return (__m512i)__builtin_convertvector((__v16qu)__A, __v16si);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepu8_epi32(__m512i __W, __mmask16 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                             (__v16si)_mm512_cvtepu8_epi32(__A),
                                             (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepu8_epi32(__mmask16 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                             (__v16si)_mm512_cvtepu8_epi32(__A),
                                             (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepu8_epi64(__m128i __A)
{
  return (__m512i)__builtin_convertvector(__builtin_shufflevector((__v16qu)__A, (__v16qu)__A, 0, 1, 2, 3, 4, 5, 6, 7), __v8di);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepu8_epi64(__m512i __W, __mmask8 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepu8_epi64(__A),
                                             (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepu8_epi64(__mmask8 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepu8_epi64(__A),
                                             (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepu32_epi64(__m256i __X)
{
  return (__m512i)__builtin_convertvector((__v8su)__X, __v8di);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepu32_epi64(__m512i __W, __mmask8 __U, __m256i __X)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepu32_epi64(__X),
                                             (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepu32_epi64(__mmask8 __U, __m256i __X)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepu32_epi64(__X),
                                             (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepu16_epi32(__m256i __A)
{
  return (__m512i)__builtin_convertvector((__v16hu)__A, __v16si);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepu16_epi32(__m512i __W, __mmask16 __U, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                            (__v16si)_mm512_cvtepu16_epi32(__A),
                                            (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepu16_epi32(__mmask16 __U, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                            (__v16si)_mm512_cvtepu16_epi32(__A),
                                            (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepu16_epi64(__m128i __A)
{
  return (__m512i)__builtin_convertvector((__v8hu)__A, __v8di);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepu16_epi64(__m512i __W, __mmask8 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepu16_epi64(__A),
                                             (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepu16_epi64(__mmask8 __U, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_cvtepu16_epi64(__A),
                                             (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rorv_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_rorv_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si) __W,
              (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_rorv_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rorv_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_rorv_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di) __W,
              (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_rorv_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) __U);
}
# 5488 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rolv_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_rolv_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si) __W,
              (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_rolv_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rolv_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_rolv_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di) __W,
              (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_rolv_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) __U);
}
# 5575 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_slli_epi32(__m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_pslldi512((__v16si)__A, __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_slli_epi32(__m512i __W, __mmask16 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                         (__v16si)_mm512_slli_epi32(__A, __B),
                                         (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_slli_epi32(__mmask16 __U, __m512i __A, int __B) {
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                         (__v16si)_mm512_slli_epi32(__A, __B),
                                         (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_slli_epi64(__m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_psllqi512((__v8di)__A, __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_slli_epi64(__m512i __W, __mmask8 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                          (__v8di)_mm512_slli_epi64(__A, __B),
                                          (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_slli_epi64(__mmask8 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                          (__v8di)_mm512_slli_epi64(__A, __B),
                                          (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_srli_epi32(__m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_psrldi512((__v16si)__A, __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_srli_epi32(__m512i __W, __mmask16 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                         (__v16si)_mm512_srli_epi32(__A, __B),
                                         (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_srli_epi32(__mmask16 __U, __m512i __A, int __B) {
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                         (__v16si)_mm512_srli_epi32(__A, __B),
                                         (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_srli_epi64(__m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_psrlqi512((__v8di)__A, __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_srli_epi64(__m512i __W, __mmask8 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                          (__v8di)_mm512_srli_epi64(__A, __B),
                                          (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_srli_epi64(__mmask8 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                          (__v8di)_mm512_srli_epi64(__A, __B),
                                          (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_load_epi32 (__m512i __W, __mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_movdqa32load512_mask ((const __v16si *) __P,
              (__v16si) __W,
              (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_load_epi32 (__mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_movdqa32load512_mask ((const __v16si *) __P,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_store_epi32 (void *__P, __mmask16 __U, __m512i __A)
{
  __builtin_ia32_movdqa32store512_mask ((__v16si *) __P, (__v16si) __A,
          (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mov_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_selectd_512 ((__mmask16) __U,
                 (__v16si) __A,
                 (__v16si) __W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mov_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_selectd_512 ((__mmask16) __U,
                 (__v16si) __A,
                 (__v16si) _mm512_setzero_si512 ());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mov_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_selectq_512 ((__mmask8) __U,
                 (__v8di) __A,
                 (__v8di) __W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mov_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_selectq_512 ((__mmask8) __U,
                 (__v8di) __A,
                 (__v8di) _mm512_setzero_si512 ());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_load_epi64 (__m512i __W, __mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_movdqa64load512_mask ((const __v8di *) __P,
              (__v8di) __W,
              (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_load_epi64 (__mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_movdqa64load512_mask ((const __v8di *) __P,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_store_epi64 (void *__P, __mmask8 __U, __m512i __A)
{
  __builtin_ia32_movdqa64store512_mask ((__v8di *) __P, (__v8di) __A,
          (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_movedup_pd (__m512d __A)
{
  return (__m512d)__builtin_shufflevector((__v8df)__A, (__v8df)__A,
                                          0, 0, 2, 2, 4, 4, 6, 6);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_movedup_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_movedup_pd(__A),
                                              (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_movedup_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_movedup_pd(__A),
                                              (__v8df)_mm512_setzero_pd());
}
# 5929 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_getexp_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_getexpsd128_round_mask ((__v2df) __A,
                 (__v2df) __B, (__v2df) _mm_setzero_pd(), (__mmask8) -1, 0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_getexp_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_getexpsd128_round_mask ( (__v2df) __A,
          (__v2df) __B,
          (__v2df) __W,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_getexp_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_getexpsd128_round_mask ( (__v2df) __A,
          (__v2df) __B,
          (__v2df) _mm_setzero_pd (),
          (__mmask8) __U,
          0x04);
}
# 5974 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_getexp_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_getexpss128_round_mask ((__v4sf) __A,
                (__v4sf) __B, (__v4sf) _mm_setzero_ps(), (__mmask8) -1, 0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_getexp_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_getexpss128_round_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __W,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_getexp_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_getexpss128_round_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) _mm_setzero_pd (),
          (__mmask8) __U,
          0x04);
}
# 6103 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_kmov (__mmask16 __A)
{
  return __A;
}
# 6122 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask2_permutex2var_epi32 (__m512i __A, __m512i __I,
         __mmask16 __U, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermi2vard512_mask ((__v16si) __A,
                   (__v16si) __I
                             ,
                   (__v16si) __B,
                   (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sll_epi32(__m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_pslld512((__v16si) __A, (__v4si)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sll_epi32(__m512i __W, __mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                          (__v16si)_mm512_sll_epi32(__A, __B),
                                          (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sll_epi32(__mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                          (__v16si)_mm512_sll_epi32(__A, __B),
                                          (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sll_epi64(__m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_psllq512((__v8di)__A, (__v2di)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sll_epi64(__m512i __W, __mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_sll_epi64(__A, __B),
                                             (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sll_epi64(__mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                           (__v8di)_mm512_sll_epi64(__A, __B),
                                           (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sllv_epi32(__m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_psllv16si((__v16si)__X, (__v16si)__Y);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sllv_epi32(__m512i __W, __mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                           (__v16si)_mm512_sllv_epi32(__X, __Y),
                                           (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sllv_epi32(__mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                           (__v16si)_mm512_sllv_epi32(__X, __Y),
                                           (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sllv_epi64(__m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_psllv8di((__v8di)__X, (__v8di)__Y);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sllv_epi64(__m512i __W, __mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                            (__v8di)_mm512_sllv_epi64(__X, __Y),
                                            (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sllv_epi64(__mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                            (__v8di)_mm512_sllv_epi64(__X, __Y),
                                            (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sra_epi32(__m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_psrad512((__v16si) __A, (__v4si)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sra_epi32(__m512i __W, __mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                          (__v16si)_mm512_sra_epi32(__A, __B),
                                          (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sra_epi32(__mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                          (__v16si)_mm512_sra_epi32(__A, __B),
                                          (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sra_epi64(__m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_psraq512((__v8di)__A, (__v2di)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sra_epi64(__m512i __W, __mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                           (__v8di)_mm512_sra_epi64(__A, __B),
                                           (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sra_epi64(__mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                           (__v8di)_mm512_sra_epi64(__A, __B),
                                           (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_srav_epi32(__m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_psrav16si((__v16si)__X, (__v16si)__Y);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_srav_epi32(__m512i __W, __mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                           (__v16si)_mm512_srav_epi32(__X, __Y),
                                           (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_srav_epi32(__mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                           (__v16si)_mm512_srav_epi32(__X, __Y),
                                           (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_srav_epi64(__m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_psrav8di((__v8di)__X, (__v8di)__Y);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_srav_epi64(__m512i __W, __mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                            (__v8di)_mm512_srav_epi64(__X, __Y),
                                            (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_srav_epi64(__mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                            (__v8di)_mm512_srav_epi64(__X, __Y),
                                            (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_srl_epi32(__m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_psrld512((__v16si) __A, (__v4si)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_srl_epi32(__m512i __W, __mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                          (__v16si)_mm512_srl_epi32(__A, __B),
                                          (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_srl_epi32(__mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                          (__v16si)_mm512_srl_epi32(__A, __B),
                                          (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_srl_epi64(__m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_psrlq512((__v8di)__A, (__v2di)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_srl_epi64(__m512i __W, __mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                           (__v8di)_mm512_srl_epi64(__A, __B),
                                           (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_srl_epi64(__mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                           (__v8di)_mm512_srl_epi64(__A, __B),
                                           (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_srlv_epi32(__m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_psrlv16si((__v16si)__X, (__v16si)__Y);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_srlv_epi32(__m512i __W, __mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                           (__v16si)_mm512_srlv_epi32(__X, __Y),
                                           (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_srlv_epi32(__mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U,
                                           (__v16si)_mm512_srlv_epi32(__X, __Y),
                                           (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_srlv_epi64 (__m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_psrlv8di((__v8di)__X, (__v8di)__Y);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_srlv_epi64(__m512i __W, __mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                            (__v8di)_mm512_srlv_epi64(__X, __Y),
                                            (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_srlv_epi64(__mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                            (__v8di)_mm512_srlv_epi64(__X, __Y),
                                            (__v8di)_mm512_setzero_si512());
}
# 6447 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ unsigned __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvtsd_u32 (__m128d __A)
{
  return (unsigned) __builtin_ia32_vcvtsd2usi32 ((__v2df) __A,
             0x04);
}






static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvtsd_u64 (__m128d __A)
{
  return (unsigned long long) __builtin_ia32_vcvtsd2usi64 ((__v2df)
                 __A,
                 0x04);
}
# 6485 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ unsigned __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvtss_u32 (__m128 __A)
{
  return (unsigned) __builtin_ia32_vcvtss2usi32 ((__v4sf) __A,
             0x04);
}






static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvtss_u64 (__m128 __A)
{
  return (unsigned long long) __builtin_ia32_vcvtss2usi64 ((__v4sf)
                 __A,
                 0x04);
}
# 6512 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvttsd_i32 (__m128d __A)
{
  return (int) __builtin_ia32_vcvttsd2si32 ((__v2df) __A,
              0x04);
}
# 6526 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvttsd_i64 (__m128d __A)
{
  return (long long) __builtin_ia32_vcvttsd2si64 ((__v2df) __A,
              0x04);
}





static __inline__ unsigned __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvttsd_u32 (__m128d __A)
{
  return (unsigned) __builtin_ia32_vcvttsd2usi32 ((__v2df) __A,
              0x04);
}






static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvttsd_u64 (__m128d __A)
{
  return (unsigned long long) __builtin_ia32_vcvttsd2usi64 ((__v2df)
                  __A,
                  0x04);
}
# 6564 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvttss_i32 (__m128 __A)
{
  return (int) __builtin_ia32_vcvttss2si32 ((__v4sf) __A,
              0x04);
}
# 6578 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvttss_i64 (__m128 __A)
{
  return (long long) __builtin_ia32_vcvttss2si64 ((__v4sf) __A,
              0x04);
}





static __inline__ unsigned __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvttss_u32 (__m128 __A)
{
  return (unsigned) __builtin_ia32_vcvttss2usi32 ((__v4sf) __A,
              0x04);
}






static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvttss_u64 (__m128 __A)
{
  return (unsigned long long) __builtin_ia32_vcvttss2usi64 ((__v4sf)
                  __A,
                  0x04);
}


static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask2_permutex2var_pd (__m512d __A, __m512i __I, __mmask8 __U,
            __m512d __B)
{
  return (__m512d) __builtin_ia32_vpermi2varpd512_mask ((__v8df) __A,
              (__v8di) __I
                        ,
              (__v8df) __B,
              (__mmask8) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask2_permutex2var_ps (__m512 __A, __m512i __I, __mmask16 __U,
            __m512 __B)
{
  return (__m512) __builtin_ia32_vpermi2varps512_mask ((__v16sf) __A,
                   (__v16si) __I
                             ,
                   (__v16sf) __B,
                   (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask2_permutex2var_epi64 (__m512i __A, __m512i __I,
         __mmask8 __U, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermi2varq512_mask ((__v8di) __A,
                   (__v8di) __I
                             ,
                   (__v8di) __B,
                   (__mmask8) __U);
}
# 6695 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutevar_pd(__m512d __A, __m512i __C)
{
  return (__m512d)__builtin_ia32_vpermilvarpd512((__v8df)__A, (__v8di)__C);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_permutevar_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512i __C)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                         (__v8df)_mm512_permutevar_pd(__A, __C),
                                         (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_permutevar_pd(__mmask8 __U, __m512d __A, __m512i __C)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                         (__v8df)_mm512_permutevar_pd(__A, __C),
                                         (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutevar_ps(__m512 __A, __m512i __C)
{
  return (__m512)__builtin_ia32_vpermilvarps512((__v16sf)__A, (__v16si)__C);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_permutevar_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512i __C)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                        (__v16sf)_mm512_permutevar_ps(__A, __C),
                                        (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_permutevar_ps(__mmask16 __U, __m512 __A, __m512i __C)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                        (__v16sf)_mm512_permutevar_ps(__A, __C),
                                        (__v16sf)_mm512_setzero_ps());
}

static inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutex2var_pd(__m512d __A, __m512i __I, __m512d __B)
{
  return (__m512d) __builtin_ia32_vpermt2varpd512_mask ((__v8di) __I
                              ,
                    (__v8df) __A,
                    (__v8df) __B,
                    (__mmask8) -1);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_permutex2var_pd (__m512d __A, __mmask8 __U, __m512i __I, __m512d __B)
{
  return (__m512d) __builtin_ia32_vpermt2varpd512_mask ((__v8di) __I
                              ,
                    (__v8df) __A,
                    (__v8df) __B,
                    (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_permutex2var_pd (__mmask8 __U, __m512d __A, __m512i __I,
            __m512d __B)
{
  return (__m512d) __builtin_ia32_vpermt2varpd512_maskz ((__v8di) __I
                                                                   ,
                                                         (__v8df) __A,
                                                         (__v8df) __B,
                                                         (__mmask8) __U);
}

static inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutex2var_ps(__m512 __A, __m512i __I, __m512 __B)
{
  return (__m512) __builtin_ia32_vpermt2varps512_mask ((__v16si) __I
                                                                   ,
                                                         (__v16sf) __A,
                                                         (__v16sf) __B,
                                                         (__mmask16) -1);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_permutex2var_ps (__m512 __A, __mmask16 __U, __m512i __I, __m512 __B)
{
  return (__m512) __builtin_ia32_vpermt2varps512_mask ((__v16si) __I
                                                                   ,
                                                         (__v16sf) __A,
                                                         (__v16sf) __B,
                                                         (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_permutex2var_ps (__mmask16 __U, __m512 __A, __m512i __I,
            __m512 __B)
{
  return (__m512) __builtin_ia32_vpermt2varps512_maskz ((__v16si) __I
                                                                  ,
                                                        (__v16sf) __A,
                                                        (__v16sf) __B,
                                                        (__mmask16) __U);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_testn_epi32_mask (__m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmd512 ((__v16si) __A,
             (__v16si) __B,
             (__mmask16) -1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_testn_epi32_mask (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmd512 ((__v16si) __A,
             (__v16si) __B, __U);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_testn_epi64_mask (__m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq512 ((__v8di) __A,
            (__v8di) __B,
            (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_testn_epi64_mask (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq512 ((__v8di) __A,
            (__v8di) __B, __U);
}
# 6846 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvttpd_epu32 (__m512d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2udq512_mask ((__v8df) __A,
                  (__v8si)
                  _mm256_undefined_si256 (),
                  (__mmask8) -1,
                  0x04);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvttpd_epu32 (__m256i __W, __mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2udq512_mask ((__v8df) __A,
                  (__v8si) __W,
                  (__mmask8) __U,
                  0x04);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvttpd_epu32 (__mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2udq512_mask ((__v8df) __A,
                  (__v8si)
                  _mm256_setzero_si256 (),
                  (__mmask8) __U,
                  0x04);
}
# 6977 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_scalef_pd (__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_scalefpd512_mask ((__v8df) __A,
                (__v8df) __B,
                (__v8df)
                _mm512_undefined_pd (),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_scalef_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_scalefpd512_mask ((__v8df) __A,
                (__v8df) __B,
                (__v8df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_scalef_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_scalefpd512_mask ((__v8df) __A,
                (__v8df) __B,
                (__v8df)
                _mm512_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
# 7027 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_scalef_ps (__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_scalefps512_mask ((__v16sf) __A,
               (__v16sf) __B,
               (__v16sf)
               _mm512_undefined_ps (),
               (__mmask16) -1,
               0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_scalef_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_scalefps512_mask ((__v16sf) __A,
               (__v16sf) __B,
               (__v16sf) __W,
               (__mmask16) __U,
               0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_scalef_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_scalefps512_mask ((__v16sf) __A,
               (__v16sf) __B,
               (__v16sf)
               _mm512_setzero_ps (),
               (__mmask16) __U,
               0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_scalef_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_scalefsd_round_mask ((__v2df) __A,
              (__v2df)( __B), (__v2df) _mm_setzero_pd(),
              (__mmask8) -1,
              0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_scalef_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_scalefsd_round_mask ( (__v2df) __A,
                 (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_scalef_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_scalefsd_round_mask ( (__v2df) __A,
                 (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
# 7112 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_scalef_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_scalefss_round_mask ((__v4sf) __A,
             (__v4sf)( __B), (__v4sf) _mm_setzero_ps(),
             (__mmask8) -1,
             0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_scalef_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_scalefss_round_mask ( (__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_scalef_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_scalefss_round_mask ( (__v4sf) __A,
                 (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
# 7154 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_srai_epi32(__m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_psradi512((__v16si)__A, __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_srai_epi32(__m512i __W, __mmask16 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U, (__v16si)_mm512_srai_epi32(__A, __B), (__v16si)__W);


}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_srai_epi32(__mmask16 __U, __m512i __A, int __B) {
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__U, (__v16si)_mm512_srai_epi32(__A, __B), (__v16si)_mm512_setzero_si512());


}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_srai_epi64(__m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_psraqi512((__v8di)__A, __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_srai_epi64(__m512i __W, __mmask8 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U, (__v8di)_mm512_srai_epi64(__A, __B), (__v8di)__W);


}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_srai_epi64(__mmask8 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U, (__v8di)_mm512_srai_epi64(__A, __B), (__v8di)_mm512_setzero_si512());


}
# 7327 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_sqrt_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_sqrtsd_round_mask ( (__v2df) __A,
                 (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_sqrt_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_sqrtsd_round_mask ( (__v2df) __A,
                 (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
# 7365 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_sqrt_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_sqrtss_round_mask ( (__v4sf) __A,
                 (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_sqrt_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_sqrtss_round_mask ( (__v4sf) __A,
                 (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}







static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_broadcast_f32x4(__m128 __A)
{
  return (__m512)__builtin_shufflevector((__v4sf)__A, (__v4sf)__A,
                                         0, 1, 2, 3, 0, 1, 2, 3,
                                         0, 1, 2, 3, 0, 1, 2, 3);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_broadcast_f32x4(__m512 __O, __mmask16 __M, __m128 __A)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__M,
                                           (__v16sf)_mm512_broadcast_f32x4(__A),
                                           (__v16sf)__O);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_broadcast_f32x4(__mmask16 __M, __m128 __A)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__M,
                                           (__v16sf)_mm512_broadcast_f32x4(__A),
                                           (__v16sf)_mm512_setzero_ps());
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_broadcast_f64x4(__m256d __A)
{
  return (__m512d)__builtin_shufflevector((__v4df)__A, (__v4df)__A,
                                          0, 1, 2, 3, 0, 1, 2, 3);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_broadcast_f64x4(__m512d __O, __mmask8 __M, __m256d __A)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__M,
                                            (__v8df)_mm512_broadcast_f64x4(__A),
                                            (__v8df)__O);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_broadcast_f64x4(__mmask8 __M, __m256d __A)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__M,
                                            (__v8df)_mm512_broadcast_f64x4(__A),
                                            (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_broadcast_i32x4(__m128i __A)
{
  return (__m512i)__builtin_shufflevector((__v4si)__A, (__v4si)__A,
                                          0, 1, 2, 3, 0, 1, 2, 3,
                                          0, 1, 2, 3, 0, 1, 2, 3);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_broadcast_i32x4(__m512i __O, __mmask16 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__M,
                                           (__v16si)_mm512_broadcast_i32x4(__A),
                                           (__v16si)__O);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_broadcast_i32x4(__mmask16 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask16)__M,
                                           (__v16si)_mm512_broadcast_i32x4(__A),
                                           (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_broadcast_i64x4(__m256i __A)
{
  return (__m512i)__builtin_shufflevector((__v4di)__A, (__v4di)__A,
                                          0, 1, 2, 3, 0, 1, 2, 3);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_broadcast_i64x4(__m512i __O, __mmask8 __M, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__M,
                                            (__v8di)_mm512_broadcast_i64x4(__A),
                                            (__v8di)__O);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_broadcast_i64x4(__mmask8 __M, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__M,
                                            (__v8di)_mm512_broadcast_i64x4(__A),
                                            (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_broadcastsd_pd (__m512d __O, __mmask8 __M, __m128d __A)
{
  return (__m512d)__builtin_ia32_selectpd_512(__M,
                                              (__v8df) _mm512_broadcastsd_pd(__A),
                                              (__v8df) __O);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_broadcastsd_pd (__mmask8 __M, __m128d __A)
{
  return (__m512d)__builtin_ia32_selectpd_512(__M,
                                              (__v8df) _mm512_broadcastsd_pd(__A),
                                              (__v8df) _mm512_setzero_pd());
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_broadcastss_ps (__m512 __O, __mmask16 __M, __m128 __A)
{
  return (__m512)__builtin_ia32_selectps_512(__M,
                                             (__v16sf) _mm512_broadcastss_ps(__A),
                                             (__v16sf) __O);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_broadcastss_ps (__mmask16 __M, __m128 __A)
{
  return (__m512)__builtin_ia32_selectps_512(__M,
                                             (__v16sf) _mm512_broadcastss_ps(__A),
                                             (__v16sf) _mm512_setzero_ps());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtsepi32_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb512_mask ((__v16si) __A,
               (__v16qi) _mm_undefined_si128 (),
               (__mmask16) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtsepi32_epi8 (__m128i __O, __mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb512_mask ((__v16si) __A,
               (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtsepi32_epi8 (__mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb512_mask ((__v16si) __A,
               (__v16qi) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtsepi32_storeu_epi8 (void * __P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovsdb512mem_mask ((__v16qi *) __P, (__v16si) __A, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtsepi32_epi16 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsdw512_mask ((__v16si) __A,
               (__v16hi) _mm256_undefined_si256 (),
               (__mmask16) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtsepi32_epi16 (__m256i __O, __mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsdw512_mask ((__v16si) __A,
               (__v16hi) __O, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtsepi32_epi16 (__mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsdw512_mask ((__v16si) __A,
               (__v16hi) _mm256_setzero_si256 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtsepi32_storeu_epi16 (void *__P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovsdw512mem_mask ((__v16hi*) __P, (__v16si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtsepi64_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb512_mask ((__v8di) __A,
               (__v16qi) _mm_undefined_si128 (),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtsepi64_epi8 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb512_mask ((__v8di) __A,
               (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtsepi64_epi8 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb512_mask ((__v8di) __A,
               (__v16qi) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtsepi64_storeu_epi8 (void * __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovsqb512mem_mask ((__v16qi *) __P, (__v8di) __A, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtsepi64_epi32 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsqd512_mask ((__v8di) __A,
               (__v8si) _mm256_undefined_si256 (),
               (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtsepi64_epi32 (__m256i __O, __mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsqd512_mask ((__v8di) __A,
               (__v8si) __O, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtsepi64_epi32 (__mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsqd512_mask ((__v8di) __A,
               (__v8si) _mm256_setzero_si256 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtsepi64_storeu_epi32 (void *__P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovsqd512mem_mask ((__v8si *) __P, (__v8di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtsepi64_epi16 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw512_mask ((__v8di) __A,
               (__v8hi) _mm_undefined_si128 (),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtsepi64_epi16 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw512_mask ((__v8di) __A,
               (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtsepi64_epi16 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw512_mask ((__v8di) __A,
               (__v8hi) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtsepi64_storeu_epi16 (void * __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovsqw512mem_mask ((__v8hi *) __P, (__v8di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtusepi32_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb512_mask ((__v16si) __A,
                (__v16qi) _mm_undefined_si128 (),
                (__mmask16) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtusepi32_epi8 (__m128i __O, __mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb512_mask ((__v16si) __A,
                (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtusepi32_epi8 (__mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb512_mask ((__v16si) __A,
                (__v16qi) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtusepi32_storeu_epi8 (void * __P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovusdb512mem_mask ((__v16qi *) __P, (__v16si) __A, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtusepi32_epi16 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusdw512_mask ((__v16si) __A,
                (__v16hi) _mm256_undefined_si256 (),
                (__mmask16) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtusepi32_epi16 (__m256i __O, __mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusdw512_mask ((__v16si) __A,
                (__v16hi) __O,
                __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtusepi32_epi16 (__mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusdw512_mask ((__v16si) __A,
                (__v16hi) _mm256_setzero_si256 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtusepi32_storeu_epi16 (void *__P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovusdw512mem_mask ((__v16hi*) __P, (__v16si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtusepi64_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb512_mask ((__v8di) __A,
                (__v16qi) _mm_undefined_si128 (),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtusepi64_epi8 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb512_mask ((__v8di) __A,
                (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtusepi64_epi8 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb512_mask ((__v8di) __A,
                (__v16qi) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtusepi64_storeu_epi8 (void * __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovusqb512mem_mask ((__v16qi *) __P, (__v8di) __A, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtusepi64_epi32 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusqd512_mask ((__v8di) __A,
                (__v8si) _mm256_undefined_si256 (),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtusepi64_epi32 (__m256i __O, __mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusqd512_mask ((__v8di) __A,
                (__v8si) __O, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtusepi64_epi32 (__mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusqd512_mask ((__v8di) __A,
                (__v8si) _mm256_setzero_si256 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtusepi64_storeu_epi32 (void* __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovusqd512mem_mask ((__v8si*) __P, (__v8di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtusepi64_epi16 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw512_mask ((__v8di) __A,
                (__v8hi) _mm_undefined_si128 (),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtusepi64_epi16 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw512_mask ((__v8di) __A,
                (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtusepi64_epi16 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw512_mask ((__v8di) __A,
                (__v8hi) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtusepi64_storeu_epi16 (void *__P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovusqw512mem_mask ((__v8hi*) __P, (__v8di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi32_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovdb512_mask ((__v16si) __A,
              (__v16qi) _mm_undefined_si128 (),
              (__mmask16) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi32_epi8 (__m128i __O, __mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovdb512_mask ((__v16si) __A,
              (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi32_epi8 (__mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovdb512_mask ((__v16si) __A,
              (__v16qi) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi32_storeu_epi8 (void * __P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovdb512mem_mask ((__v16qi *) __P, (__v16si) __A, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi32_epi16 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovdw512_mask ((__v16si) __A,
              (__v16hi) _mm256_undefined_si256 (),
              (__mmask16) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi32_epi16 (__m256i __O, __mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovdw512_mask ((__v16si) __A,
              (__v16hi) __O, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi32_epi16 (__mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovdw512_mask ((__v16si) __A,
              (__v16hi) _mm256_setzero_si256 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi32_storeu_epi16 (void * __P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovdw512mem_mask ((__v16hi *) __P, (__v16si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi64_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqb512_mask ((__v8di) __A,
              (__v16qi) _mm_undefined_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi64_epi8 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqb512_mask ((__v8di) __A,
              (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi64_epi8 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqb512_mask ((__v8di) __A,
              (__v16qi) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi64_storeu_epi8 (void * __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovqb512mem_mask ((__v16qi *) __P, (__v8di) __A, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi64_epi32 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovqd512_mask ((__v8di) __A,
              (__v8si) _mm256_undefined_si256 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi64_epi32 (__m256i __O, __mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovqd512_mask ((__v8di) __A,
              (__v8si) __O, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi64_epi32 (__mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovqd512_mask ((__v8di) __A,
              (__v8si) _mm256_setzero_si256 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi64_storeu_epi32 (void* __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovqd512mem_mask ((__v8si *) __P, (__v8di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi64_epi16 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqw512_mask ((__v8di) __A,
              (__v8hi) _mm_undefined_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi64_epi16 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqw512_mask ((__v8di) __A,
              (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtepi64_epi16 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqw512_mask ((__v8di) __A,
              (__v8hi) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtepi64_storeu_epi16 (void *__P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovqw512mem_mask ((__v8hi *) __P, (__v8di) __A, __M);
}
# 8194 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_getexp_pd (__m512d __A)
{
  return (__m512d) __builtin_ia32_getexppd512_mask ((__v8df) __A,
                (__v8df) _mm512_undefined_pd (),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_getexp_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_getexppd512_mask ((__v8df) __A,
                (__v8df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_getexp_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_getexppd512_mask ((__v8df) __A,
                (__v8df) _mm512_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
# 8236 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_getexp_ps (__m512 __A)
{
  return (__m512) __builtin_ia32_getexpps512_mask ((__v16sf) __A,
               (__v16sf) _mm512_undefined_ps (),
               (__mmask16) -1,
               0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_getexp_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_getexpps512_mask ((__v16sf) __A,
               (__v16sf) __W,
               (__mmask16) __U,
               0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_getexp_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_getexpps512_mask ((__v16sf) __A,
               (__v16sf) _mm512_setzero_ps (),
               (__mmask16) __U,
               0x04);
}
# 8439 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_fmadd_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_vfmaddss3_mask ((__v4sf) __W,
          (__v4sf) __A,
          (__v4sf) __B,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_fmadd_ss (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
 return (__m128) __builtin_ia32_vfmaddss3_maskz ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __C,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask3_fmadd_ss (__m128 __W, __m128 __X, __m128 __Y, __mmask8 __U)
{
 return (__m128) __builtin_ia32_vfmaddss3_mask3 ((__v4sf) __W,
          (__v4sf) __X,
          (__v4sf) __Y,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_fmsub_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_vfmaddss3_mask ((__v4sf) __W,
          (__v4sf) __A,
          -(__v4sf) __B,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_fmsub_ss (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
 return (__m128) __builtin_ia32_vfmaddss3_maskz ((__v4sf) __A,
          (__v4sf) __B,
          -(__v4sf) __C,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask3_fmsub_ss (__m128 __W, __m128 __X, __m128 __Y, __mmask8 __U)
{
 return (__m128) __builtin_ia32_vfmsubss3_mask3 ((__v4sf) __W,
          (__v4sf) __X,
          (__v4sf) __Y,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_fnmadd_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_vfmaddss3_mask ((__v4sf) __W,
          -(__v4sf) __A,
          (__v4sf) __B,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_fnmadd_ss (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
 return (__m128) __builtin_ia32_vfmaddss3_maskz (-(__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __C,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask3_fnmadd_ss (__m128 __W, __m128 __X, __m128 __Y, __mmask8 __U)
{
 return (__m128) __builtin_ia32_vfmaddss3_mask3 (-(__v4sf) __W,
          (__v4sf) __X,
          (__v4sf) __Y,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_fnmsub_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
 return (__m128) __builtin_ia32_vfmaddss3_mask ((__v4sf) __W,
          -(__v4sf) __A,
          -(__v4sf) __B,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_fnmsub_ss (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
 return (__m128) __builtin_ia32_vfmaddss3_maskz (-(__v4sf) __A,
          (__v4sf) __B,
          -(__v4sf) __C,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask3_fnmsub_ss (__m128 __W, __m128 __X, __m128 __Y, __mmask8 __U)
{
 return (__m128) __builtin_ia32_vfnmsubss3_mask3 ((__v4sf) __W,
          (__v4sf) __X,
          (__v4sf) __Y,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_fmadd_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_vfmaddsd3_mask ( (__v2df) __W,
          (__v2df) __A,
          (__v2df) __B,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_fmadd_sd (__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
 return (__m128d) __builtin_ia32_vfmaddsd3_maskz ( (__v2df) __A,
          (__v2df) __B,
          (__v2df) __C,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask3_fmadd_sd (__m128d __W, __m128d __X, __m128d __Y, __mmask8 __U)
{
 return (__m128d) __builtin_ia32_vfmaddsd3_mask3 ((__v2df) __W,
          (__v2df) __X,
          (__v2df) __Y,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_fmsub_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_vfmaddsd3_mask ( (__v2df) __W,
          (__v2df) __A,
          -(__v2df) __B,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_fmsub_sd (__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
 return (__m128d) __builtin_ia32_vfmaddsd3_maskz ( (__v2df) __A,
          (__v2df) __B,
          -(__v2df) __C,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask3_fmsub_sd (__m128d __W, __m128d __X, __m128d __Y, __mmask8 __U)
{
 return (__m128d) __builtin_ia32_vfmsubsd3_mask3 ((__v2df) __W,
          (__v2df) __X,
          (__v2df) __Y,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_fnmadd_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_vfmaddsd3_mask ( (__v2df) __W,
          -(__v2df) __A,
          (__v2df) __B,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_fnmadd_sd (__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
 return (__m128d) __builtin_ia32_vfmaddsd3_maskz ( -(__v2df) __A,
          (__v2df) __B,
          (__v2df) __C,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask3_fnmadd_sd (__m128d __W, __m128d __X, __m128d __Y, __mmask8 __U)
{
 return (__m128d) __builtin_ia32_vfmaddsd3_mask3 (-(__v2df) __W,
          (__v2df) __X,
          (__v2df) __Y,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_fnmsub_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
 return (__m128d) __builtin_ia32_vfmaddsd3_mask ( (__v2df) __W,
          -(__v2df) __A,
          -(__v2df) __B,
          (__mmask8) __U,
          0x04);
}







static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_fnmsub_sd (__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
 return (__m128d) __builtin_ia32_vfmaddsd3_maskz ( -(__v2df) __A,
          (__v2df) __B,
          -(__v2df) __C,
          (__mmask8) __U,
          0x04);
}
# 8808 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask3_fnmsub_sd (__m128d __W, __m128d __X, __m128d __Y, __mmask8 __U)
{
 return (__m128d) __builtin_ia32_vfnmsubsd3_mask3 ((__v2df) (__W),
          (__v2df) __X,
          (__v2df) (__Y),
          (__mmask8) __U,
          0x04);
}
# 8868 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutexvar_pd (__m512i __X, __m512d __Y)
{
  return (__m512d) __builtin_ia32_permvardf512_mask ((__v8df) __Y,
                 (__v8di) __X,
                 (__v8df) _mm512_undefined_pd (),
                 (__mmask8) -1);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_permutexvar_pd (__m512d __W, __mmask8 __U, __m512i __X, __m512d __Y)
{
  return (__m512d) __builtin_ia32_permvardf512_mask ((__v8df) __Y,
                 (__v8di) __X,
                 (__v8df) __W,
                 (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_permutexvar_pd (__mmask8 __U, __m512i __X, __m512d __Y)
{
  return (__m512d) __builtin_ia32_permvardf512_mask ((__v8df) __Y,
                 (__v8di) __X,
                 (__v8df) _mm512_setzero_pd (),
                 (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_permutexvar_epi64 (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvardi512_mask ((__v8di) __Y,
                 (__v8di) __X,
                 (__v8di) _mm512_setzero_si512 (),
                 __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutexvar_epi64 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvardi512_mask ((__v8di) __Y,
                 (__v8di) __X,
                 (__v8di) _mm512_undefined_epi32 (),
                 (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_permutexvar_epi64 (__m512i __W, __mmask8 __M, __m512i __X,
             __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvardi512_mask ((__v8di) __Y,
                 (__v8di) __X,
                 (__v8di) __W,
                 __M);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutexvar_ps (__m512i __X, __m512 __Y)
{
  return (__m512) __builtin_ia32_permvarsf512_mask ((__v16sf) __Y,
                (__v16si) __X,
                (__v16sf) _mm512_undefined_ps (),
                (__mmask16) -1);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_permutexvar_ps (__m512 __W, __mmask16 __U, __m512i __X, __m512 __Y)
{
  return (__m512) __builtin_ia32_permvarsf512_mask ((__v16sf) __Y,
                (__v16si) __X,
                (__v16sf) __W,
                (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_permutexvar_ps (__mmask16 __U, __m512i __X, __m512 __Y)
{
  return (__m512) __builtin_ia32_permvarsf512_mask ((__v16sf) __Y,
                (__v16si) __X,
                (__v16sf) _mm512_setzero_ps (),
                (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_permutexvar_epi32 (__mmask16 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvarsi512_mask ((__v16si) __Y,
                 (__v16si) __X,
                 (__v16si) _mm512_setzero_si512 (),
                 __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutexvar_epi32 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvarsi512_mask ((__v16si) __Y,
                 (__v16si) __X,
                 (__v16si) _mm512_undefined_epi32 (),
                 (__mmask16) -1);
}



static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_permutexvar_epi32 (__m512i __W, __mmask16 __M, __m512i __X,
             __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvarsi512_mask ((__v16si) __Y,
                 (__v16si) __X,
                 (__v16si) __W,
                 __M);
}



static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_kand (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kandhi ((__mmask16) __A, (__mmask16) __B);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_kandn (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kandnhi ((__mmask16) __A, (__mmask16) __B);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_kor (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_korhi ((__mmask16) __A, (__mmask16) __B);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_kortestc (__mmask16 __A, __mmask16 __B)
{
  return __builtin_ia32_kortestchi ((__mmask16) __A, (__mmask16) __B);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_kortestz (__mmask16 __A, __mmask16 __B)
{
  return __builtin_ia32_kortestzhi ((__mmask16) __A, (__mmask16) __B);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_kunpackb (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kunpckhi ((__mmask16) __A, (__mmask16) __B);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_kxnor (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kxnorhi ((__mmask16) __A, (__mmask16) __B);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_kxor (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kxorhi ((__mmask16) __A, (__mmask16) __B);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_stream_si512 (__m512i * __P, __m512i __A)
{
  typedef __v8di __v8di_aligned __attribute__((aligned(64)));
  __builtin_nontemporal_store((__v8di_aligned)__A, (__v8di_aligned*)__P);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_stream_load_si512 (void *__P)
{
  typedef __v8di __v8di_aligned __attribute__((aligned(64)));
  return (__m512i) __builtin_nontemporal_load((const __v8di_aligned *)__P);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_stream_pd (double *__P, __m512d __A)
{
  typedef __v8df __v8df_aligned __attribute__((aligned(64)));
  __builtin_nontemporal_store((__v8df_aligned)__A, (__v8df_aligned*)__P);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_stream_ps (float *__P, __m512 __A)
{
  typedef __v16sf __v16sf_aligned __attribute__((aligned(64)));
  __builtin_nontemporal_store((__v16sf_aligned)__A, (__v16sf_aligned*)__P);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_compress_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_compressdf512_mask ((__v8df) __A,
                  (__v8df) __W,
                  (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_compress_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_compressdf512_mask ((__v8df) __A,
                  (__v8df)
                  _mm512_setzero_pd (),
                  (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_compress_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_compressdi512_mask ((__v8di) __A,
                  (__v8di) __W,
                  (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_compress_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_compressdi512_mask ((__v8di) __A,
                  (__v8di)
                  _mm512_setzero_si512 (),
                  (__mmask8) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_compress_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_compresssf512_mask ((__v16sf) __A,
                 (__v16sf) __W,
                 (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_compress_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_compresssf512_mask ((__v16sf) __A,
                 (__v16sf)
                 _mm512_setzero_ps (),
                 (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_compress_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_compresssi512_mask ((__v16si) __A,
                  (__v16si) __W,
                  (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_compress_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_compresssi512_mask ((__v16si) __A,
                  (__v16si)
                  _mm512_setzero_si512 (),
                  (__mmask16) __U);
}
# 9170 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_movehdup_ps (__m512 __A)
{
  return (__m512)__builtin_shufflevector((__v16sf)__A, (__v16sf)__A,
                         1, 1, 3, 3, 5, 5, 7, 7, 9, 9, 11, 11, 13, 13, 15, 15);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_movehdup_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_movehdup_ps(__A),
                                             (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_movehdup_ps (__mmask16 __U, __m512 __A)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_movehdup_ps(__A),
                                             (__v16sf)_mm512_setzero_ps());
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_moveldup_ps (__m512 __A)
{
  return (__m512)__builtin_shufflevector((__v16sf)__A, (__v16sf)__A,
                         0, 0, 2, 2, 4, 4, 6, 6, 8, 8, 10, 10, 12, 12, 14, 14);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_moveldup_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_moveldup_ps(__A),
                                             (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_moveldup_ps (__mmask16 __U, __m512 __A)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_moveldup_ps(__A),
                                             (__v16sf)_mm512_setzero_ps());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_move_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  __m128 res = __A;
  res[0] = (__U & 1) ? __B[0] : __W[0];
  return res;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_move_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
  __m128 res = __A;
  res[0] = (__U & 1) ? __B[0] : 0;
  return res;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_move_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  __m128d res = __A;
  res[0] = (__U & 1) ? __B[0] : __W[0];
  return res;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_move_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
  __m128d res = __A;
  res[0] = (__U & 1) ? __B[0] : 0;
  return res;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_store_ss (float * __W, __mmask8 __U, __m128 __A)
{
  __builtin_ia32_storess128_mask ((__v16sf *)__W,
                (__v16sf) _mm512_castps128_ps512(__A),
                (__mmask16) __U & (__mmask16)1);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_store_sd (double * __W, __mmask8 __U, __m128d __A)
{
  __builtin_ia32_storesd128_mask ((__v8df *)__W,
                (__v8df) _mm512_castpd128_pd512(__A),
                (__mmask8) __U & 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_load_ss (__m128 __W, __mmask8 __U, const float* __A)
{
  __m128 src = (__v4sf) __builtin_shufflevector((__v4sf) __W,
                                                (__v4sf) {0.0, 0.0, 0.0, 0.0},
                                                0, 4, 4, 4);

  return (__m128) __builtin_shufflevector(
                           __builtin_ia32_loadss128_mask ((__v16sf *) __A,
                                      (__v16sf) _mm512_castps128_ps512(src),
                                      (__mmask16) __U & 1),
                           _mm512_undefined_ps(), 0, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_load_ss (__mmask8 __U, const float* __A)
{
  return (__m128) __builtin_shufflevector(
                           __builtin_ia32_loadss128_mask ((__v16sf *) __A,
                                      (__v16sf) _mm512_setzero_ps(),
                                      (__mmask16) __U & 1),
                           _mm512_undefined_ps(), 0, 1, 2, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_load_sd (__m128d __W, __mmask8 __U, const double* __A)
{
  __m128d src = (__v2df) __builtin_shufflevector((__v2df) __W,
                                                 (__v2df) {0.0, 0.0}, 0, 2);

  return (__m128d) __builtin_shufflevector(
                            __builtin_ia32_loadsd128_mask ((__v8df *) __A,
                                      (__v8df) _mm512_castpd128_pd512(src),
                                      (__mmask8) __U & 1),
                            _mm512_undefined_pd(), 0, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_load_sd (__mmask8 __U, const double* __A)
{
  return (__m128d) __builtin_shufflevector(
                            __builtin_ia32_loadsd128_mask ((__v8df *) __A,
                                      (__v8df) _mm512_setzero_pd(),
                                      (__mmask8) __U & 1),
                            _mm512_undefined_pd(), 0, 1);
}
# 9341 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_expand_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_expanddf512_mask ((__v8df) __A,
                (__v8df) __W,
                (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_expand_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_expanddf512_mask ((__v8df) __A,
                (__v8df) _mm512_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_expand_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_expanddi512_mask ((__v8di) __A,
                (__v8di) __W,
                (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_expand_epi64 ( __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_expanddi512_mask ((__v8di) __A,
                (__v8di) _mm512_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_expandloadu_pd(__m512d __W, __mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_expandloaddf512_mask ((const __v8df *)__P,
              (__v8df) __W,
              (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_expandloadu_pd(__mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_expandloaddf512_mask ((const __v8df *)__P,
              (__v8df) _mm512_setzero_pd(),
              (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_expandloadu_epi64(__m512i __W, __mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_expandloaddi512_mask ((const __v8di *)__P,
              (__v8di) __W,
              (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_expandloadu_epi64(__mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_expandloaddi512_mask ((const __v8di *)__P,
              (__v8di) _mm512_setzero_pd(),
              (__mmask8) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_expandloadu_ps(__m512 __W, __mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_expandloadsf512_mask ((const __v16sf *)__P,
                   (__v16sf) __W,
                   (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_expandloadu_ps(__mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_expandloadsf512_mask ((const __v16sf *)__P,
                   (__v16sf) _mm512_setzero_ps(),
                   (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_expandloadu_epi32(__m512i __W, __mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_expandloadsi512_mask ((const __v16si *)__P,
              (__v16si) __W,
              (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_expandloadu_epi32(__mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_expandloadsi512_mask ((const __v16si *)__P,
              (__v16si) _mm512_setzero_ps(),
              (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_expand_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_expandsf512_mask ((__v16sf) __A,
               (__v16sf) __W,
               (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_expand_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_expandsf512_mask ((__v16sf) __A,
               (__v16sf) _mm512_setzero_ps(),
               (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_expand_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_expandsi512_mask ((__v16si) __A,
                (__v16si) __W,
                (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_expand_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_expandsi512_mask ((__v16si) __A,
                (__v16si) _mm512_setzero_ps(),
                (__mmask16) __U);
}
# 9484 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtps_pd (__m256 __A)
{
  return (__m512d) __builtin_ia32_cvtps2pd512_mask ((__v8sf) __A,
                (__v8df)
                _mm512_undefined_pd (),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtps_pd (__m512d __W, __mmask8 __U, __m256 __A)
{
  return (__m512d) __builtin_ia32_cvtps2pd512_mask ((__v8sf) __A,
                (__v8df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_cvtps_pd (__mmask8 __U, __m256 __A)
{
  return (__m512d) __builtin_ia32_cvtps2pd512_mask ((__v8sf) __A,
                (__v8df)
                _mm512_setzero_pd (),
                (__mmask8) __U,
                0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtpslo_pd (__m512 __A)
{
  return (__m512) _mm512_cvtps_pd(_mm512_castps512_ps256(__A));
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cvtpslo_pd (__m512d __W, __mmask8 __U, __m512 __A)
{
  return (__m512) _mm512_mask_cvtps_pd(__W, __U, _mm512_castps512_ps256(__A));
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mov_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_selectpd_512 ((__mmask8) __U,
              (__v8df) __A,
              (__v8df) __W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mov_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_selectpd_512 ((__mmask8) __U,
              (__v8df) __A,
              (__v8df) _mm512_setzero_pd ());
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mov_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_selectps_512 ((__mmask16) __U,
             (__v16sf) __A,
             (__v16sf) __W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mov_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_selectps_512 ((__mmask16) __U,
             (__v16sf) __A,
             (__v16sf) _mm512_setzero_ps ());
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_compressstoreu_pd (void *__P, __mmask8 __U, __m512d __A)
{
  __builtin_ia32_compressstoredf512_mask ((__v8df *) __P, (__v8df) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_compressstoreu_epi64 (void *__P, __mmask8 __U, __m512i __A)
{
  __builtin_ia32_compressstoredi512_mask ((__v8di *) __P, (__v8di) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_compressstoreu_ps (void *__P, __mmask16 __U, __m512 __A)
{
  __builtin_ia32_compressstoresf512_mask ((__v16sf *) __P, (__v16sf) __A,
            (__mmask16) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_compressstoreu_epi32 (void *__P, __mmask16 __U, __m512i __A)
{
  __builtin_ia32_compressstoresi512_mask ((__v16si *) __P, (__v16si) __A,
            (__mmask16) __U);
}
# 9603 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_cvtsd_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128d __B)
{
  return __builtin_ia32_cvtsd2ss_round_mask ((__v4sf)(__A),
                                             (__v2df)(__B),
                                             (__v4sf)(__W),
                                             (__mmask8)(__U), 0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_cvtsd_ss (__mmask8 __U, __m128 __A, __m128d __B)
{
  return __builtin_ia32_cvtsd2ss_round_mask ((__v4sf)(__A),
                                             (__v2df)(__B),
                                             (__v4sf)_mm_setzero_ps(),
                                             (__mmask8)(__U), 0x04);
}
# 9676 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_cvtss_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128 __B)
{
  return __builtin_ia32_cvtss2sd_round_mask((__v2df)(__A),
                                              (__v4sf)(__B),
                                              (__v2df)(__W),
                                              (__mmask8)(__U), 0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_cvtss_sd (__mmask8 __U, __m128d __A, __m128 __B)
{
  return __builtin_ia32_cvtss2sd_round_mask((__v2df)(__A),
                                              (__v4sf)(__B),
                                              (__v2df)_mm_setzero_pd(),
                                              (__mmask8)(__U), 0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvtu32_sd (__m128d __A, unsigned __B)
{
  return (__m128d) __builtin_ia32_cvtusi2sd32 ((__v2df) __A, __B);
}






static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvtu64_sd (__m128d __A, unsigned long long __B)
{
  return (__m128d) __builtin_ia32_cvtusi2sd64 ((__v2df) __A, __B,
                 0x04);
}






static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvtu32_ss (__m128 __A, unsigned __B)
{
  return (__m128) __builtin_ia32_cvtusi2ss32 ((__v4sf) __A, __B,
                0x04);
}






static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_cvtu64_ss (__m128 __A, unsigned long long __B)
{
  return (__m128) __builtin_ia32_cvtusi2ss64 ((__v4sf) __A, __B,
                0x04);
}


static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_set1_epi32 (__m512i __O, __mmask16 __M, int __A)
{
  return (__m512i) __builtin_ia32_pbroadcastd512_gpr_mask (__A, (__v16si) __O,
                 __M);
}


static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_set1_epi64 (__m512i __O, __mmask8 __M, long long __A)
{
  return (__m512i) __builtin_ia32_pbroadcastq512_gpr_mask (__A, (__v8di) __O,
                 __M);
}


static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set_epi8 (char __e63, char __e62, char __e61, char __e60, char __e59,
    char __e58, char __e57, char __e56, char __e55, char __e54, char __e53,
    char __e52, char __e51, char __e50, char __e49, char __e48, char __e47,
    char __e46, char __e45, char __e44, char __e43, char __e42, char __e41,
    char __e40, char __e39, char __e38, char __e37, char __e36, char __e35,
    char __e34, char __e33, char __e32, char __e31, char __e30, char __e29,
    char __e28, char __e27, char __e26, char __e25, char __e24, char __e23,
    char __e22, char __e21, char __e20, char __e19, char __e18, char __e17,
    char __e16, char __e15, char __e14, char __e13, char __e12, char __e11,
    char __e10, char __e9, char __e8, char __e7, char __e6, char __e5,
    char __e4, char __e3, char __e2, char __e1, char __e0) {

  return __extension__ (__m512i)(__v64qi)
    {__e0, __e1, __e2, __e3, __e4, __e5, __e6, __e7,
     __e8, __e9, __e10, __e11, __e12, __e13, __e14, __e15,
     __e16, __e17, __e18, __e19, __e20, __e21, __e22, __e23,
     __e24, __e25, __e26, __e27, __e28, __e29, __e30, __e31,
     __e32, __e33, __e34, __e35, __e36, __e37, __e38, __e39,
     __e40, __e41, __e42, __e43, __e44, __e45, __e46, __e47,
     __e48, __e49, __e50, __e51, __e52, __e53, __e54, __e55,
     __e56, __e57, __e58, __e59, __e60, __e61, __e62, __e63};
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set_epi16(short __e31, short __e30, short __e29, short __e28,
    short __e27, short __e26, short __e25, short __e24, short __e23,
    short __e22, short __e21, short __e20, short __e19, short __e18,
    short __e17, short __e16, short __e15, short __e14, short __e13,
    short __e12, short __e11, short __e10, short __e9, short __e8,
    short __e7, short __e6, short __e5, short __e4, short __e3,
    short __e2, short __e1, short __e0) {
  return __extension__ (__m512i)(__v32hi)
    {__e0, __e1, __e2, __e3, __e4, __e5, __e6, __e7,
     __e8, __e9, __e10, __e11, __e12, __e13, __e14, __e15,
     __e16, __e17, __e18, __e19, __e20, __e21, __e22, __e23,
     __e24, __e25, __e26, __e27, __e28, __e29, __e30, __e31 };
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set_epi32 (int __A, int __B, int __C, int __D,
     int __E, int __F, int __G, int __H,
     int __I, int __J, int __K, int __L,
     int __M, int __N, int __O, int __P)
{
  return __extension__ (__m512i)(__v16si)
  { __P, __O, __N, __M, __L, __K, __J, __I,
    __H, __G, __F, __E, __D, __C, __B, __A };
}






static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set_epi64 (long long __A, long long __B, long long __C,
     long long __D, long long __E, long long __F,
     long long __G, long long __H)
{
  return __extension__ (__m512i) (__v8di)
  { __H, __G, __F, __E, __D, __C, __B, __A };
}




static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set_pd (double __A, double __B, double __C, double __D,
        double __E, double __F, double __G, double __H)
{
  return __extension__ (__m512d)
  { __H, __G, __F, __E, __D, __C, __B, __A };
}




static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set_ps (float __A, float __B, float __C, float __D,
        float __E, float __F, float __G, float __H,
        float __I, float __J, float __K, float __L,
        float __M, float __N, float __O, float __P)
{
  return __extension__ (__m512)
  { __P, __O, __N, __M, __L, __K, __J, __I,
    __H, __G, __F, __E, __D, __C, __B, __A };
}





static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_abs_ps(__m512 __A)
{
  return (__m512)_mm512_and_epi32(_mm512_set1_epi32(0x7FFFFFFF),(__m512i)__A) ;
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_abs_ps(__m512 __W, __mmask16 __K, __m512 __A)
{
  return (__m512)_mm512_mask_and_epi32((__m512i)__W, __K, _mm512_set1_epi32(0x7FFFFFFF),(__m512i)__A) ;
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_abs_pd(__m512d __A)
{
  return (__m512d)_mm512_and_epi64(_mm512_set1_epi64(0x7FFFFFFFFFFFFFFF),(__v8di)__A) ;
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_abs_pd(__m512d __W, __mmask8 __K, __m512d __A)
{
  return (__m512d)_mm512_mask_and_epi64((__v8di)__W, __K, _mm512_set1_epi64(0x7FFFFFFFFFFFFFFF),(__v8di)__A);
}
# 9912 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f"))) _mm512_reduce_add_epi64(__m512i __W) {
  __extension__({ __m256i Vec256 = __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 0, 1, 2, 3) + __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 4, 5, 6, 7); __m128i Vec128 = __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 0, 1) + __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 0, -1) + __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 1, -1); return Vec128[0]; });
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f"))) _mm512_reduce_mul_epi64(__m512i __W) {
  __extension__({ __m256i Vec256 = __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 0, 1, 2, 3) * __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 4, 5, 6, 7); __m128i Vec128 = __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 0, 1) * __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 0, -1) * __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 1, -1); return Vec128[0]; });
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f"))) _mm512_reduce_and_epi64(__m512i __W) {
  __extension__({ __m256i Vec256 = __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 0, 1, 2, 3) & __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 4, 5, 6, 7); __m128i Vec128 = __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 0, 1) & __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 0, -1) & __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 1, -1); return Vec128[0]; });
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f"))) _mm512_reduce_or_epi64(__m512i __W) {
  __extension__({ __m256i Vec256 = __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 0, 1, 2, 3) | __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 4, 5, 6, 7); __m128i Vec128 = __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 0, 1) | __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 0, -1) | __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 1, -1); return Vec128[0]; });
}

static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("avx512f"))) _mm512_reduce_add_pd(__m512d __W) {
  __extension__({ __m256d Vec256 = __builtin_shufflevector( (__v8df)__W, (__v8df)__W, 0, 1, 2, 3) + __builtin_shufflevector( (__v8df)__W, (__v8df)__W, 4, 5, 6, 7); __m128d Vec128 = __builtin_shufflevector( (__v4df)Vec256, (__v4df)Vec256, 0, 1) + __builtin_shufflevector( (__v4df)Vec256, (__v4df)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2df)Vec128, (__v2df)Vec128, 0, -1) + __builtin_shufflevector((__v2df)Vec128, (__v2df)Vec128, 1, -1); return Vec128[0]; });
}

static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("avx512f"))) _mm512_reduce_mul_pd(__m512d __W) {
  __extension__({ __m256d Vec256 = __builtin_shufflevector( (__v8df)__W, (__v8df)__W, 0, 1, 2, 3) * __builtin_shufflevector( (__v8df)__W, (__v8df)__W, 4, 5, 6, 7); __m128d Vec128 = __builtin_shufflevector( (__v4df)Vec256, (__v4df)Vec256, 0, 1) * __builtin_shufflevector( (__v4df)Vec256, (__v4df)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2df)Vec128, (__v2df)Vec128, 0, -1) * __builtin_shufflevector((__v2df)Vec128, (__v2df)Vec128, 1, -1); return Vec128[0]; });
}
# 9955 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_add_epi64(__mmask8 __M, __m512i __W) {
  __extension__({ __W = __builtin_ia32_selectq_512( (__mmask8)__M, (__v8di)__W, (__v8di)_mm512_set1_epi64(0)); __extension__({ __m256i Vec256 = __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 0, 1, 2, 3) + __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 4, 5, 6, 7); __m128i Vec128 = __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 0, 1) + __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 0, -1) + __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 1, -1); return Vec128[0]; }); });
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_mul_epi64(__mmask8 __M, __m512i __W) {
  __extension__({ __W = __builtin_ia32_selectq_512( (__mmask8)__M, (__v8di)__W, (__v8di)_mm512_set1_epi64(1)); __extension__({ __m256i Vec256 = __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 0, 1, 2, 3) * __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 4, 5, 6, 7); __m128i Vec128 = __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 0, 1) * __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 0, -1) * __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 1, -1); return Vec128[0]; }); });
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_and_epi64(__mmask8 __M, __m512i __W) {
  __extension__({ __W = __builtin_ia32_selectq_512( (__mmask8)__M, (__v8di)__W, (__v8di)_mm512_set1_epi64(0xFFFFFFFFFFFFFFFF)); __extension__({ __m256i Vec256 = __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 0, 1, 2, 3) & __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 4, 5, 6, 7); __m128i Vec128 = __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 0, 1) & __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 0, -1) & __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 1, -1); return Vec128[0]; }); });

}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_or_epi64(__mmask8 __M, __m512i __W) {
  __extension__({ __W = __builtin_ia32_selectq_512( (__mmask8)__M, (__v8di)__W, (__v8di)_mm512_set1_epi64(0)); __extension__({ __m256i Vec256 = __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 0, 1, 2, 3) | __builtin_shufflevector( (__v8di)__W, (__v8di)__W, 4, 5, 6, 7); __m128i Vec128 = __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 0, 1) | __builtin_shufflevector( (__v4di)Vec256, (__v4di)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 0, -1) | __builtin_shufflevector((__v2di)Vec128, (__v2di)Vec128, 1, -1); return Vec128[0]; }); });

}

static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_add_pd(__mmask8 __M, __m512d __W) {
  __extension__({ __W = __builtin_ia32_selectpd_512( (__mmask8)__M, (__v8df)__W, (__v8df)_mm512_set1_pd(0)); __extension__({ __m256d Vec256 = __builtin_shufflevector( (__v8df)__W, (__v8df)__W, 0, 1, 2, 3) + __builtin_shufflevector( (__v8df)__W, (__v8df)__W, 4, 5, 6, 7); __m128d Vec128 = __builtin_shufflevector( (__v4df)Vec256, (__v4df)Vec256, 0, 1) + __builtin_shufflevector( (__v4df)Vec256, (__v4df)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2df)Vec128, (__v2df)Vec128, 0, -1) + __builtin_shufflevector((__v2df)Vec128, (__v2df)Vec128, 1, -1); return Vec128[0]; }); });

}

static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_mul_pd(__mmask8 __M, __m512d __W) {
  __extension__({ __W = __builtin_ia32_selectpd_512( (__mmask8)__M, (__v8df)__W, (__v8df)_mm512_set1_pd(1)); __extension__({ __m256d Vec256 = __builtin_shufflevector( (__v8df)__W, (__v8df)__W, 0, 1, 2, 3) * __builtin_shufflevector( (__v8df)__W, (__v8df)__W, 4, 5, 6, 7); __m128d Vec128 = __builtin_shufflevector( (__v4df)Vec256, (__v4df)Vec256, 0, 1) * __builtin_shufflevector( (__v4df)Vec256, (__v4df)Vec256, 2, 3); Vec128 = __builtin_shufflevector((__v2df)Vec128, (__v2df)Vec128, 0, -1) * __builtin_shufflevector((__v2df)Vec128, (__v2df)Vec128, 1, -1); return Vec128[0]; }); });

}
# 10036 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_add_epi32(__m512i __W) {
  __extension__({ __m256i Vec256 = (__m256i)(__builtin_shufflevector( (__v16si)__W, (__v16si)__W, 0, 1, 2, 3, 4, 5, 6, 7) + __builtin_shufflevector( (__v16si)__W, (__v16si)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128i Vec128 = (__m128i)(__builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 0, 1, 2, 3) + __builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 4, 5, 6, 7)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, 1, -1, -1) + __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 2, 3, -1, -1)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, -1, -1, -1) + __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 1, -1, -1, -1)); return Vec128[0]; });
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_mul_epi32(__m512i __W) {
  __extension__({ __m256i Vec256 = (__m256i)(__builtin_shufflevector( (__v16si)__W, (__v16si)__W, 0, 1, 2, 3, 4, 5, 6, 7) * __builtin_shufflevector( (__v16si)__W, (__v16si)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128i Vec128 = (__m128i)(__builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 0, 1, 2, 3) * __builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 4, 5, 6, 7)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, 1, -1, -1) * __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 2, 3, -1, -1)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, -1, -1, -1) * __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 1, -1, -1, -1)); return Vec128[0]; });
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_and_epi32(__m512i __W) {
  __extension__({ __m256i Vec256 = (__m256i)(__builtin_shufflevector( (__v16si)__W, (__v16si)__W, 0, 1, 2, 3, 4, 5, 6, 7) & __builtin_shufflevector( (__v16si)__W, (__v16si)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128i Vec128 = (__m128i)(__builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 0, 1, 2, 3) & __builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 4, 5, 6, 7)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, 1, -1, -1) & __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 2, 3, -1, -1)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, -1, -1, -1) & __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 1, -1, -1, -1)); return Vec128[0]; });
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_or_epi32(__m512i __W) {
  __extension__({ __m256i Vec256 = (__m256i)(__builtin_shufflevector( (__v16si)__W, (__v16si)__W, 0, 1, 2, 3, 4, 5, 6, 7) | __builtin_shufflevector( (__v16si)__W, (__v16si)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128i Vec128 = (__m128i)(__builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 0, 1, 2, 3) | __builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 4, 5, 6, 7)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, 1, -1, -1) | __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 2, 3, -1, -1)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, -1, -1, -1) | __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 1, -1, -1, -1)); return Vec128[0]; });
}

static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_add_ps(__m512 __W) {
  __extension__({ __m256 Vec256 = (__m256)(__builtin_shufflevector( (__v16sf)__W, (__v16sf)__W, 0, 1, 2, 3, 4, 5, 6, 7) + __builtin_shufflevector( (__v16sf)__W, (__v16sf)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128 Vec128 = (__m128)(__builtin_shufflevector( (__v8sf)Vec256, (__v8sf)Vec256, 0, 1, 2, 3) + __builtin_shufflevector( (__v8sf)Vec256, (__v8sf)Vec256, 4, 5, 6, 7)); Vec128 = (__m128)(__builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 0, 1, -1, -1) + __builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 2, 3, -1, -1)); Vec128 = (__m128)(__builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 0, -1, -1, -1) + __builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 1, -1, -1, -1)); return Vec128[0]; });
}

static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_mul_ps(__m512 __W) {
  __extension__({ __m256 Vec256 = (__m256)(__builtin_shufflevector( (__v16sf)__W, (__v16sf)__W, 0, 1, 2, 3, 4, 5, 6, 7) * __builtin_shufflevector( (__v16sf)__W, (__v16sf)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128 Vec128 = (__m128)(__builtin_shufflevector( (__v8sf)Vec256, (__v8sf)Vec256, 0, 1, 2, 3) * __builtin_shufflevector( (__v8sf)Vec256, (__v8sf)Vec256, 4, 5, 6, 7)); Vec128 = (__m128)(__builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 0, 1, -1, -1) * __builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 2, 3, -1, -1)); Vec128 = (__m128)(__builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 0, -1, -1, -1) * __builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 1, -1, -1, -1)); return Vec128[0]; });
}
# 10085 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_add_epi32( __mmask16 __M, __m512i __W) {
  __extension__({ __W = (__m512i)__builtin_ia32_selectd_512( (__mmask16)__M, (__v16si)__W, (__v16si)_mm512_set1_epi32(0)); __extension__({ __m256i Vec256 = (__m256i)(__builtin_shufflevector( (__v16si)__W, (__v16si)__W, 0, 1, 2, 3, 4, 5, 6, 7) + __builtin_shufflevector( (__v16si)__W, (__v16si)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128i Vec128 = (__m128i)(__builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 0, 1, 2, 3) + __builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 4, 5, 6, 7)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, 1, -1, -1) + __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 2, 3, -1, -1)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, -1, -1, -1) + __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 1, -1, -1, -1)); return Vec128[0]; }); });
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_mul_epi32( __mmask16 __M, __m512i __W) {
  __extension__({ __W = (__m512i)__builtin_ia32_selectd_512( (__mmask16)__M, (__v16si)__W, (__v16si)_mm512_set1_epi32(1)); __extension__({ __m256i Vec256 = (__m256i)(__builtin_shufflevector( (__v16si)__W, (__v16si)__W, 0, 1, 2, 3, 4, 5, 6, 7) * __builtin_shufflevector( (__v16si)__W, (__v16si)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128i Vec128 = (__m128i)(__builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 0, 1, 2, 3) * __builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 4, 5, 6, 7)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, 1, -1, -1) * __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 2, 3, -1, -1)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, -1, -1, -1) * __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 1, -1, -1, -1)); return Vec128[0]; }); });
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_and_epi32( __mmask16 __M, __m512i __W) {
  __extension__({ __W = (__m512i)__builtin_ia32_selectd_512( (__mmask16)__M, (__v16si)__W, (__v16si)_mm512_set1_epi32(0xFFFFFFFF)); __extension__({ __m256i Vec256 = (__m256i)(__builtin_shufflevector( (__v16si)__W, (__v16si)__W, 0, 1, 2, 3, 4, 5, 6, 7) & __builtin_shufflevector( (__v16si)__W, (__v16si)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128i Vec128 = (__m128i)(__builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 0, 1, 2, 3) & __builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 4, 5, 6, 7)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, 1, -1, -1) & __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 2, 3, -1, -1)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, -1, -1, -1) & __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 1, -1, -1, -1)); return Vec128[0]; }); });

}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_or_epi32(__mmask16 __M, __m512i __W) {
  __extension__({ __W = (__m512i)__builtin_ia32_selectd_512( (__mmask16)__M, (__v16si)__W, (__v16si)_mm512_set1_epi32(0)); __extension__({ __m256i Vec256 = (__m256i)(__builtin_shufflevector( (__v16si)__W, (__v16si)__W, 0, 1, 2, 3, 4, 5, 6, 7) | __builtin_shufflevector( (__v16si)__W, (__v16si)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128i Vec128 = (__m128i)(__builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 0, 1, 2, 3) | __builtin_shufflevector( (__v8si)Vec256, (__v8si)Vec256, 4, 5, 6, 7)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, 1, -1, -1) | __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 2, 3, -1, -1)); Vec128 = (__m128i)(__builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 0, -1, -1, -1) | __builtin_shufflevector( (__v4si)Vec128, (__v4si)Vec128, 1, -1, -1, -1)); return Vec128[0]; }); });
}

static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_add_ps(__mmask16 __M, __m512 __W) {
  __extension__({ __W = (__m512)__builtin_ia32_selectps_512( (__mmask16)__M, (__v16sf)__W, (__v16sf)_mm512_set1_ps(0)); __extension__({ __m256 Vec256 = (__m256)(__builtin_shufflevector( (__v16sf)__W, (__v16sf)__W, 0, 1, 2, 3, 4, 5, 6, 7) + __builtin_shufflevector( (__v16sf)__W, (__v16sf)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128 Vec128 = (__m128)(__builtin_shufflevector( (__v8sf)Vec256, (__v8sf)Vec256, 0, 1, 2, 3) + __builtin_shufflevector( (__v8sf)Vec256, (__v8sf)Vec256, 4, 5, 6, 7)); Vec128 = (__m128)(__builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 0, 1, -1, -1) + __builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 2, 3, -1, -1)); Vec128 = (__m128)(__builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 0, -1, -1, -1) + __builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 1, -1, -1, -1)); return Vec128[0]; }); });
}

static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_mul_ps(__mmask16 __M, __m512 __W) {
  __extension__({ __W = (__m512)__builtin_ia32_selectps_512( (__mmask16)__M, (__v16sf)__W, (__v16sf)_mm512_set1_ps(1)); __extension__({ __m256 Vec256 = (__m256)(__builtin_shufflevector( (__v16sf)__W, (__v16sf)__W, 0, 1, 2, 3, 4, 5, 6, 7) * __builtin_shufflevector( (__v16sf)__W, (__v16sf)__W, 8, 9, 10, 11, 12, 13, 14, 15)); __m128 Vec128 = (__m128)(__builtin_shufflevector( (__v8sf)Vec256, (__v8sf)Vec256, 0, 1, 2, 3) * __builtin_shufflevector( (__v8sf)Vec256, (__v8sf)Vec256, 4, 5, 6, 7)); Vec128 = (__m128)(__builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 0, 1, -1, -1) * __builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 2, 3, -1, -1)); Vec128 = (__m128)(__builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 0, -1, -1, -1) * __builtin_shufflevector( (__v4sf)Vec128, (__v4sf)Vec128, 1, -1, -1, -1)); return Vec128[0]; }); });
}
# 10160 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_max_epi64(__m512i __V) {
  __extension__({ __V = _mm512_max_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_max_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; });
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_max_epu64(__m512i __V) {
  __extension__({ __V = _mm512_max_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_max_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; });
}

static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_max_pd(__m512d __V) {
  __extension__({ __V = _mm512_max_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_max_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; });
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f"))) _mm512_reduce_min_epi64
(__m512i __V) {
  __extension__({ __V = _mm512_min_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_min_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; });
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_min_epu64(__m512i __V) {
  __extension__({ __V = _mm512_min_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_min_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; });
}

static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_min_pd(__m512d __V) {
  __extension__({ __V = _mm512_min_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_min_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; });
}
# 10217 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_max_epi64(__mmask8 __M, __m512i __V) {
  __extension__({ __V = (__m512i)__builtin_ia32_selectq_512( (__mmask8)__M, (__v8di)__V, (__v8di)_mm512_set1_epi64(0x8000000000000000)); __extension__({ __V = _mm512_max_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_max_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; }); });

}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_max_epu64(__mmask8 __M, __m512i __V) {
  __extension__({ __V = (__m512i)__builtin_ia32_selectq_512( (__mmask8)__M, (__v8di)__V, (__v8di)_mm512_set1_epi64(0x0000000000000000)); __extension__({ __V = _mm512_max_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_max_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; }); });

}

static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_max_pd(__mmask8 __M, __m512d __V) {
  __extension__({ __V = (__m512d)__builtin_ia32_selectpd_512( (__mmask8)__M, (__v8df)__V, (__v8df)-_mm512_set1_pd(__builtin_inf())); __extension__({ __V = _mm512_max_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_max_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; }); });

}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_min_epi64(__mmask8 __M, __m512i __V) {
  __extension__({ __V = (__m512i)__builtin_ia32_selectq_512( (__mmask8)__M, (__v8di)__V, (__v8di)_mm512_set1_epi64(0x7FFFFFFFFFFFFFFF)); __extension__({ __V = _mm512_min_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_min_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_epi64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; }); });

}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_min_epu64(__mmask8 __M, __m512i __V) {
  __extension__({ __V = (__m512i)__builtin_ia32_selectq_512( (__mmask8)__M, (__v8di)__V, (__v8di)_mm512_set1_epi64(0xFFFFFFFFFFFFFFFF)); __extension__({ __V = _mm512_min_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_min_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_epu64( (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v8di)__V, (__v8di)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; }); });

}

static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_min_pd(__mmask8 __M, __m512d __V) {
  __extension__({ __V = (__m512d)__builtin_ia32_selectpd_512( (__mmask8)__M, (__v8df)__V, (__v8df)_mm512_set1_pd(__builtin_inf())); __extension__({ __V = _mm512_min_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, 1, 2, 3, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 4, 5, 6, 7, -1, -1, -1, -1)); __V = _mm512_min_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, 1, -1, -1, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 2, 3, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_pd( (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 0, -1, -1, -1, -1, -1, -1, -1), (__m512d)__builtin_shufflevector( (__v8df)__V, (__v8df)__V, 1, -1, -1, -1, -1, -1, -1, -1)) ; return __V[0]; }); });

}
# 10307 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f"))) _mm512_reduce_max_epi32(__m512i a) {
  __extension__({ a = _mm512_max_epi32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_max_epi32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_max_epi32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_max_epi32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return a[0]; });
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_max_epu32(__m512i a) {
  __extension__({ a = _mm512_max_epu32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_max_epu32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_max_epu32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_max_epu32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return a[0]; });
}

static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("avx512f"))) _mm512_reduce_max_ps(__m512 a) {
  __extension__({ a = _mm512_max_ps( (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_max_ps( (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_max_ps( (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_max_ps( (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return a[0]; });
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f"))) _mm512_reduce_min_epi32(__m512i a) {
  __extension__({ a = _mm512_min_epi32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_min_epi32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_min_epi32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_min_epi32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return a[0]; });
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_reduce_min_epu32(__m512i a) {
  __extension__({ a = _mm512_min_epu32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_min_epu32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_min_epu32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_min_epu32( (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)a, (__v16si)a, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return a[0]; });
}

static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("avx512f"))) _mm512_reduce_min_ps(__m512 a) {
  __extension__({ a = _mm512_min_ps( (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_min_ps( (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_min_ps( (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); a = _mm512_min_ps( (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)a, (__v16sf)a, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return a[0]; });
}
# 10360 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512fintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_max_epi32(__mmask16 __M, __m512i __V) {
  __extension__({ __V = (__m512i)__builtin_ia32_selectd_512( (__mmask16)__M, (__v16si)__V, (__v16si)_mm512_set1_epi32(0x80000000)); __extension__({ __V = _mm512_max_epi32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_epi32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_epi32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_epi32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return __V[0]; }); });

}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_max_epu32(__mmask16 __M, __m512i __V) {
  __extension__({ __V = (__m512i)__builtin_ia32_selectd_512( (__mmask16)__M, (__v16si)__V, (__v16si)_mm512_set1_epi32(0x00000000)); __extension__({ __V = _mm512_max_epu32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_epu32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_epu32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_epu32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return __V[0]; }); });

}

static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_max_ps(__mmask16 __M, __m512 __V) {
  __extension__({ __V = (__m512)__builtin_ia32_selectps_512( (__mmask16)__M, (__v16sf)__V, (__v16sf)-_mm512_set1_ps(__builtin_inff())); __extension__({ __V = _mm512_max_ps( (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_ps( (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_ps( (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_max_ps( (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return __V[0]; }); });

}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_min_epi32(__mmask16 __M, __m512i __V) {
  __extension__({ __V = (__m512i)__builtin_ia32_selectd_512( (__mmask16)__M, (__v16si)__V, (__v16si)_mm512_set1_epi32(0x7FFFFFFF)); __extension__({ __V = _mm512_min_epi32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_epi32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_epi32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_epi32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return __V[0]; }); });

}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_min_epu32(__mmask16 __M, __m512i __V) {
  __extension__({ __V = (__m512i)__builtin_ia32_selectd_512( (__mmask16)__M, (__v16si)__V, (__v16si)_mm512_set1_epi32(0xFFFFFFFF)); __extension__({ __V = _mm512_min_epu32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_epu32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_epu32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_epu32( (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512i)__builtin_shufflevector( (__v16si)__V, (__v16si)__V, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return __V[0]; }); });

}

static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_reduce_min_ps(__mmask16 __M, __m512 __V) {
  __extension__({ __V = (__m512)__builtin_ia32_selectps_512( (__mmask16)__M, (__v16sf)__V, (__v16sf)_mm512_set1_ps(__builtin_inff())); __extension__({ __V = _mm512_min_ps( (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_ps( (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_ps( (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); __V = _mm512_min_ps( (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), (__m512)__builtin_shufflevector( (__v16sf)__V, (__v16sf)__V, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1)); return __V[0]; }); });

}
# 135 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_setzero_di(void) {
  return (__m128i)(__v2di){ 0LL, 0LL};
}



static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpeq_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqd128_mask((__v4si)__a, (__v4si)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpeq_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqd128_mask((__v4si)__a, (__v4si)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpeq_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpeq_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 0,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpeq_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqd256_mask((__v8si)__a, (__v8si)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpeq_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqd256_mask((__v8si)__a, (__v8si)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpeq_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpeq_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 0,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpeq_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq128_mask((__v2di)__a, (__v2di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpeq_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq128_mask((__v2di)__a, (__v2di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpeq_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpeq_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 0,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpeq_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq256_mask((__v4di)__a, (__v4di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpeq_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq256_mask((__v4di)__a, (__v4di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpeq_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpeq_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 0,
                                                __u);
}


static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpge_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpge_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpge_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpge_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 5,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpge_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpge_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpge_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpge_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 5,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpge_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpge_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpge_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpge_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 5,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpge_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpge_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpge_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpge_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 5,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpgt_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtd128_mask((__v4si)__a, (__v4si)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpgt_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtd128_mask((__v4si)__a, (__v4si)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpgt_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpgt_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 6,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpgt_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtd256_mask((__v8si)__a, (__v8si)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpgt_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtd256_mask((__v8si)__a, (__v8si)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpgt_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpgt_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 6,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpgt_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq128_mask((__v2di)__a, (__v2di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpgt_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq128_mask((__v2di)__a, (__v2di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpgt_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpgt_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 6,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpgt_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq256_mask((__v4di)__a, (__v4di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpgt_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq256_mask((__v4di)__a, (__v4di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpgt_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpgt_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 6,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmple_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmple_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmple_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmple_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 2,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmple_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmple_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmple_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmple_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 2,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmple_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmple_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmple_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmple_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 2,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmple_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmple_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmple_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmple_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 2,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmplt_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmplt_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmplt_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmplt_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 1,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmplt_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmplt_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmplt_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmplt_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 1,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmplt_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmplt_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmplt_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmplt_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 1,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmplt_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmplt_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmplt_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmplt_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 1,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpneq_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpneq_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpneq_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpneq_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 4,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpneq_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpneq_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpneq_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpneq_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 4,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpneq_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpneq_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpneq_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpneq_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 4,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpneq_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpneq_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpneq_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpneq_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 4,
                                                __u);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_add_epi32(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_add_epi32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_add_epi32(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_add_epi32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_add_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_add_epi64(__A, __B),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_add_epi64(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_add_epi64(__A, __B),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sub_epi32(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_sub_epi32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sub_epi32(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_sub_epi32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sub_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_sub_epi64(__A, __B),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sub_epi64(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_sub_epi64(__A, __B),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_add_epi32(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_add_epi32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_add_epi32(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_add_epi32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_add_epi64(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_add_epi64(__A, __B),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_add_epi64(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_add_epi64(__A, __B),
                                             (__v2di)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sub_epi32(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_sub_epi32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sub_epi32(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_sub_epi32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sub_epi64(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_sub_epi64(__A, __B),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sub_epi64(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_sub_epi64(__A, __B),
                                             (__v2di)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mul_epi32(__m256i __W, __mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__M,
                                             (__v4di)_mm256_mul_epi32(__X, __Y),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mul_epi32(__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__M,
                                             (__v4di)_mm256_mul_epi32(__X, __Y),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mul_epi32(__m128i __W, __mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__M,
                                             (__v2di)_mm_mul_epi32(__X, __Y),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mul_epi32(__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__M,
                                             (__v2di)_mm_mul_epi32(__X, __Y),
                                             (__v2di)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mul_epu32(__m256i __W, __mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__M,
                                             (__v4di)_mm256_mul_epu32(__X, __Y),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mul_epu32(__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__M,
                                             (__v4di)_mm256_mul_epu32(__X, __Y),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mul_epu32(__m128i __W, __mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__M,
                                             (__v2di)_mm_mul_epu32(__X, __Y),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mul_epu32(__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__M,
                                             (__v2di)_mm_mul_epu32(__X, __Y),
                                             (__v2di)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mullo_epi32(__mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                             (__v8si)_mm256_mullo_epi32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mullo_epi32(__m256i __W, __mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                             (__v8si)_mm256_mullo_epi32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mullo_epi32(__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__M,
                                             (__v4si)_mm_mullo_epi32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mullo_epi32(__m128i __W, __mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__M,
                                             (__v4si)_mm_mullo_epi32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_and_epi32(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_and_si256(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_and_epi32(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)_mm256_mask_and_epi32(_mm256_setzero_si256(), __U, __A, __B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_and_epi32(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_and_si128(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_and_epi32(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)_mm_mask_and_epi32(_mm_setzero_si128(), __U, __A, __B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_andnot_epi32(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                          (__v8si)_mm256_andnot_si256(__A, __B),
                                          (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_andnot_epi32(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)_mm256_mask_andnot_epi32(_mm256_setzero_si256(),
                                           __U, __A, __B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_andnot_epi32(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_andnot_si128(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_andnot_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)_mm_mask_andnot_epi32(_mm_setzero_si128(), __U, __A, __B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_or_epi32 (__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_or_si256(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_or_epi32(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)_mm256_mask_or_epi32(_mm256_setzero_si256(), __U, __A, __B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_or_epi32(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_or_si128(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_or_epi32(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)_mm_mask_or_epi32(_mm_setzero_si128(), __U, __A, __B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_xor_epi32(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_xor_si256(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_xor_epi32(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)_mm256_mask_xor_epi32(_mm256_setzero_si256(), __U, __A, __B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_xor_epi32(__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_xor_si128(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_xor_epi32(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)_mm_mask_xor_epi32(_mm_setzero_si128(), __U, __A, __B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_and_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_and_si256(__A, __B),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_and_epi64(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)_mm256_mask_and_epi64(_mm256_setzero_si256(), __U, __A, __B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_and_epi64(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_and_si128(__A, __B),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_and_epi64(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)_mm_mask_and_epi64(_mm_setzero_si128(), __U, __A, __B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_andnot_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                          (__v4di)_mm256_andnot_si256(__A, __B),
                                          (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_andnot_epi64(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)_mm256_mask_andnot_epi64(_mm256_setzero_si256(),
                                           __U, __A, __B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_andnot_epi64(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_andnot_si128(__A, __B),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_andnot_epi64(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)_mm_mask_andnot_epi64(_mm_setzero_si128(), __U, __A, __B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_or_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_or_si256(__A, __B),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_or_epi64(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)_mm256_mask_or_epi64(_mm256_setzero_si256(), __U, __A, __B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_or_epi64(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_or_si128(__A, __B),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_or_epi64(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)_mm_mask_or_epi64(_mm_setzero_si128(), __U, __A, __B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_xor_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_xor_si256(__A, __B),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_xor_epi64(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)_mm256_mask_xor_epi64(_mm256_setzero_si256(), __U, __A, __B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_xor_epi64(__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_xor_si128(__A, __B),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_xor_epi64(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)_mm_mask_xor_epi64(_mm_setzero_si128(), __U, __A, __B);
}
# 1190 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmadd_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_mask ((__v2df) __A,
                                                    (__v2df) __B,
                                                    (__v2df) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmadd_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_mask3 ((__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmadd_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_maskz ((__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmsub_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_mask ((__v2df) __A,
                                                    (__v2df) __B,
                                                    -(__v2df) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmsub_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_maskz ((__v2df) __A,
                                                     (__v2df) __B,
                                                     -(__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fnmadd_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_mask3 (-(__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fnmadd_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_maskz (-(__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fnmsub_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_maskz (-(__v2df) __A,
                                                     (__v2df) __B,
                                                     -(__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmadd_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_mask ((__v4df) __A,
                                                    (__v4df) __B,
                                                    (__v4df) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmadd_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_mask3 ((__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmadd_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_maskz ((__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmsub_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_mask ((__v4df) __A,
                                                    (__v4df) __B,
                                                    -(__v4df) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmsub_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_maskz ((__v4df) __A,
                                                     (__v4df) __B,
                                                     -(__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fnmadd_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_mask3 (-(__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fnmadd_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_maskz (-(__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fnmsub_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_maskz (-(__v4df) __A,
                                                     (__v4df) __B,
                                                     -(__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmadd_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_mask ((__v4sf) __A,
                                                   (__v4sf) __B,
                                                   (__v4sf) __C,
                                                   (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmadd_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmaddps128_mask3 ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmadd_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_maskz ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmsub_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_mask ((__v4sf) __A,
                                                   (__v4sf) __B,
                                                   -(__v4sf) __C,
                                                   (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmsub_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_maskz ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    -(__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fnmadd_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmaddps128_mask3 (-(__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fnmadd_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_maskz (-(__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fnmsub_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_maskz (-(__v4sf) __A,
                                                    (__v4sf) __B,
                                                    -(__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmadd_ps(__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_mask ((__v8sf) __A,
                                                   (__v8sf) __B,
                                                   (__v8sf) __C,
                                                   (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmadd_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmaddps256_mask3 ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmadd_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_maskz ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmsub_ps(__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_mask ((__v8sf) __A,
                                                   (__v8sf) __B,
                                                   -(__v8sf) __C,
                                                   (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmsub_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_maskz ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    -(__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fnmadd_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmaddps256_mask3 (-(__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fnmadd_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_maskz (-(__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fnmsub_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_maskz (-(__v8sf) __A,
                                                    (__v8sf) __B,
                                                    -(__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmaddsub_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_mask ((__v2df) __A,
                                                       (__v2df) __B,
                                                       (__v2df) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmaddsub_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_mask3 ((__v2df) __A,
                                                        (__v2df) __B,
                                                        (__v2df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmaddsub_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_maskz ((__v2df) __A,
                                                        (__v2df) __B,
                                                        (__v2df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmsubadd_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_mask ((__v2df) __A,
                                                       (__v2df) __B,
                                                       -(__v2df) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmsubadd_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_maskz ((__v2df) __A,
                                                        (__v2df) __B,
                                                        -(__v2df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmaddsub_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_mask ((__v4df) __A,
                                                       (__v4df) __B,
                                                       (__v4df) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmaddsub_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_mask3 ((__v4df) __A,
                                                        (__v4df) __B,
                                                        (__v4df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmaddsub_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_maskz ((__v4df) __A,
                                                        (__v4df) __B,
                                                        (__v4df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmsubadd_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_mask ((__v4df) __A,
                                                       (__v4df) __B,
                                                       -(__v4df) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmsubadd_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_maskz ((__v4df) __A,
                                                        (__v4df) __B,
                                                        -(__v4df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmaddsub_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_mask ((__v4sf) __A,
                                                      (__v4sf) __B,
                                                      (__v4sf) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmaddsub_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_mask3 ((__v4sf) __A,
                                                       (__v4sf) __B,
                                                       (__v4sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmaddsub_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_maskz ((__v4sf) __A,
                                                       (__v4sf) __B,
                                                       (__v4sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmsubadd_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_mask ((__v4sf) __A,
                                                      (__v4sf) __B,
                                                      -(__v4sf) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmsubadd_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_maskz ((__v4sf) __A,
                                                       (__v4sf) __B,
                                                       -(__v4sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmaddsub_ps(__m256 __A, __mmask8 __U, __m256 __B,
                         __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_mask ((__v8sf) __A,
                                                      (__v8sf) __B,
                                                      (__v8sf) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmaddsub_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_mask3 ((__v8sf) __A,
                                                       (__v8sf) __B,
                                                       (__v8sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmaddsub_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_maskz ((__v8sf) __A,
                                                       (__v8sf) __B,
                                                       (__v8sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmsubadd_ps(__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_mask ((__v8sf) __A,
                                                      (__v8sf) __B,
                                                      -(__v8sf) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmsubadd_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_maskz ((__v8sf) __A,
                                                       (__v8sf) __B,
                                                       -(__v8sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmsub_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmsubpd128_mask3 ((__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmsub_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmsubpd256_mask3 ((__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmsub_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmsubps128_mask3 ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmsub_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmsubps256_mask3 ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmsubadd_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmsubaddpd128_mask3 ((__v2df) __A,
                                                        (__v2df) __B,
                                                        (__v2df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmsubadd_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmsubaddpd256_mask3 ((__v4df) __A,
                                                        (__v4df) __B,
                                                        (__v4df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmsubadd_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmsubaddps128_mask3 ((__v4sf) __A,
                                                       (__v4sf) __B,
                                                       (__v4sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmsubadd_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmsubaddps256_mask3 ((__v8sf) __A,
                                                       (__v8sf) __B,
                                                       (__v8sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fnmadd_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfnmaddpd128_mask ((__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fnmadd_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfnmaddpd256_mask ((__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fnmadd_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfnmaddps128_mask ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fnmadd_ps(__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfnmaddps256_mask ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fnmsub_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfnmsubpd128_mask ((__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fnmsub_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfnmsubpd128_mask3 ((__v2df) __A,
                                                      (__v2df) __B,
                                                      (__v2df) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fnmsub_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfnmsubpd256_mask ((__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fnmsub_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfnmsubpd256_mask3 ((__v4df) __A,
                                                      (__v4df) __B,
                                                      (__v4df) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fnmsub_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfnmsubps128_mask ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fnmsub_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfnmsubps128_mask3 ((__v4sf) __A,
                                                     (__v4sf) __B,
                                                     (__v4sf) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fnmsub_ps(__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfnmsubps256_mask ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fnmsub_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfnmsubps256_mask3 ((__v8sf) __A,
                                                     (__v8sf) __B,
                                                     (__v8sf) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_add_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_add_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_add_pd(__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_add_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_add_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_add_pd(__A, __B),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_add_pd(__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_add_pd(__A, __B),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_add_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_add_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_add_ps(__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_add_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_add_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_add_ps(__A, __B),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_add_ps(__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_add_ps(__A, __B),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_blend_epi32 (__mmask8 __U, __m128i __A, __m128i __W) {
  return (__m128i) __builtin_ia32_selectd_128 ((__mmask8) __U,
                (__v4si) __W,
                (__v4si) __A);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_blend_epi32 (__mmask8 __U, __m256i __A, __m256i __W) {
  return (__m256i) __builtin_ia32_selectd_256 ((__mmask8) __U,
                (__v8si) __W,
                (__v8si) __A);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_blend_pd (__mmask8 __U, __m128d __A, __m128d __W) {
  return (__m128d) __builtin_ia32_selectpd_128 ((__mmask8) __U,
                 (__v2df) __W,
                 (__v2df) __A);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_blend_pd (__mmask8 __U, __m256d __A, __m256d __W) {
  return (__m256d) __builtin_ia32_selectpd_256 ((__mmask8) __U,
                 (__v4df) __W,
                 (__v4df) __A);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_blend_ps (__mmask8 __U, __m128 __A, __m128 __W) {
  return (__m128) __builtin_ia32_selectps_128 ((__mmask8) __U,
                (__v4sf) __W,
                (__v4sf) __A);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_blend_ps (__mmask8 __U, __m256 __A, __m256 __W) {
  return (__m256) __builtin_ia32_selectps_256 ((__mmask8) __U,
                (__v8sf) __W,
                (__v8sf) __A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_blend_epi64 (__mmask8 __U, __m128i __A, __m128i __W) {
  return (__m128i) __builtin_ia32_selectq_128 ((__mmask8) __U,
                (__v2di) __W,
                (__v2di) __A);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_blend_epi64 (__mmask8 __U, __m256i __A, __m256i __W) {
  return (__m256i) __builtin_ia32_selectq_256 ((__mmask8) __U,
                (__v4di) __W,
                (__v4di) __A);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compress_pd (__m128d __W, __mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_compressdf128_mask ((__v2df) __A,
                  (__v2df) __W,
                  (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_compress_pd (__mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_compressdf128_mask ((__v2df) __A,
                  (__v2df)
                  _mm_setzero_pd (),
                  (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compress_pd (__m256d __W, __mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_compressdf256_mask ((__v4df) __A,
                  (__v4df) __W,
                  (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_compress_pd (__mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_compressdf256_mask ((__v4df) __A,
                  (__v4df)
                  _mm256_setzero_pd (),
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compress_epi64 (__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_compressdi128_mask ((__v2di) __A,
                  (__v2di) __W,
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_compress_epi64 (__mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_compressdi128_mask ((__v2di) __A,
                  (__v2di)
                  _mm_setzero_si128 (),
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compress_epi64 (__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_compressdi256_mask ((__v4di) __A,
                  (__v4di) __W,
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_compress_epi64 (__mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_compressdi256_mask ((__v4di) __A,
                  (__v4di)
                  _mm256_setzero_si256 (),
                  (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compress_ps (__m128 __W, __mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_compresssf128_mask ((__v4sf) __A,
                 (__v4sf) __W,
                 (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_compress_ps (__mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_compresssf128_mask ((__v4sf) __A,
                 (__v4sf)
                 _mm_setzero_ps (),
                 (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compress_ps (__m256 __W, __mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_compresssf256_mask ((__v8sf) __A,
                 (__v8sf) __W,
                 (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_compress_ps (__mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_compresssf256_mask ((__v8sf) __A,
                 (__v8sf)
                 _mm256_setzero_ps (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compress_epi32 (__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_compresssi128_mask ((__v4si) __A,
                  (__v4si) __W,
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_compress_epi32 (__mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_compresssi128_mask ((__v4si) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compress_epi32 (__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_compresssi256_mask ((__v8si) __A,
                  (__v8si) __W,
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_compress_epi32 (__mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_compresssi256_mask ((__v8si) __A,
                  (__v8si)
                  _mm256_setzero_si256 (),
                  (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compressstoreu_pd (void *__P, __mmask8 __U, __m128d __A) {
  __builtin_ia32_compressstoredf128_mask ((__v2df *) __P,
            (__v2df) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compressstoreu_pd (void *__P, __mmask8 __U, __m256d __A) {
  __builtin_ia32_compressstoredf256_mask ((__v4df *) __P,
            (__v4df) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compressstoreu_epi64 (void *__P, __mmask8 __U, __m128i __A) {
  __builtin_ia32_compressstoredi128_mask ((__v2di *) __P,
            (__v2di) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compressstoreu_epi64 (void *__P, __mmask8 __U, __m256i __A) {
  __builtin_ia32_compressstoredi256_mask ((__v4di *) __P,
            (__v4di) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compressstoreu_ps (void *__P, __mmask8 __U, __m128 __A) {
  __builtin_ia32_compressstoresf128_mask ((__v4sf *) __P,
            (__v4sf) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compressstoreu_ps (void *__P, __mmask8 __U, __m256 __A) {
  __builtin_ia32_compressstoresf256_mask ((__v8sf *) __P,
            (__v8sf) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compressstoreu_epi32 (void *__P, __mmask8 __U, __m128i __A) {
  __builtin_ia32_compressstoresi128_mask ((__v4si *) __P,
            (__v4si) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compressstoreu_epi32 (void *__P, __mmask8 __U, __m256i __A) {
  __builtin_ia32_compressstoresi256_mask ((__v8si *) __P,
            (__v8si) __A,
            (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi32_pd (__m128d __W, __mmask8 __U, __m128i __A) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8) __U,
                                              (__v2df)_mm_cvtepi32_pd(__A),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi32_pd (__mmask8 __U, __m128i __A) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8) __U,
                                              (__v2df)_mm_cvtepi32_pd(__A),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi32_pd (__m256d __W, __mmask8 __U, __m128i __A) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8) __U,
                                              (__v4df)_mm256_cvtepi32_pd(__A),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi32_pd (__mmask8 __U, __m128i __A) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8) __U,
                                              (__v4df)_mm256_cvtepi32_pd(__A),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi32_ps (__m128 __W, __mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtdq2ps128_mask ((__v4si) __A,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi32_ps (__mmask16 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtdq2ps128_mask ((__v4si) __A,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi32_ps (__m256 __W, __mmask8 __U, __m256i __A) {
  return (__m256) __builtin_ia32_cvtdq2ps256_mask ((__v8si) __A,
               (__v8sf) __W,
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi32_ps (__mmask16 __U, __m256i __A) {
  return (__m256) __builtin_ia32_cvtdq2ps256_mask ((__v8si) __A,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtpd_epi32 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2dq128_mask ((__v2df) __A,
                (__v4si) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtpd_epi32 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2dq128_mask ((__v2df) __A,
                (__v4si)
                _mm_setzero_si128 (),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtpd_epi32 (__m128i __W, __mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvtpd2dq256_mask ((__v4df) __A,
                (__v4si) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtpd_epi32 (__mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvtpd2dq256_mask ((__v4df) __A,
                (__v4si)
                _mm_setzero_si128 (),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtpd_ps (__m128 __W, __mmask8 __U, __m128d __A) {
  return (__m128) __builtin_ia32_cvtpd2ps_mask ((__v2df) __A,
            (__v4sf) __W,
            (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtpd_ps (__mmask8 __U, __m128d __A) {
  return (__m128) __builtin_ia32_cvtpd2ps_mask ((__v2df) __A,
            (__v4sf)
            _mm_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtpd_ps (__m128 __W, __mmask8 __U, __m256d __A) {
  return (__m128) __builtin_ia32_cvtpd2ps256_mask ((__v4df) __A,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtpd_ps (__mmask8 __U, __m256d __A) {
  return (__m128) __builtin_ia32_cvtpd2ps256_mask ((__v4df) __A,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtpd_epu32 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq128_mask ((__v2df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtpd_epu32 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq128_mask ((__v2df) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtpd_epu32 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq128_mask ((__v2df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtpd_epu32 (__m256d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq256_mask ((__v4df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtpd_epu32 (__m128i __W, __mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq256_mask ((__v4df) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtpd_epu32 (__mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq256_mask ((__v4df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtps_epi32 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2dq128_mask ((__v4sf) __A,
                (__v4si) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtps_epi32 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2dq128_mask ((__v4sf) __A,
                (__v4si)
                _mm_setzero_si128 (),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtps_epi32 (__m256i __W, __mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvtps2dq256_mask ((__v8sf) __A,
                (__v8si) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtps_epi32 (__mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvtps2dq256_mask ((__v8sf) __A,
                (__v8si)
                _mm256_setzero_si256 (),
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtps_pd (__m128d __W, __mmask8 __U, __m128 __A) {
  return (__m128d) __builtin_ia32_cvtps2pd128_mask ((__v4sf) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtps_pd (__mmask8 __U, __m128 __A) {
  return (__m128d) __builtin_ia32_cvtps2pd128_mask ((__v4sf) __A,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtps_pd (__m256d __W, __mmask8 __U, __m128 __A) {
  return (__m256d) __builtin_ia32_cvtps2pd256_mask ((__v4sf) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtps_pd (__mmask8 __U, __m128 __A) {
  return (__m256d) __builtin_ia32_cvtps2pd256_mask ((__v4sf) __A,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtps_epu32 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2udq128_mask ((__v4sf) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtps_epu32 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2udq128_mask ((__v4sf) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtps_epu32 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2udq128_mask ((__v4sf) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtps_epu32 (__m256 __A) {
  return (__m256i) __builtin_ia32_cvtps2udq256_mask ((__v8sf) __A,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtps_epu32 (__m256i __W, __mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvtps2udq256_mask ((__v8sf) __A,
                 (__v8si) __W,
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtps_epu32 (__mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvtps2udq256_mask ((__v8sf) __A,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvttpd_epi32 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2dq128_mask ((__v2df) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvttpd_epi32 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2dq128_mask ((__v2df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvttpd_epi32 (__m128i __W, __mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvttpd2dq256_mask ((__v4df) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvttpd_epi32 (__mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvttpd2dq256_mask ((__v4df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvttpd_epu32 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq128_mask ((__v2df) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvttpd_epu32 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq128_mask ((__v2df) __A,
                  (__v4si) __W,
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvttpd_epu32 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq128_mask ((__v2df) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvttpd_epu32 (__m256d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq256_mask ((__v4df) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvttpd_epu32 (__m128i __W, __mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq256_mask ((__v4df) __A,
                  (__v4si) __W,
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvttpd_epu32 (__mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq256_mask ((__v4df) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvttps_epi32 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2dq128_mask ((__v4sf) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvttps_epi32 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2dq128_mask ((__v4sf) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvttps_epi32 (__m256i __W, __mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvttps2dq256_mask ((__v8sf) __A,
                 (__v8si) __W,
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvttps_epi32 (__mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvttps2dq256_mask ((__v8sf) __A,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvttps_epu32 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2udq128_mask ((__v4sf) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvttps_epu32 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2udq128_mask ((__v4sf) __A,
                  (__v4si) __W,
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvttps_epu32 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2udq128_mask ((__v4sf) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvttps_epu32 (__m256 __A) {
  return (__m256i) __builtin_ia32_cvttps2udq256_mask ((__v8sf) __A,
                  (__v8si)
                  _mm256_setzero_si256 (),
                  (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvttps_epu32 (__m256i __W, __mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvttps2udq256_mask ((__v8sf) __A,
                  (__v8si) __W,
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvttps_epu32 (__mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvttps2udq256_mask ((__v8sf) __A,
                  (__v8si)
                  _mm256_setzero_si256 (),
                  (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtepu32_pd (__m128i __A) {
  return (__m128d) __builtin_convertvector(
      __builtin_shufflevector((__v4su)__A, (__v4su)__A, 0, 1), __v2df);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepu32_pd (__m128d __W, __mmask8 __U, __m128i __A) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8) __U,
                                              (__v2df)_mm_cvtepu32_pd(__A),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepu32_pd (__mmask8 __U, __m128i __A) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8) __U,
                                              (__v2df)_mm_cvtepu32_pd(__A),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtepu32_pd (__m128i __A) {
  return (__m256d)__builtin_convertvector((__v4su)__A, __v4df);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepu32_pd (__m256d __W, __mmask8 __U, __m128i __A) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8) __U,
                                              (__v4df)_mm256_cvtepu32_pd(__A),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepu32_pd (__mmask8 __U, __m128i __A) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8) __U,
                                              (__v4df)_mm256_cvtepu32_pd(__A),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtepu32_ps (__m128i __A) {
  return (__m128) __builtin_ia32_cvtudq2ps128_mask ((__v4si) __A,
                (__v4sf)
                _mm_setzero_ps (),
                (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepu32_ps (__m128 __W, __mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtudq2ps128_mask ((__v4si) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepu32_ps (__mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtudq2ps128_mask ((__v4si) __A,
                (__v4sf)
                _mm_setzero_ps (),
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtepu32_ps (__m256i __A) {
  return (__m256) __builtin_ia32_cvtudq2ps256_mask ((__v8si) __A,
                (__v8sf)
                _mm256_setzero_ps (),
                (__mmask8) -1);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepu32_ps (__m256 __W, __mmask8 __U, __m256i __A) {
  return (__m256) __builtin_ia32_cvtudq2ps256_mask ((__v8si) __A,
                (__v8sf) __W,
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepu32_ps (__mmask8 __U, __m256i __A) {
  return (__m256) __builtin_ia32_cvtudq2ps256_mask ((__v8si) __A,
                (__v8sf)
                _mm256_setzero_ps (),
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_div_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_div_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_div_pd(__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_div_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_div_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_div_pd(__A, __B),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_div_pd(__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_div_pd(__A, __B),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_div_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_div_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_div_ps(__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_div_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_div_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_div_ps(__A, __B),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_div_ps(__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_div_ps(__A, __B),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expand_pd (__m128d __W, __mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_expanddf128_mask ((__v2df) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expand_pd (__mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_expanddf128_mask ((__v2df) __A,
                 (__v2df)
                 _mm_setzero_pd (),
                 (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expand_pd (__m256d __W, __mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_expanddf256_mask ((__v4df) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expand_pd (__mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_expanddf256_mask ((__v4df) __A,
                 (__v4df)
                 _mm256_setzero_pd (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expand_epi64 (__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_expanddi128_mask ((__v2di) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expand_epi64 (__mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_expanddi128_mask ((__v2di) __A,
                 (__v2di)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expand_epi64 (__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_expanddi256_mask ((__v4di) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expand_epi64 (__mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_expanddi256_mask ((__v4di) __A,
                 (__v4di)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expandloadu_pd (__m128d __W, __mmask8 __U, void const *__P) {
  return (__m128d) __builtin_ia32_expandloaddf128_mask ((__v2df *) __P,
              (__v2df) __W,
              (__mmask8)
              __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expandloadu_pd (__mmask8 __U, void const *__P) {
  return (__m128d) __builtin_ia32_expandloaddf128_mask ((__v2df *) __P,
               (__v2df)
               _mm_setzero_pd (),
               (__mmask8)
               __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expandloadu_pd (__m256d __W, __mmask8 __U, void const *__P) {
  return (__m256d) __builtin_ia32_expandloaddf256_mask ((__v4df *) __P,
              (__v4df) __W,
              (__mmask8)
              __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expandloadu_pd (__mmask8 __U, void const *__P) {
  return (__m256d) __builtin_ia32_expandloaddf256_mask ((__v4df *) __P,
               (__v4df)
               _mm256_setzero_pd (),
               (__mmask8)
               __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expandloadu_epi64 (__m128i __W, __mmask8 __U, void const *__P) {
  return (__m128i) __builtin_ia32_expandloaddi128_mask ((__v2di *) __P,
              (__v2di) __W,
              (__mmask8)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expandloadu_epi64 (__mmask8 __U, void const *__P) {
  return (__m128i) __builtin_ia32_expandloaddi128_mask ((__v2di *) __P,
               (__v2di)
               _mm_setzero_si128 (),
               (__mmask8)
               __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expandloadu_epi64 (__m256i __W, __mmask8 __U,
             void const *__P) {
  return (__m256i) __builtin_ia32_expandloaddi256_mask ((__v4di *) __P,
              (__v4di) __W,
              (__mmask8)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expandloadu_epi64 (__mmask8 __U, void const *__P) {
  return (__m256i) __builtin_ia32_expandloaddi256_mask ((__v4di *) __P,
               (__v4di)
               _mm256_setzero_si256 (),
               (__mmask8)
               __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expandloadu_ps (__m128 __W, __mmask8 __U, void const *__P) {
  return (__m128) __builtin_ia32_expandloadsf128_mask ((__v4sf *) __P,
                   (__v4sf) __W,
                   (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expandloadu_ps (__mmask8 __U, void const *__P) {
  return (__m128) __builtin_ia32_expandloadsf128_mask ((__v4sf *) __P,
              (__v4sf)
              _mm_setzero_ps (),
              (__mmask8)
              __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expandloadu_ps (__m256 __W, __mmask8 __U, void const *__P) {
  return (__m256) __builtin_ia32_expandloadsf256_mask ((__v8sf *) __P,
                   (__v8sf) __W,
                   (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expandloadu_ps (__mmask8 __U, void const *__P) {
  return (__m256) __builtin_ia32_expandloadsf256_mask ((__v8sf *) __P,
              (__v8sf)
              _mm256_setzero_ps (),
              (__mmask8)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expandloadu_epi32 (__m128i __W, __mmask8 __U, void const *__P) {
  return (__m128i) __builtin_ia32_expandloadsi128_mask ((__v4si *) __P,
              (__v4si) __W,
              (__mmask8)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expandloadu_epi32 (__mmask8 __U, void const *__P) {
  return (__m128i) __builtin_ia32_expandloadsi128_mask ((__v4si *) __P,
               (__v4si)
               _mm_setzero_si128 (),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expandloadu_epi32 (__m256i __W, __mmask8 __U,
             void const *__P) {
  return (__m256i) __builtin_ia32_expandloadsi256_mask ((__v8si *) __P,
              (__v8si) __W,
              (__mmask8)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expandloadu_epi32 (__mmask8 __U, void const *__P) {
  return (__m256i) __builtin_ia32_expandloadsi256_mask ((__v8si *) __P,
               (__v8si)
               _mm256_setzero_si256 (),
               (__mmask8)
               __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expand_ps (__m128 __W, __mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_expandsf128_mask ((__v4sf) __A,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expand_ps (__mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_expandsf128_mask ((__v4sf) __A,
                (__v4sf)
                _mm_setzero_ps (),
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expand_ps (__m256 __W, __mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_expandsf256_mask ((__v8sf) __A,
               (__v8sf) __W,
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expand_ps (__mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_expandsf256_mask ((__v8sf) __A,
                (__v8sf)
                _mm256_setzero_ps (),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expand_epi32 (__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_expandsi128_mask ((__v4si) __A,
                (__v4si) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expand_epi32 (__mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_expandsi128_mask ((__v4si) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expand_epi32 (__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_expandsi256_mask ((__v8si) __A,
                (__v8si) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expand_epi32 (__mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_expandsi256_mask ((__v8si) __A,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_getexp_pd (__m128d __A) {
  return (__m128d) __builtin_ia32_getexppd128_mask ((__v2df) __A,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_getexp_pd (__m128d __W, __mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_getexppd128_mask ((__v2df) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_getexp_pd (__mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_getexppd128_mask ((__v2df) __A,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_getexp_pd (__m256d __A) {
  return (__m256d) __builtin_ia32_getexppd256_mask ((__v4df) __A,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_getexp_pd (__m256d __W, __mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_getexppd256_mask ((__v4df) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_getexp_pd (__mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_getexppd256_mask ((__v4df) __A,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_getexp_ps (__m128 __A) {
  return (__m128) __builtin_ia32_getexpps128_mask ((__v4sf) __A,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_getexp_ps (__m128 __W, __mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_getexpps128_mask ((__v4sf) __A,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_getexp_ps (__mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_getexpps128_mask ((__v4sf) __A,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_getexp_ps (__m256 __A) {
  return (__m256) __builtin_ia32_getexpps256_mask ((__v8sf) __A,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) -1);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_getexp_ps (__m256 __W, __mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_getexpps256_mask ((__v8sf) __A,
               (__v8sf) __W,
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_getexp_ps (__mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_getexpps256_mask ((__v8sf) __A,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_max_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_pd(__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_max_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_max_pd(__A, __B),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_pd(__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_max_pd(__A, __B),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_max_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_ps(__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_max_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_max_ps(__A, __B),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_ps(__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_max_ps(__A, __B),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_min_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_pd(__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_min_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_min_pd(__A, __B),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_pd(__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_min_pd(__A, __B),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_min_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_ps(__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_min_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_min_ps(__A, __B),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_ps(__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_min_ps(__A, __B),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mul_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_mul_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mul_pd(__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_mul_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mul_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_mul_pd(__A, __B),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mul_pd(__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_mul_pd(__A, __B),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mul_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_mul_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mul_ps(__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_mul_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mul_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_mul_ps(__A, __B),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mul_ps(__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_mul_ps(__A, __B),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_abs_epi32(__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_abs_epi32(__A),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_abs_epi32(__mmask8 __U, __m128i __A) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_abs_epi32(__A),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_abs_epi32(__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask16)__U,
                                             (__v8si)_mm256_abs_epi32(__A),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_abs_epi32(__mmask8 __U, __m256i __A) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask16)__U,
                                             (__v8si)_mm256_abs_epi32(__A),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_abs_epi64 (__m128i __A) {
  return (__m128i) __builtin_ia32_pabsq128_mask ((__v2di) __A,
             (__v2di)
             _mm_setzero_si128 (),
             (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_abs_epi64 (__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_pabsq128_mask ((__v2di) __A,
             (__v2di) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_abs_epi64 (__mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_pabsq128_mask ((__v2di) __A,
             (__v2di)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_abs_epi64 (__m256i __A) {
  return (__m256i) __builtin_ia32_pabsq256_mask ((__v4di) __A,
             (__v4di)
             _mm256_setzero_si256 (),
             (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_abs_epi64 (__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_pabsq256_mask ((__v4di) __A,
             (__v4di) __W,
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_abs_epi64 (__mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_pabsq256_mask ((__v4di) __A,
             (__v4di)
             _mm256_setzero_si256 (),
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_epi32(__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__M,
                                             (__v4si)_mm_max_epi32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_epi32(__m128i __W, __mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__M,
                                             (__v4si)_mm_max_epi32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_epi32(__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                             (__v8si)_mm256_max_epi32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_epi32(__m256i __W, __mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                             (__v8si)_mm256_max_epi32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_epi64 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_epi64 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_max_epi64 (__m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_epi64 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_epi64 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_max_epi64 (__m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_epu32(__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__M,
                                             (__v4si)_mm_max_epu32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_epu32(__m128i __W, __mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__M,
                                             (__v4si)_mm_max_epu32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_epu32(__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                             (__v8si)_mm256_max_epu32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_epu32(__m256i __W, __mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                             (__v8si)_mm256_max_epu32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_epu64 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_max_epu64 (__m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_epu64 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_epu64 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_max_epu64 (__m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_epu64 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_epi32(__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__M,
                                             (__v4si)_mm_min_epi32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_epi32(__m128i __W, __mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__M,
                                             (__v4si)_mm_min_epi32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_epi32(__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                             (__v8si)_mm256_min_epi32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_epi32(__m256i __W, __mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                             (__v8si)_mm256_min_epi32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_min_epi64 (__m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pminsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_epi64 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pminsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_epi64 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pminsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_min_epi64 (__m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pminsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_epi64 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pminsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_epi64 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pminsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_epu32(__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__M,
                                             (__v4si)_mm_min_epu32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_epu32(__m128i __W, __mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__M,
                                             (__v4si)_mm_min_epu32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_epu32(__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                             (__v8si)_mm256_min_epu32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_epu32(__m256i __W, __mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                             (__v8si)_mm256_min_epu32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_min_epu64 (__m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pminuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_epu64 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pminuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_epu64 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pminuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_min_epu64 (__m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pminuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_epu64 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pminuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_epu64 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pminuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              __M);
}
# 3681 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_scalef_pd (__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_scalefpd128_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_scalef_pd (__m128d __W, __mmask8 __U, __m128d __A,
        __m128d __B) {
  return (__m128d) __builtin_ia32_scalefpd128_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_scalef_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_scalefpd128_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_scalef_pd (__m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_scalefpd256_mask ((__v4df) __A,
                (__v4df) __B,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_scalef_pd (__m256d __W, __mmask8 __U, __m256d __A,
           __m256d __B) {
  return (__m256d) __builtin_ia32_scalefpd256_mask ((__v4df) __A,
                (__v4df) __B,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_scalef_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_scalefpd256_mask ((__v4df) __A,
                (__v4df) __B,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_scalef_ps (__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_scalefps128_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_scalef_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_scalefps128_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_scalef_ps (__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_scalefps128_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_scalef_ps (__m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_scalefps256_mask ((__v8sf) __A,
               (__v8sf) __B,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) -1);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_scalef_ps (__m256 __W, __mmask8 __U, __m256 __A,
           __m256 __B) {
  return (__m256) __builtin_ia32_scalefps256_mask ((__v8sf) __A,
               (__v8sf) __B,
               (__v8sf) __W,
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_scalef_ps (__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_scalefps256_mask ((__v8sf) __A,
               (__v8sf) __B,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) __U);
}
# 3948 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sqrt_pd(__m128d __W, __mmask8 __U, __m128d __A) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_sqrt_pd(__A),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sqrt_pd(__mmask8 __U, __m128d __A) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_sqrt_pd(__A),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sqrt_pd(__m256d __W, __mmask8 __U, __m256d __A) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_sqrt_pd(__A),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sqrt_pd(__mmask8 __U, __m256d __A) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_sqrt_pd(__A),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sqrt_ps(__m128 __W, __mmask8 __U, __m128 __A) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_sqrt_ps(__A),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sqrt_ps(__mmask8 __U, __m128 __A) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_sqrt_ps(__A),
                                             (__v4sf)_mm_setzero_pd());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sqrt_ps(__m256 __W, __mmask8 __U, __m256 __A) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_sqrt_ps(__A),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sqrt_ps(__mmask8 __U, __m256 __A) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_sqrt_ps(__A),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sub_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_sub_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sub_pd(__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_sub_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sub_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_sub_pd(__A, __B),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sub_pd(__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_sub_pd(__A, __B),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sub_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_sub_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sub_ps(__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_sub_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sub_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_sub_ps(__A, __B),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sub_ps(__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_sub_ps(__A, __B),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask2_permutex2var_epi32 (__m128i __A, __m128i __I, __mmask8 __U,
            __m128i __B) {
  return (__m128i) __builtin_ia32_vpermi2vard128_mask ((__v4si) __A,
                   (__v4si) __I
                             ,
                   (__v4si) __B,
                   (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask2_permutex2var_epi32 (__m256i __A, __m256i __I,
         __mmask8 __U, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermi2vard256_mask ((__v8si) __A,
                   (__v8si) __I
                             ,
                   (__v8si) __B,
                   (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask2_permutex2var_pd (__m128d __A, __m128i __I, __mmask8 __U,
         __m128d __B) {
  return (__m128d) __builtin_ia32_vpermi2varpd128_mask ((__v2df) __A,
              (__v2di) __I
                        ,
              (__v2df) __B,
              (__mmask8)
              __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask2_permutex2var_pd (__m256d __A, __m256i __I, __mmask8 __U,
            __m256d __B) {
  return (__m256d) __builtin_ia32_vpermi2varpd256_mask ((__v4df) __A,
              (__v4di) __I
                        ,
              (__v4df) __B,
              (__mmask8)
              __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask2_permutex2var_ps (__m128 __A, __m128i __I, __mmask8 __U,
         __m128 __B) {
  return (__m128) __builtin_ia32_vpermi2varps128_mask ((__v4sf) __A,
                   (__v4si) __I
                             ,
                   (__v4sf) __B,
                   (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask2_permutex2var_ps (__m256 __A, __m256i __I, __mmask8 __U,
            __m256 __B) {
  return (__m256) __builtin_ia32_vpermi2varps256_mask ((__v8sf) __A,
                   (__v8si) __I
                             ,
                   (__v8sf) __B,
                   (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask2_permutex2var_epi64 (__m128i __A, __m128i __I, __mmask8 __U,
            __m128i __B) {
  return (__m128i) __builtin_ia32_vpermi2varq128_mask ((__v2di) __A,
                   (__v2di) __I
                             ,
                   (__v2di) __B,
                   (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask2_permutex2var_epi64 (__m256i __A, __m256i __I,
         __mmask8 __U, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermi2varq256_mask ((__v4di) __A,
                   (__v4di) __I
                             ,
                   (__v4di) __B,
                   (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_permutex2var_epi32 (__m128i __A, __m128i __I, __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2vard128_mask ((__v4si) __I
                             ,
                   (__v4si) __A,
                   (__v4si) __B,
                   (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_permutex2var_epi32 (__m128i __A, __mmask8 __U, __m128i __I,
           __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2vard128_mask ((__v4si) __I
                             ,
                   (__v4si) __A,
                   (__v4si) __B,
                   (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_permutex2var_epi32 (__mmask8 __U, __m128i __A, __m128i __I,
            __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2vard128_maskz ((__v4si) __I
                        ,
              (__v4si) __A,
              (__v4si) __B,
              (__mmask8)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutex2var_epi32 (__m256i __A, __m256i __I, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2vard256_mask ((__v8si) __I
                             ,
                   (__v8si) __A,
                   (__v8si) __B,
                   (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutex2var_epi32 (__m256i __A, __mmask8 __U, __m256i __I,
        __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2vard256_mask ((__v8si) __I
                             ,
                   (__v8si) __A,
                   (__v8si) __B,
                   (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutex2var_epi32 (__mmask8 __U, __m256i __A,
         __m256i __I, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2vard256_maskz ((__v8si) __I
                        ,
              (__v8si) __A,
              (__v8si) __B,
              (__mmask8)
              __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_permutex2var_pd (__m128d __A, __m128i __I, __m128d __B) {
  return (__m128d) __builtin_ia32_vpermt2varpd128_mask ((__v2di) __I
                        ,
              (__v2df) __A,
              (__v2df) __B,
              (__mmask8) -
              1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_permutex2var_pd (__m128d __A, __mmask8 __U, __m128i __I,
        __m128d __B) {
  return (__m128d) __builtin_ia32_vpermt2varpd128_mask ((__v2di) __I
                        ,
              (__v2df) __A,
              (__v2df) __B,
              (__mmask8)
              __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_permutex2var_pd (__mmask8 __U, __m128d __A, __m128i __I,
         __m128d __B) {
  return (__m128d) __builtin_ia32_vpermt2varpd128_maskz ((__v2di) __I
                         ,
               (__v2df) __A,
               (__v2df) __B,
               (__mmask8)
               __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutex2var_pd (__m256d __A, __m256i __I, __m256d __B) {
  return (__m256d) __builtin_ia32_vpermt2varpd256_mask ((__v4di) __I
                        ,
              (__v4df) __A,
              (__v4df) __B,
              (__mmask8) -
              1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutex2var_pd (__m256d __A, __mmask8 __U, __m256i __I,
           __m256d __B) {
  return (__m256d) __builtin_ia32_vpermt2varpd256_mask ((__v4di) __I
                        ,
              (__v4df) __A,
              (__v4df) __B,
              (__mmask8)
              __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutex2var_pd (__mmask8 __U, __m256d __A, __m256i __I,
            __m256d __B) {
  return (__m256d) __builtin_ia32_vpermt2varpd256_maskz ((__v4di) __I
                         ,
               (__v4df) __A,
               (__v4df) __B,
               (__mmask8)
               __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_permutex2var_ps (__m128 __A, __m128i __I, __m128 __B) {
  return (__m128) __builtin_ia32_vpermt2varps128_mask ((__v4si) __I
                             ,
                   (__v4sf) __A,
                   (__v4sf) __B,
                   (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_permutex2var_ps (__m128 __A, __mmask8 __U, __m128i __I,
        __m128 __B) {
  return (__m128) __builtin_ia32_vpermt2varps128_mask ((__v4si) __I
                             ,
                   (__v4sf) __A,
                   (__v4sf) __B,
                   (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_permutex2var_ps (__mmask8 __U, __m128 __A, __m128i __I,
         __m128 __B) {
  return (__m128) __builtin_ia32_vpermt2varps128_maskz ((__v4si) __I
                        ,
              (__v4sf) __A,
              (__v4sf) __B,
              (__mmask8)
              __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutex2var_ps (__m256 __A, __m256i __I, __m256 __B) {
  return (__m256) __builtin_ia32_vpermt2varps256_mask ((__v8si) __I
                             ,
                   (__v8sf) __A,
                   (__v8sf) __B,
                   (__mmask8) -1);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutex2var_ps (__m256 __A, __mmask8 __U, __m256i __I,
           __m256 __B) {
  return (__m256) __builtin_ia32_vpermt2varps256_mask ((__v8si) __I
                             ,
                   (__v8sf) __A,
                   (__v8sf) __B,
                   (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutex2var_ps (__mmask8 __U, __m256 __A, __m256i __I,
            __m256 __B) {
  return (__m256) __builtin_ia32_vpermt2varps256_maskz ((__v8si) __I
                        ,
              (__v8sf) __A,
              (__v8sf) __B,
              (__mmask8)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_permutex2var_epi64 (__m128i __A, __m128i __I, __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2varq128_mask ((__v2di) __I
                             ,
                   (__v2di) __A,
                   (__v2di) __B,
                   (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_permutex2var_epi64 (__m128i __A, __mmask8 __U, __m128i __I,
           __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2varq128_mask ((__v2di) __I
                             ,
                   (__v2di) __A,
                   (__v2di) __B,
                   (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_permutex2var_epi64 (__mmask8 __U, __m128i __A, __m128i __I,
            __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2varq128_maskz ((__v2di) __I
                        ,
              (__v2di) __A,
              (__v2di) __B,
              (__mmask8)
              __U);
}


static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutex2var_epi64 (__m256i __A, __m256i __I, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2varq256_mask ((__v4di) __I
                             ,
                   (__v4di) __A,
                   (__v4di) __B,
                   (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutex2var_epi64 (__m256i __A, __mmask8 __U, __m256i __I,
        __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2varq256_mask ((__v4di) __I
                             ,
                   (__v4di) __A,
                   (__v4di) __B,
                   (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutex2var_epi64 (__mmask8 __U, __m256i __A,
         __m256i __I, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2varq256_maskz ((__v4di) __I
                        ,
              (__v4di) __A,
              (__v4di) __B,
              (__mmask8)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi8_epi32(__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_cvtepi8_epi32(__A),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi8_epi32(__mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_cvtepi8_epi32(__A),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi8_epi32 (__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_cvtepi8_epi32(__A),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi8_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_cvtepi8_epi32(__A),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi8_epi64(__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepi8_epi64(__A),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi8_epi64(__mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepi8_epi64(__A),
                                             (__v2di)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi8_epi64(__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepi8_epi64(__A),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi8_epi64(__mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepi8_epi64(__A),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi32_epi64(__m128i __W, __mmask8 __U, __m128i __X)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepi32_epi64(__X),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi32_epi64(__mmask8 __U, __m128i __X)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepi32_epi64(__X),
                                             (__v2di)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi32_epi64(__m256i __W, __mmask8 __U, __m128i __X)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepi32_epi64(__X),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi32_epi64(__mmask8 __U, __m128i __X)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepi32_epi64(__X),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi16_epi32(__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_cvtepi16_epi32(__A),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi16_epi32(__mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_cvtepi16_epi32(__A),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi16_epi32(__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_cvtepi16_epi32(__A),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi16_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_cvtepi16_epi32(__A),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi16_epi64(__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepi16_epi64(__A),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi16_epi64(__mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepi16_epi64(__A),
                                             (__v2di)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi16_epi64(__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepi16_epi64(__A),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi16_epi64(__mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepi16_epi64(__A),
                                             (__v4di)_mm256_setzero_si256());
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepu8_epi32(__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_cvtepu8_epi32(__A),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepu8_epi32(__mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_cvtepu8_epi32(__A),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepu8_epi32(__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_cvtepu8_epi32(__A),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepu8_epi32(__mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_cvtepu8_epi32(__A),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepu8_epi64(__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepu8_epi64(__A),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepu8_epi64(__mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepu8_epi64(__A),
                                             (__v2di)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepu8_epi64(__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepu8_epi64(__A),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepu8_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepu8_epi64(__A),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepu32_epi64(__m128i __W, __mmask8 __U, __m128i __X)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepu32_epi64(__X),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepu32_epi64(__mmask8 __U, __m128i __X)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepu32_epi64(__X),
                                             (__v2di)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepu32_epi64(__m256i __W, __mmask8 __U, __m128i __X)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepu32_epi64(__X),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepu32_epi64(__mmask8 __U, __m128i __X)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepu32_epi64(__X),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepu16_epi32(__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_cvtepu16_epi32(__A),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepu16_epi32(__mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_cvtepu16_epi32(__A),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepu16_epi32(__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_cvtepu16_epi32(__A),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepu16_epi32(__mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_cvtepu16_epi32(__A),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepu16_epi64(__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepu16_epi64(__A),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepu16_epi64(__mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_cvtepu16_epi64(__A),
                                             (__v2di)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepu16_epi64(__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepu16_epi64(__A),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepu16_epi64(__mmask8 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_cvtepu16_epi64(__A),
                                             (__v4di)_mm256_setzero_si256());
}
# 4765 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_rolv_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si)
              _mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_rolv_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si) __W,
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_rolv_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si)
              _mm_setzero_si128 (),
              (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_rolv_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_rolv_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
      __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si) __W,
              (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_rolv_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si)
              _mm256_setzero_si256 (),
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_rolv_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_di (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_rolv_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W,
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_rolv_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_di (),
              (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_rolv_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_rolv_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
      __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W,
              (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_rolv_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) __U);
}
# 4941 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sll_epi32(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_sll_epi32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sll_epi32(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_sll_epi32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sll_epi32(__m256i __W, __mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_sll_epi32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sll_epi32(__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_sll_epi32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_slli_epi32(__m128i __W, __mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_slli_epi32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_slli_epi32(__mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_slli_epi32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_slli_epi32(__m256i __W, __mmask8 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_slli_epi32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_slli_epi32(__mmask8 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_slli_epi32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sll_epi64(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_sll_epi64(__A, __B),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sll_epi64(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_sll_epi64(__A, __B),
                                             (__v2di)_mm_setzero_di());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sll_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_sll_epi64(__A, __B),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sll_epi64(__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_sll_epi64(__A, __B),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_slli_epi64(__m128i __W, __mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_slli_epi64(__A, __B),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_slli_epi64(__mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_slli_epi64(__A, __B),
                                             (__v2di)_mm_setzero_di());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_slli_epi64(__m256i __W, __mmask8 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_slli_epi64(__A, __B),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_slli_epi64(__mmask8 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_slli_epi64(__A, __B),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_rorv_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si)
              _mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_rorv_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si) __W,
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_rorv_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si)
              _mm_setzero_si128 (),
              (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_rorv_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_rorv_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
      __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si) __W,
              (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_rorv_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si)
              _mm256_setzero_si256 (),
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_rorv_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_di (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_rorv_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W,
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_rorv_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_di (),
              (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_rorv_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_rorv_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
      __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W,
              (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_rorv_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sllv_epi64(__m128i __W, __mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_sllv_epi64(__X, __Y),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sllv_epi64(__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_sllv_epi64(__X, __Y),
                                             (__v2di)_mm_setzero_di());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sllv_epi64(__m256i __W, __mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                            (__v4di)_mm256_sllv_epi64(__X, __Y),
                                            (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sllv_epi64(__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                            (__v4di)_mm256_sllv_epi64(__X, __Y),
                                            (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sllv_epi32(__m128i __W, __mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_sllv_epi32(__X, __Y),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sllv_epi32(__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_sllv_epi32(__X, __Y),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sllv_epi32(__m256i __W, __mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                            (__v8si)_mm256_sllv_epi32(__X, __Y),
                                            (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sllv_epi32(__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                            (__v8si)_mm256_sllv_epi32(__X, __Y),
                                            (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_srlv_epi64(__m128i __W, __mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_srlv_epi64(__X, __Y),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_srlv_epi64(__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_srlv_epi64(__X, __Y),
                                             (__v2di)_mm_setzero_di());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_srlv_epi64(__m256i __W, __mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                            (__v4di)_mm256_srlv_epi64(__X, __Y),
                                            (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_srlv_epi64(__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                            (__v4di)_mm256_srlv_epi64(__X, __Y),
                                            (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_srlv_epi32(__m128i __W, __mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                            (__v4si)_mm_srlv_epi32(__X, __Y),
                                            (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_srlv_epi32(__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                            (__v4si)_mm_srlv_epi32(__X, __Y),
                                            (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_srlv_epi32(__m256i __W, __mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                            (__v8si)_mm256_srlv_epi32(__X, __Y),
                                            (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_srlv_epi32(__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                            (__v8si)_mm256_srlv_epi32(__X, __Y),
                                            (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_srl_epi32(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_srl_epi32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_srl_epi32(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_srl_epi32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_srl_epi32(__m256i __W, __mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_srl_epi32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_srl_epi32(__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_srl_epi32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_srli_epi32(__m128i __W, __mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_srli_epi32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_srli_epi32(__mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_srli_epi32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_srli_epi32(__m256i __W, __mmask8 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_srli_epi32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_srli_epi32(__mmask8 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_srli_epi32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_srl_epi64(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_srl_epi64(__A, __B),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_srl_epi64(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_srl_epi64(__A, __B),
                                             (__v2di)_mm_setzero_di());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_srl_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_srl_epi64(__A, __B),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_srl_epi64(__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_srl_epi64(__A, __B),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_srli_epi64(__m128i __W, __mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_srli_epi64(__A, __B),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_srli_epi64(__mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_srli_epi64(__A, __B),
                                             (__v2di)_mm_setzero_di());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_srli_epi64(__m256i __W, __mmask8 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_srli_epi64(__A, __B),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_srli_epi64(__mmask8 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_srli_epi64(__A, __B),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_srav_epi32(__m128i __W, __mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                            (__v4si)_mm_srav_epi32(__X, __Y),
                                            (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_srav_epi32(__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                            (__v4si)_mm_srav_epi32(__X, __Y),
                                            (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_srav_epi32(__m256i __W, __mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                            (__v8si)_mm256_srav_epi32(__X, __Y),
                                            (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_srav_epi32(__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                            (__v8si)_mm256_srav_epi32(__X, __Y),
                                            (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_srav_epi64(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psravq128((__v2di)__X, (__v2di)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_srav_epi64(__m128i __W, __mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_srav_epi64(__X, __Y),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_srav_epi64(__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_srav_epi64(__X, __Y),
                                             (__v2di)_mm_setzero_di());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_srav_epi64(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psravq256((__v4di)__X, (__v4di) __Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_srav_epi64(__m256i __W, __mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_srav_epi64(__X, __Y),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_srav_epi64 (__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_srav_epi64(__X, __Y),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mov_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_selectd_128 ((__mmask8) __U,
                 (__v4si) __A,
                 (__v4si) __W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mov_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_selectd_128 ((__mmask8) __U,
                 (__v4si) __A,
                 (__v4si) _mm_setzero_si128 ());
}


static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mov_epi32 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_selectd_256 ((__mmask8) __U,
                 (__v8si) __A,
                 (__v8si) __W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mov_epi32 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_selectd_256 ((__mmask8) __U,
                 (__v8si) __A,
                 (__v8si) _mm256_setzero_si256 ());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_load_epi32 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_movdqa32load128_mask ((__v4si *) __P,
              (__v4si) __W,
              (__mmask8)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_load_epi32 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_movdqa32load128_mask ((__v4si *) __P,
              (__v4si)
              _mm_setzero_si128 (),
              (__mmask8)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_load_epi32 (__m256i __W, __mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_movdqa32load256_mask ((__v8si *) __P,
              (__v8si) __W,
              (__mmask8)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_load_epi32 (__mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_movdqa32load256_mask ((__v8si *) __P,
              (__v8si)
              _mm256_setzero_si256 (),
              (__mmask8)
              __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_store_epi32 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_movdqa32store128_mask ((__v4si *) __P,
          (__v4si) __A,
          (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_store_epi32 (void *__P, __mmask8 __U, __m256i __A)
{
  __builtin_ia32_movdqa32store256_mask ((__v8si *) __P,
          (__v8si) __A,
          (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mov_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_selectq_128 ((__mmask8) __U,
                 (__v2di) __A,
                 (__v2di) __W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mov_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_selectq_128 ((__mmask8) __U,
                 (__v2di) __A,
                 (__v2di) _mm_setzero_di ());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mov_epi64 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_selectq_256 ((__mmask8) __U,
                 (__v4di) __A,
                 (__v4di) __W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mov_epi64 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_selectq_256 ((__mmask8) __U,
                 (__v4di) __A,
                 (__v4di) _mm256_setzero_si256 ());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_load_epi64 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_movdqa64load128_mask ((__v2di *) __P,
              (__v2di) __W,
              (__mmask8)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_load_epi64 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_movdqa64load128_mask ((__v2di *) __P,
              (__v2di)
              _mm_setzero_di (),
              (__mmask8)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_load_epi64 (__m256i __W, __mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_movdqa64load256_mask ((__v4di *) __P,
              (__v4di) __W,
              (__mmask8)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_load_epi64 (__mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_movdqa64load256_mask ((__v4di *) __P,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8)
              __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_store_epi64 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_movdqa64store128_mask ((__v2di *) __P,
          (__v2di) __A,
          (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_store_epi64 (void *__P, __mmask8 __U, __m256i __A)
{
  __builtin_ia32_movdqa64store256_mask ((__v4di *) __P,
          (__v4di) __A,
          (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_movedup_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_movedup_pd(__A),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_movedup_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_movedup_pd(__A),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_movedup_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_movedup_pd(__A),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_movedup_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_movedup_pd(__A),
                                              (__v4df)_mm256_setzero_pd());
}
# 5748 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_set1_epi64 (__m128i __O, __mmask8 __M, long long __A)
{
  return (__m128i) __builtin_ia32_pbroadcastq128_gpr_mask (__A, (__v2di) __O,
                 __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_set1_epi64 (__mmask8 __M, long long __A)
{
  return (__m128i) __builtin_ia32_pbroadcastq128_gpr_mask (__A,
                 (__v2di)
                 _mm_setzero_si128 (),
                 __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_set1_epi64 (__m256i __O, __mmask8 __M, long long __A)
{
  return (__m256i) __builtin_ia32_pbroadcastq256_gpr_mask (__A, (__v4di) __O,
                 __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_set1_epi64 (__mmask8 __M, long long __A)
{
  return (__m256i) __builtin_ia32_pbroadcastq256_gpr_mask (__A,
                 (__v4di)
                 _mm256_setzero_si256 (),
                 __M);
}
# 5853 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_load_pd (__m128d __W, __mmask8 __U, void const *__P)
{
  return (__m128d) __builtin_ia32_loadapd128_mask ((__v2df *) __P,
               (__v2df) __W,
               (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_load_pd (__mmask8 __U, void const *__P)
{
  return (__m128d) __builtin_ia32_loadapd128_mask ((__v2df *) __P,
               (__v2df)
               _mm_setzero_pd (),
               (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_load_pd (__m256d __W, __mmask8 __U, void const *__P)
{
  return (__m256d) __builtin_ia32_loadapd256_mask ((__v4df *) __P,
               (__v4df) __W,
               (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_load_pd (__mmask8 __U, void const *__P)
{
  return (__m256d) __builtin_ia32_loadapd256_mask ((__v4df *) __P,
               (__v4df)
               _mm256_setzero_pd (),
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_load_ps (__m128 __W, __mmask8 __U, void const *__P)
{
  return (__m128) __builtin_ia32_loadaps128_mask ((__v4sf *) __P,
              (__v4sf) __W,
              (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_load_ps (__mmask8 __U, void const *__P)
{
  return (__m128) __builtin_ia32_loadaps128_mask ((__v4sf *) __P,
              (__v4sf)
              _mm_setzero_ps (),
              (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_load_ps (__m256 __W, __mmask8 __U, void const *__P)
{
  return (__m256) __builtin_ia32_loadaps256_mask ((__v8sf *) __P,
              (__v8sf) __W,
              (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_load_ps (__mmask8 __U, void const *__P)
{
  return (__m256) __builtin_ia32_loadaps256_mask ((__v8sf *) __P,
              (__v8sf)
              _mm256_setzero_ps (),
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_loadu_epi64 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddqudi128_mask ((__v2di *) __P,
                 (__v2di) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_loadu_epi64 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddqudi128_mask ((__v2di *) __P,
                 (__v2di)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_loadu_epi64 (__m256i __W, __mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddqudi256_mask ((__v4di *) __P,
                 (__v4di) __W,
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_loadu_epi64 (__mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddqudi256_mask ((__v4di *) __P,
                 (__v4di)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_loadu_epi32 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddqusi128_mask ((__v4si *) __P,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_loadu_epi32 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddqusi128_mask ((__v4si *) __P,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_loadu_epi32 (__m256i __W, __mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddqusi256_mask ((__v8si *) __P,
                 (__v8si) __W,
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_loadu_epi32 (__mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddqusi256_mask ((__v8si *) __P,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_loadu_pd (__m128d __W, __mmask8 __U, void const *__P)
{
  return (__m128d) __builtin_ia32_loadupd128_mask ((__v2df *) __P,
               (__v2df) __W,
               (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_loadu_pd (__mmask8 __U, void const *__P)
{
  return (__m128d) __builtin_ia32_loadupd128_mask ((__v2df *) __P,
               (__v2df)
               _mm_setzero_pd (),
               (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_loadu_pd (__m256d __W, __mmask8 __U, void const *__P)
{
  return (__m256d) __builtin_ia32_loadupd256_mask ((__v4df *) __P,
               (__v4df) __W,
               (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_loadu_pd (__mmask8 __U, void const *__P)
{
  return (__m256d) __builtin_ia32_loadupd256_mask ((__v4df *) __P,
               (__v4df)
               _mm256_setzero_pd (),
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_loadu_ps (__m128 __W, __mmask8 __U, void const *__P)
{
  return (__m128) __builtin_ia32_loadups128_mask ((__v4sf *) __P,
              (__v4sf) __W,
              (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_loadu_ps (__mmask8 __U, void const *__P)
{
  return (__m128) __builtin_ia32_loadups128_mask ((__v4sf *) __P,
              (__v4sf)
              _mm_setzero_ps (),
              (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_loadu_ps (__m256 __W, __mmask8 __U, void const *__P)
{
  return (__m256) __builtin_ia32_loadups256_mask ((__v8sf *) __P,
              (__v8sf) __W,
              (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_loadu_ps (__mmask8 __U, void const *__P)
{
  return (__m256) __builtin_ia32_loadups256_mask ((__v8sf *) __P,
              (__v8sf)
              _mm256_setzero_ps (),
              (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_store_pd (void *__P, __mmask8 __U, __m128d __A)
{
  __builtin_ia32_storeapd128_mask ((__v2df *) __P,
           (__v2df) __A,
           (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_store_pd (void *__P, __mmask8 __U, __m256d __A)
{
  __builtin_ia32_storeapd256_mask ((__v4df *) __P,
           (__v4df) __A,
           (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_store_ps (void *__P, __mmask8 __U, __m128 __A)
{
  __builtin_ia32_storeaps128_mask ((__v4sf *) __P,
           (__v4sf) __A,
           (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_store_ps (void *__P, __mmask8 __U, __m256 __A)
{
  __builtin_ia32_storeaps256_mask ((__v8sf *) __P,
           (__v8sf) __A,
           (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_storeu_epi64 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_storedqudi128_mask ((__v2di *) __P,
             (__v2di) __A,
             (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_storeu_epi64 (void *__P, __mmask8 __U, __m256i __A)
{
  __builtin_ia32_storedqudi256_mask ((__v4di *) __P,
             (__v4di) __A,
             (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_storeu_epi32 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_storedqusi128_mask ((__v4si *) __P,
             (__v4si) __A,
             (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_storeu_epi32 (void *__P, __mmask8 __U, __m256i __A)
{
  __builtin_ia32_storedqusi256_mask ((__v8si *) __P,
             (__v8si) __A,
             (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_storeu_pd (void *__P, __mmask8 __U, __m128d __A)
{
  __builtin_ia32_storeupd128_mask ((__v2df *) __P,
           (__v2df) __A,
           (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_storeu_pd (void *__P, __mmask8 __U, __m256d __A)
{
  __builtin_ia32_storeupd256_mask ((__v4df *) __P,
           (__v4df) __A,
           (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_storeu_ps (void *__P, __mmask8 __U, __m128 __A)
{
  __builtin_ia32_storeups128_mask ((__v4sf *) __P,
           (__v4sf) __A,
           (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_storeu_ps (void *__P, __mmask8 __U, __m256 __A)
{
  __builtin_ia32_storeups256_mask ((__v8sf *) __P,
           (__v8sf) __A,
           (__mmask8) __U);
}


static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_unpackhi_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_unpackhi_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_unpackhi_pd(__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_unpackhi_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_unpackhi_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                           (__v4df)_mm256_unpackhi_pd(__A, __B),
                                           (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_unpackhi_pd(__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                           (__v4df)_mm256_unpackhi_pd(__A, __B),
                                           (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_unpackhi_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_unpackhi_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_unpackhi_ps(__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_unpackhi_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_unpackhi_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                           (__v8sf)_mm256_unpackhi_ps(__A, __B),
                                           (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_unpackhi_ps(__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                           (__v8sf)_mm256_unpackhi_ps(__A, __B),
                                           (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_unpacklo_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_unpacklo_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_unpacklo_pd(__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_unpacklo_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_unpacklo_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                           (__v4df)_mm256_unpacklo_pd(__A, __B),
                                           (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_unpacklo_pd(__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                           (__v4df)_mm256_unpacklo_pd(__A, __B),
                                           (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_unpacklo_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_unpacklo_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_unpacklo_ps(__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_unpacklo_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_unpacklo_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                           (__v8sf)_mm256_unpacklo_ps(__A, __B),
                                           (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_unpacklo_ps(__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                           (__v8sf)_mm256_unpacklo_ps(__A, __B),
                                           (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_rcp14_pd (__m128d __A)
{
  return (__m128d) __builtin_ia32_rcp14pd128_mask ((__v2df) __A,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_rcp14_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_rcp14pd128_mask ((__v2df) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_rcp14_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_rcp14pd128_mask ((__v2df) __A,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_rcp14_pd (__m256d __A)
{
  return (__m256d) __builtin_ia32_rcp14pd256_mask ((__v4df) __A,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_rcp14_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_rcp14pd256_mask ((__v4df) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_rcp14_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_rcp14pd256_mask ((__v4df) __A,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_rcp14_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rcp14ps128_mask ((__v4sf) __A,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_rcp14_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_rcp14ps128_mask ((__v4sf) __A,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_rcp14_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_rcp14ps128_mask ((__v4sf) __A,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_rcp14_ps (__m256 __A)
{
  return (__m256) __builtin_ia32_rcp14ps256_mask ((__v8sf) __A,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) -1);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_rcp14_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_rcp14ps256_mask ((__v8sf) __A,
               (__v8sf) __W,
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_rcp14_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_rcp14ps256_mask ((__v8sf) __A,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) __U);
}
# 6426 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_permutevar_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128i __C)
{
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                            (__v2df)_mm_permutevar_pd(__A, __C),
                                            (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_permutevar_pd(__mmask8 __U, __m128d __A, __m128i __C)
{
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                            (__v2df)_mm_permutevar_pd(__A, __C),
                                            (__v2df)_mm_setzero_pd());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutevar_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256i __C)
{
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                         (__v4df)_mm256_permutevar_pd(__A, __C),
                                         (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutevar_pd(__mmask8 __U, __m256d __A, __m256i __C)
{
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                         (__v4df)_mm256_permutevar_pd(__A, __C),
                                         (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_permutevar_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128i __C)
{
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                            (__v4sf)_mm_permutevar_ps(__A, __C),
                                            (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_permutevar_ps(__mmask8 __U, __m128 __A, __m128i __C)
{
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                            (__v4sf)_mm_permutevar_ps(__A, __C),
                                            (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutevar_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256i __C)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                          (__v8sf)_mm256_permutevar_ps(__A, __C),
                                          (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutevar_ps(__mmask8 __U, __m256 __A, __m256i __C)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                          (__v8sf)_mm256_permutevar_ps(__A, __C),
                                          (__v8sf)_mm256_setzero_ps());
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_test_epi32_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmd128 ((__v4si) __A,
                 (__v4si) __B,
                 (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_test_epi32_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmd128 ((__v4si) __A,
                 (__v4si) __B, __U);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_test_epi32_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestmd256 ((__v8si) __A,
                 (__v8si) __B,
                 (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_test_epi32_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestmd256 ((__v8si) __A,
                 (__v8si) __B, __U);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_test_epi64_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq128 ((__v2di) __A,
                 (__v2di) __B,
                 (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_test_epi64_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq128 ((__v2di) __A,
                 (__v2di) __B, __U);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_test_epi64_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq256 ((__v4di) __A,
                 (__v4di) __B,
                 (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_test_epi64_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq256 ((__v4di) __A,
                 (__v4di) __B, __U);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_testn_epi32_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmd128 ((__v4si) __A,
            (__v4si) __B,
            (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_testn_epi32_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmd128 ((__v4si) __A,
            (__v4si) __B, __U);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_testn_epi32_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmd256 ((__v8si) __A,
            (__v8si) __B,
            (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_testn_epi32_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmd256 ((__v8si) __A,
            (__v8si) __B, __U);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_testn_epi64_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq128 ((__v2di) __A,
            (__v2di) __B,
            (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_testn_epi64_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq128 ((__v2di) __A,
            (__v2di) __B, __U);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_testn_epi64_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq256 ((__v4di) __A,
            (__v4di) __B,
            (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_testn_epi64_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq256 ((__v4di) __A,
            (__v4di) __B, __U);
}



static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_unpackhi_epi32(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                           (__v4si)_mm_unpackhi_epi32(__A, __B),
                                           (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_unpackhi_epi32(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                           (__v4si)_mm_unpackhi_epi32(__A, __B),
                                           (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_unpackhi_epi32(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                        (__v8si)_mm256_unpackhi_epi32(__A, __B),
                                        (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_unpackhi_epi32(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                        (__v8si)_mm256_unpackhi_epi32(__A, __B),
                                        (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_unpackhi_epi64(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                           (__v2di)_mm_unpackhi_epi64(__A, __B),
                                           (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_unpackhi_epi64(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                           (__v2di)_mm_unpackhi_epi64(__A, __B),
                                           (__v2di)_mm_setzero_di());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_unpackhi_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                        (__v4di)_mm256_unpackhi_epi64(__A, __B),
                                        (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_unpackhi_epi64(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                        (__v4di)_mm256_unpackhi_epi64(__A, __B),
                                        (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_unpacklo_epi32(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                           (__v4si)_mm_unpacklo_epi32(__A, __B),
                                           (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_unpacklo_epi32(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                           (__v4si)_mm_unpacklo_epi32(__A, __B),
                                           (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_unpacklo_epi32(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                        (__v8si)_mm256_unpacklo_epi32(__A, __B),
                                        (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_unpacklo_epi32(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                        (__v8si)_mm256_unpacklo_epi32(__A, __B),
                                        (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_unpacklo_epi64(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                           (__v2di)_mm_unpacklo_epi64(__A, __B),
                                           (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_unpacklo_epi64(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                           (__v2di)_mm_unpacklo_epi64(__A, __B),
                                           (__v2di)_mm_setzero_di());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_unpacklo_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                        (__v4di)_mm256_unpacklo_epi64(__A, __B),
                                        (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_unpacklo_epi64(__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                        (__v4di)_mm256_unpacklo_epi64(__A, __B),
                                        (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sra_epi32(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_sra_epi32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sra_epi32(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_sra_epi32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sra_epi32(__m256i __W, __mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_sra_epi32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sra_epi32(__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_sra_epi32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_srai_epi32(__m128i __W, __mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_srai_epi32(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_srai_epi32(__mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_srai_epi32(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_srai_epi32(__m256i __W, __mmask8 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_srai_epi32(__A, __B),
                                             (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_srai_epi32(__mmask8 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                             (__v8si)_mm256_srai_epi32(__A, __B),
                                             (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_sra_epi64(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psraq128((__v2di)__A, (__v2di)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sra_epi64(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U, (__v2di)_mm_sra_epi64(__A, __B), (__v2di)__W);


}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sra_epi64(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U, (__v2di)_mm_sra_epi64(__A, __B), (__v2di)_mm_setzero_di());


}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_sra_epi64(__m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_psraq256((__v4di) __A, (__v2di) __B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sra_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U, (__v4di)_mm256_sra_epi64(__A, __B), (__v4di)__W);


}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sra_epi64(__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U, (__v4di)_mm256_sra_epi64(__A, __B), (__v4di)_mm256_setzero_si256());


}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_srai_epi64(__m128i __A, int __imm)
{
  return (__m128i)__builtin_ia32_psraqi128((__v2di)__A, __imm);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_srai_epi64(__m128i __W, __mmask8 __U, __m128i __A, int __imm)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U, (__v2di)_mm_srai_epi64(__A, __imm), (__v2di)__W);


}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_srai_epi64(__mmask8 __U, __m128i __A, int __imm)
{
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U, (__v2di)_mm_srai_epi64(__A, __imm), (__v2di)_mm_setzero_di());


}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_srai_epi64(__m256i __A, int __imm)
{
  return (__m256i)__builtin_ia32_psraqi256((__v4di)__A, __imm);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_srai_epi64(__m256i __W, __mmask8 __U, __m256i __A, int __imm)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U, (__v4di)_mm256_srai_epi64(__A, __imm), (__v4di)__W);


}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_srai_epi64(__mmask8 __U, __m256i __A, int __imm)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U, (__v4di)_mm256_srai_epi64(__A, __imm), (__v4di)_mm256_setzero_si256());


}
# 7087 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_rsqrt14_pd (__m128d __A)
{
  return (__m128d) __builtin_ia32_rsqrt14pd128_mask ((__v2df) __A,
                 (__v2df)
                 _mm_setzero_pd (),
                 (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_rsqrt14_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_rsqrt14pd128_mask ((__v2df) __A,
                 (__v2df) __W,
                 (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_rsqrt14_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_rsqrt14pd128_mask ((__v2df) __A,
                 (__v2df)
                 _mm_setzero_pd (),
                 (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_rsqrt14_pd (__m256d __A)
{
  return (__m256d) __builtin_ia32_rsqrt14pd256_mask ((__v4df) __A,
                 (__v4df)
                 _mm256_setzero_pd (),
                 (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_rsqrt14_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_rsqrt14pd256_mask ((__v4df) __A,
                 (__v4df) __W,
                 (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_rsqrt14_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_rsqrt14pd256_mask ((__v4df) __A,
                 (__v4df)
                 _mm256_setzero_pd (),
                 (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_rsqrt14_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrt14ps128_mask ((__v4sf) __A,
                (__v4sf)
                _mm_setzero_ps (),
                (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_rsqrt14_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_rsqrt14ps128_mask ((__v4sf) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_rsqrt14_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_rsqrt14ps128_mask ((__v4sf) __A,
                (__v4sf)
                _mm_setzero_ps (),
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_rsqrt14_ps (__m256 __A)
{
  return (__m256) __builtin_ia32_rsqrt14ps256_mask ((__v8sf) __A,
                (__v8sf)
                _mm256_setzero_ps (),
                (__mmask8) -1);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_rsqrt14_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_rsqrt14ps256_mask ((__v8sf) __A,
                (__v8sf) __W,
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_rsqrt14_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_rsqrt14ps256_mask ((__v8sf) __A,
                (__v8sf)
                _mm256_setzero_ps (),
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_broadcast_f32x4(__m128 __A)
{
  return (__m256)__builtin_shufflevector((__v4sf)__A, (__v4sf)__A,
                                         0, 1, 2, 3, 0, 1, 2, 3);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_broadcast_f32x4(__m256 __O, __mmask8 __M, __m128 __A)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__M,
                                            (__v8sf)_mm256_broadcast_f32x4(__A),
                                            (__v8sf)__O);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_broadcast_f32x4 (__mmask8 __M, __m128 __A)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__M,
                                            (__v8sf)_mm256_broadcast_f32x4(__A),
                                            (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_broadcast_i32x4(__m128i __A)
{
  return (__m256i)__builtin_shufflevector((__v4si)__A, (__v4si)__A,
                                          0, 1, 2, 3, 0, 1, 2, 3);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_broadcast_i32x4(__m256i __O, __mmask8 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                            (__v8si)_mm256_broadcast_i32x4(__A),
                                            (__v8si)__O);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_broadcast_i32x4(__mmask8 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__M,
                                            (__v8si)_mm256_broadcast_i32x4(__A),
                                            (__v8si)_mm256_setzero_si256());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_broadcastsd_pd (__m256d __O, __mmask8 __M, __m128d __A)
{
  return (__m256d)__builtin_ia32_selectpd_256(__M,
                                              (__v4df) _mm256_broadcastsd_pd(__A),
                                              (__v4df) __O);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_broadcastsd_pd (__mmask8 __M, __m128d __A)
{
  return (__m256d)__builtin_ia32_selectpd_256(__M,
                                              (__v4df) _mm256_broadcastsd_pd(__A),
                                              (__v4df) _mm256_setzero_pd());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_broadcastss_ps (__m128 __O, __mmask8 __M, __m128 __A)
{
  return (__m128)__builtin_ia32_selectps_128(__M,
                                             (__v4sf) _mm_broadcastss_ps(__A),
                                             (__v4sf) __O);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_broadcastss_ps (__mmask8 __M, __m128 __A)
{
  return (__m128)__builtin_ia32_selectps_128(__M,
                                             (__v4sf) _mm_broadcastss_ps(__A),
                                             (__v4sf) _mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_broadcastss_ps (__m256 __O, __mmask8 __M, __m128 __A)
{
  return (__m256)__builtin_ia32_selectps_256(__M,
                                             (__v8sf) _mm256_broadcastss_ps(__A),
                                             (__v8sf) __O);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_broadcastss_ps (__mmask8 __M, __m128 __A)
{
  return (__m256)__builtin_ia32_selectps_256(__M,
                                             (__v8sf) _mm256_broadcastss_ps(__A),
                                             (__v8sf) _mm256_setzero_ps());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_broadcastd_epi32 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectd_128(__M,
                                             (__v4si) _mm_broadcastd_epi32(__A),
                                             (__v4si) __O);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_broadcastd_epi32 (__mmask8 __M, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectd_128(__M,
                                             (__v4si) _mm_broadcastd_epi32(__A),
                                             (__v4si) _mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_broadcastd_epi32 (__m256i __O, __mmask8 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256(__M,
                                             (__v8si) _mm256_broadcastd_epi32(__A),
                                             (__v8si) __O);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_broadcastd_epi32 (__mmask8 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectd_256(__M,
                                             (__v8si) _mm256_broadcastd_epi32(__A),
                                             (__v8si) _mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_broadcastq_epi64 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectq_128(__M,
                                             (__v2di) _mm_broadcastq_epi64(__A),
                                             (__v2di) __O);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_broadcastq_epi64 (__mmask8 __M, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectq_128(__M,
                                             (__v2di) _mm_broadcastq_epi64(__A),
                                             (__v2di) _mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_broadcastq_epi64 (__m256i __O, __mmask8 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256(__M,
                                             (__v4di) _mm256_broadcastq_epi64(__A),
                                             (__v4di) __O);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_broadcastq_epi64 (__mmask8 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256(__M,
                                             (__v4di) _mm256_broadcastq_epi64(__A),
                                             (__v4di) _mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtsepi32_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb128_mask ((__v4si) __A,
               (__v16qi)_mm_undefined_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtsepi32_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb128_mask ((__v4si) __A,
               (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtsepi32_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb128_mask ((__v4si) __A,
               (__v16qi) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtsepi32_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovsdb128mem_mask ((__v16qi *) __P, (__v4si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtsepi32_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb256_mask ((__v8si) __A,
               (__v16qi)_mm_undefined_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtsepi32_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb256_mask ((__v8si) __A,
               (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtsepi32_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb256_mask ((__v8si) __A,
               (__v16qi) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtsepi32_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovsdb256mem_mask ((__v16qi *) __P, (__v8si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtsepi32_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw128_mask ((__v4si) __A,
               (__v8hi)_mm_setzero_si128 (),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtsepi32_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw128_mask ((__v4si) __A,
               (__v8hi)__O,
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtsepi32_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw128_mask ((__v4si) __A,
               (__v8hi) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtsepi32_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovsdw128mem_mask ((__v8hi *) __P, (__v4si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtsepi32_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw256_mask ((__v8si) __A,
               (__v8hi)_mm_undefined_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtsepi32_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw256_mask ((__v8si) __A,
               (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtsepi32_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw256_mask ((__v8si) __A,
               (__v8hi) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtsepi32_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovsdw256mem_mask ((__v8hi *) __P, (__v8si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtsepi64_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb128_mask ((__v2di) __A,
               (__v16qi)_mm_undefined_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtsepi64_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb128_mask ((__v2di) __A,
               (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtsepi64_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb128_mask ((__v2di) __A,
               (__v16qi) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtsepi64_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovsqb128mem_mask ((__v16qi *) __P, (__v2di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtsepi64_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb256_mask ((__v4di) __A,
               (__v16qi)_mm_undefined_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtsepi64_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb256_mask ((__v4di) __A,
               (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtsepi64_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb256_mask ((__v4di) __A,
               (__v16qi) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtsepi64_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovsqb256mem_mask ((__v16qi *) __P, (__v4di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtsepi64_epi32 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd128_mask ((__v2di) __A,
               (__v4si)_mm_undefined_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtsepi64_epi32 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd128_mask ((__v2di) __A,
               (__v4si) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtsepi64_epi32 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd128_mask ((__v2di) __A,
               (__v4si) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtsepi64_storeu_epi32 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovsqd128mem_mask ((__v4si *) __P, (__v2di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtsepi64_epi32 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd256_mask ((__v4di) __A,
               (__v4si)_mm_undefined_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtsepi64_epi32 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd256_mask ((__v4di) __A,
               (__v4si)__O,
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtsepi64_epi32 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd256_mask ((__v4di) __A,
               (__v4si) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtsepi64_storeu_epi32 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovsqd256mem_mask ((__v4si *) __P, (__v4di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtsepi64_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw128_mask ((__v2di) __A,
               (__v8hi)_mm_undefined_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtsepi64_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw128_mask ((__v2di) __A,
               (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtsepi64_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw128_mask ((__v2di) __A,
               (__v8hi) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtsepi64_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovsqw128mem_mask ((__v8hi *) __P, (__v2di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtsepi64_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw256_mask ((__v4di) __A,
               (__v8hi)_mm_undefined_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtsepi64_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw256_mask ((__v4di) __A,
               (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtsepi64_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw256_mask ((__v4di) __A,
               (__v8hi) _mm_setzero_si128 (),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtsepi64_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovsqw256mem_mask ((__v8hi *) __P, (__v4di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtusepi32_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb128_mask ((__v4si) __A,
                (__v16qi)_mm_undefined_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtusepi32_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb128_mask ((__v4si) __A,
                (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtusepi32_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb128_mask ((__v4si) __A,
                (__v16qi) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtusepi32_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovusdb128mem_mask ((__v16qi *) __P, (__v4si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtusepi32_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb256_mask ((__v8si) __A,
                (__v16qi)_mm_undefined_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtusepi32_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb256_mask ((__v8si) __A,
                (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtusepi32_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb256_mask ((__v8si) __A,
                (__v16qi) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtusepi32_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovusdb256mem_mask ((__v16qi*) __P, (__v8si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtusepi32_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw128_mask ((__v4si) __A,
                (__v8hi)_mm_undefined_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtusepi32_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw128_mask ((__v4si) __A,
                (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtusepi32_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw128_mask ((__v4si) __A,
                (__v8hi) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtusepi32_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovusdw128mem_mask ((__v8hi *) __P, (__v4si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtusepi32_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw256_mask ((__v8si) __A,
                (__v8hi) _mm_undefined_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtusepi32_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw256_mask ((__v8si) __A,
                (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtusepi32_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw256_mask ((__v8si) __A,
                (__v8hi) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtusepi32_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovusdw256mem_mask ((__v8hi *) __P, (__v8si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtusepi64_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb128_mask ((__v2di) __A,
                (__v16qi)_mm_undefined_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtusepi64_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb128_mask ((__v2di) __A,
                (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtusepi64_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb128_mask ((__v2di) __A,
                (__v16qi) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtusepi64_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovusqb128mem_mask ((__v16qi *) __P, (__v2di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtusepi64_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb256_mask ((__v4di) __A,
                (__v16qi)_mm_undefined_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtusepi64_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb256_mask ((__v4di) __A,
                (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtusepi64_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb256_mask ((__v4di) __A,
                (__v16qi) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtusepi64_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovusqb256mem_mask ((__v16qi *) __P, (__v4di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtusepi64_epi32 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd128_mask ((__v2di) __A,
                (__v4si)_mm_undefined_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtusepi64_epi32 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd128_mask ((__v2di) __A,
                (__v4si) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtusepi64_epi32 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd128_mask ((__v2di) __A,
                (__v4si) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtusepi64_storeu_epi32 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovusqd128mem_mask ((__v4si *) __P, (__v2di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtusepi64_epi32 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd256_mask ((__v4di) __A,
                (__v4si)_mm_undefined_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtusepi64_epi32 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd256_mask ((__v4di) __A,
                (__v4si) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtusepi64_epi32 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd256_mask ((__v4di) __A,
                (__v4si) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtusepi64_storeu_epi32 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovusqd256mem_mask ((__v4si *) __P, (__v4di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtusepi64_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw128_mask ((__v2di) __A,
                (__v8hi)_mm_undefined_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtusepi64_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw128_mask ((__v2di) __A,
                (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtusepi64_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw128_mask ((__v2di) __A,
                (__v8hi) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtusepi64_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovusqw128mem_mask ((__v8hi *) __P, (__v2di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtusepi64_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw256_mask ((__v4di) __A,
                (__v8hi)_mm_undefined_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtusepi64_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw256_mask ((__v4di) __A,
                (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtusepi64_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw256_mask ((__v4di) __A,
                (__v8hi) _mm_setzero_si128 (),
                __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtusepi64_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  return __builtin_ia32_pmovusqw256mem_mask ((__v8hi *) __P, (__v4di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtepi32_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdb128_mask ((__v4si) __A,
              (__v16qi)_mm_undefined_si128(),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi32_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdb128_mask ((__v4si) __A,
              (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi32_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdb128_mask ((__v4si) __A,
              (__v16qi)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi32_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovdb128mem_mask ((__v16qi *) __P, (__v4si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtepi32_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdb256_mask ((__v8si) __A,
              (__v16qi)_mm_undefined_si128(),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi32_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdb256_mask ((__v8si) __A,
              (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi32_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdb256_mask ((__v8si) __A,
              (__v16qi) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi32_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovdb256mem_mask ((__v16qi *) __P, (__v8si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtepi32_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdw128_mask ((__v4si) __A,
              (__v8hi) _mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi32_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdw128_mask ((__v4si) __A,
              (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi32_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdw128_mask ((__v4si) __A,
              (__v8hi) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi32_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovdw128mem_mask ((__v8hi *) __P, (__v4si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtepi32_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdw256_mask ((__v8si) __A,
              (__v8hi)_mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi32_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdw256_mask ((__v8si) __A,
              (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi32_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdw256_mask ((__v8si) __A,
              (__v8hi) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi32_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovdw256mem_mask ((__v8hi *) __P, (__v8si) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtepi64_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqb128_mask ((__v2di) __A,
              (__v16qi) _mm_undefined_si128(),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi64_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqb128_mask ((__v2di) __A,
              (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi64_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqb128_mask ((__v2di) __A,
              (__v16qi) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi64_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovqb128mem_mask ((__v16qi *) __P, (__v2di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtepi64_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqb256_mask ((__v4di) __A,
              (__v16qi) _mm_undefined_si128(),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi64_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqb256_mask ((__v4di) __A,
              (__v16qi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi64_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqb256_mask ((__v4di) __A,
              (__v16qi) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi64_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovqb256mem_mask ((__v16qi *) __P, (__v4di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtepi64_epi32 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqd128_mask ((__v2di) __A,
              (__v4si)_mm_undefined_si128(),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi64_epi32 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqd128_mask ((__v2di) __A,
              (__v4si) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi64_epi32 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqd128_mask ((__v2di) __A,
              (__v4si) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi64_storeu_epi32 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovqd128mem_mask ((__v4si *) __P, (__v2di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtepi64_epi32 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqd256_mask ((__v4di) __A,
              (__v4si) _mm_undefined_si128(),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi64_epi32 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqd256_mask ((__v4di) __A,
              (__v4si) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi64_epi32 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqd256_mask ((__v4di) __A,
              (__v4si) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi64_storeu_epi32 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovqd256mem_mask ((__v4si *) __P, (__v4di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtepi64_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqw128_mask ((__v2di) __A,
              (__v8hi) _mm_undefined_si128(),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi64_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqw128_mask ((__v2di) __A,
              (__v8hi)__O,
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi64_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqw128_mask ((__v2di) __A,
              (__v8hi) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi64_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovqw128mem_mask ((__v8hi *) __P, (__v2di) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtepi64_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqw256_mask ((__v4di) __A,
              (__v8hi)_mm_undefined_si128(),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi64_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqw256_mask ((__v4di) __A,
              (__v8hi) __O, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi64_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqw256_mask ((__v4di) __A,
              (__v8hi) _mm_setzero_si128 (),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi64_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovqw256mem_mask ((__v8hi *) __P, (__v4di) __A, __M);
}
# 8507 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutexvar_pd (__m256i __X, __m256d __Y)
{
  return (__m256d) __builtin_ia32_permvardf256_mask ((__v4df) __Y,
                 (__v4di) __X,
                 (__v4df) _mm256_undefined_si256 (),
                 (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutexvar_pd (__m256d __W, __mmask8 __U, __m256i __X,
          __m256d __Y)
{
  return (__m256d) __builtin_ia32_permvardf256_mask ((__v4df) __Y,
                 (__v4di) __X,
                 (__v4df) __W,
                 (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutexvar_pd (__mmask8 __U, __m256i __X, __m256d __Y)
{
  return (__m256d) __builtin_ia32_permvardf256_mask ((__v4df) __Y,
                 (__v4di) __X,
                 (__v4df) _mm256_setzero_pd (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutexvar_epi64 (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvardi256_mask ((__v4di) __Y,
                 (__v4di) __X,
                 (__v4di) _mm256_setzero_si256 (),
                 (__mmask8) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutexvar_epi64 ( __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvardi256_mask ((__v4di) __Y,
                 (__v4di) __X,
                 (__v4di) _mm256_undefined_si256 (),
                 (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutexvar_epi64 (__m256i __W, __mmask8 __M, __m256i __X,
             __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvardi256_mask ((__v4di) __Y,
                 (__v4di) __X,
                 (__v4di) __W,
                 __M);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutexvar_ps (__m256 __W, __mmask8 __U, __m256i __X,
          __m256 __Y)
{
  return (__m256) __builtin_ia32_permvarsf256_mask ((__v8sf) __Y,
                (__v8si) __X,
                (__v8sf) __W,
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutexvar_ps (__mmask8 __U, __m256i __X, __m256 __Y)
{
  return (__m256) __builtin_ia32_permvarsf256_mask ((__v8sf) __Y,
                (__v8si) __X,
                (__v8sf) _mm256_setzero_ps (),
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutexvar_ps (__m256i __X, __m256 __Y)
{
  return (__m256) __builtin_ia32_permvarsf256_mask ((__v8sf) __Y,
                (__v8si) __X,
                (__v8sf) _mm256_undefined_si256 (),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutexvar_epi32 (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvarsi256_mask ((__v8si) __Y,
                 (__v8si) __X,
                 (__v8si) _mm256_setzero_si256 (),
                 __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutexvar_epi32 (__m256i __W, __mmask8 __M, __m256i __X,
             __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvarsi256_mask ((__v8si) __Y,
                 (__v8si) __X,
                 (__v8si) __W,
                 (__mmask8) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutexvar_epi32 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvarsi256_mask ((__v8si) __Y,
                 (__v8si) __X,
                 (__v8si) _mm256_undefined_si256(),
                 (__mmask8) -1);
}
# 8693 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_movehdup_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_movehdup_ps(__A),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_movehdup_ps (__mmask8 __U, __m128 __A)
{
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_movehdup_ps(__A),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_movehdup_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_movehdup_ps(__A),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_movehdup_ps (__mmask8 __U, __m256 __A)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_movehdup_ps(__A),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_moveldup_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_moveldup_ps(__A),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_moveldup_ps (__mmask8 __U, __m128 __A)
{
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_moveldup_ps(__A),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_moveldup_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_moveldup_ps(__A),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_moveldup_ps (__mmask8 __U, __m256 __A)
{
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_moveldup_ps(__A),
                                             (__v8sf)_mm256_setzero_ps());
}
# 8777 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mov_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_selectpd_128 ((__mmask8) __U,
              (__v2df) __A,
              (__v2df) __W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mov_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_selectpd_128 ((__mmask8) __U,
              (__v2df) __A,
              (__v2df) _mm_setzero_pd ());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mov_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_selectpd_256 ((__mmask8) __U,
              (__v4df) __A,
              (__v4df) __W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mov_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_selectpd_256 ((__mmask8) __U,
              (__v4df) __A,
              (__v4df) _mm256_setzero_pd ());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mov_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_selectps_128 ((__mmask8) __U,
             (__v4sf) __A,
             (__v4sf) __W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mov_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_selectps_128 ((__mmask8) __U,
             (__v4sf) __A,
             (__v4sf) _mm_setzero_ps ());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mov_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_selectps_256 ((__mmask8) __U,
             (__v8sf) __A,
             (__v8sf) __W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mov_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_selectps_256 ((__mmask8) __U,
             (__v8sf) __A,
             (__v8sf) _mm256_setzero_ps ());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtph_ps (__m128 __W, __mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_vcvtph2ps_mask ((__v8hi) __A,
             (__v4sf) __W,
             (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtph_ps (__mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_vcvtph2ps_mask ((__v8hi) __A,
             (__v4sf)
             _mm_setzero_ps (),
             (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtph_ps (__m256 __W, __mmask8 __U, __m128i __A)
{
  return (__m256) __builtin_ia32_vcvtph2ps256_mask ((__v8hi) __A,
                (__v8sf) __W,
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtph_ps (__mmask8 __U, __m128i __A)
{
  return (__m256) __builtin_ia32_vcvtph2ps256_mask ((__v8hi) __A,
                (__v8sf)
                _mm256_setzero_ps (),
                (__mmask8) __U);
}

static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtps_ph (__m128i __W, __mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_vcvtps2ph_mask ((__v4sf) __A, 0x04,
                                                  (__v8hi) __W,
                                                  (__mmask8) __U);
}

static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtps_ph (__mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_vcvtps2ph_mask ((__v4sf) __A, 0x04,
                                                  (__v8hi) _mm_setzero_si128 (),
                                                  (__mmask8) __U);
}
# 8901 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtps_ph (__m128i __W, __mmask8 __U, __m256 __A)
{
  return (__m128i) __builtin_ia32_vcvtps2ph256_mask ((__v8sf) __A, 0x04,
                                                      (__v8hi) __W,
                                                      (__mmask8) __U);
}

static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtps_ph ( __mmask8 __U, __m256 __A)
{
  return (__m128i) __builtin_ia32_vcvtps2ph256_mask ((__v8sf) __A, 0x04,
                                                      (__v8hi) _mm_setzero_si128(),
                                                      (__mmask8) __U);
}
# 139 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512bwintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512bwintrin.h" 3 4
typedef unsigned int __mmask32;
typedef unsigned long long __mmask64;




static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_setzero_qi(void) {
  return (__m512i)(__v64qi){ 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0 };
}

static inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_setzero_hi(void) {
  return (__m512i)(__v32hi){ 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0 };
}



static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpeq_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_pcmpeqb512_mask((__v64qi)__a, (__v64qi)__b,
                                                   (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpeq_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_pcmpeqb512_mask((__v64qi)__a, (__v64qi)__b,
                                                   __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpeq_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 0,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpeq_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 0,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpeq_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_pcmpeqw512_mask((__v32hi)__a, (__v32hi)__b,
                                                   (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpeq_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_pcmpeqw512_mask((__v32hi)__a, (__v32hi)__b,
                                                   __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpeq_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 0,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpeq_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 0,
                                                 __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpge_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 5,
                                                (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpge_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 5,
                                                __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpge_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 5,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpge_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 5,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpge_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 5,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpge_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 5,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpge_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 5,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpge_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 5,
                                                 __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpgt_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_pcmpgtb512_mask((__v64qi)__a, (__v64qi)__b,
                                                   (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpgt_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_pcmpgtb512_mask((__v64qi)__a, (__v64qi)__b,
                                                   __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpgt_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 6,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpgt_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 6,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpgt_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_pcmpgtw512_mask((__v32hi)__a, (__v32hi)__b,
                                                   (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpgt_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_pcmpgtw512_mask((__v32hi)__a, (__v32hi)__b,
                                                   __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpgt_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 6,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpgt_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 6,
                                                 __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmple_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 2,
                                                (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmple_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 2,
                                                __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmple_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 2,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmple_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 2,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmple_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 2,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmple_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 2,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmple_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 2,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmple_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 2,
                                                 __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmplt_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 1,
                                                (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmplt_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 1,
                                                __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmplt_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 1,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmplt_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 1,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmplt_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 1,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmplt_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 1,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmplt_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 1,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmplt_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 1,
                                                 __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpneq_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 4,
                                                (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpneq_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 4,
                                                __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpneq_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 4,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpneq_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 4,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpneq_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 4,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpneq_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 4,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpneq_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 4,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpneq_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 4,
                                                 __u);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_add_epi8 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v64qu) __A + (__v64qu) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_add_epi8(__m512i __W, __mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__U,
                                             (__v64qi)_mm512_add_epi8(__A, __B),
                                             (__v64qi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_add_epi8(__mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__U,
                                             (__v64qi)_mm512_add_epi8(__A, __B),
                                             (__v64qi)_mm512_setzero_qi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_sub_epi8 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v64qu) __A - (__v64qu) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_sub_epi8(__m512i __W, __mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__U,
                                             (__v64qi)_mm512_sub_epi8(__A, __B),
                                             (__v64qi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_sub_epi8(__mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__U,
                                             (__v64qi)_mm512_sub_epi8(__A, __B),
                                             (__v64qi)_mm512_setzero_qi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_add_epi16 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v32hu) __A + (__v32hu) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_add_epi16(__m512i __W, __mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                             (__v32hi)_mm512_add_epi16(__A, __B),
                                             (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_add_epi16(__mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                             (__v32hi)_mm512_add_epi16(__A, __B),
                                             (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_sub_epi16 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v32hu) __A - (__v32hu) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_sub_epi16(__m512i __W, __mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                             (__v32hi)_mm512_sub_epi16(__A, __B),
                                             (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_sub_epi16(__mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                             (__v32hi)_mm512_sub_epi16(__A, __B),
                                             (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mullo_epi16 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v32hu) __A * (__v32hu) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_mullo_epi16(__m512i __W, __mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                             (__v32hi)_mm512_mullo_epi16(__A, __B),
                                             (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_mullo_epi16(__mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                             (__v32hi)_mm512_mullo_epi16(__A, __B),
                                             (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_blend_epi8 (__mmask64 __U, __m512i __A, __m512i __W)
{
  return (__m512i) __builtin_ia32_selectb_512 ((__mmask64) __U,
              (__v64qi) __W,
              (__v64qi) __A);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_blend_epi16 (__mmask32 __U, __m512i __A, __m512i __W)
{
  return (__m512i) __builtin_ia32_selectw_512 ((__mmask32) __U,
              (__v32hi) __W,
              (__v32hi) __A);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_abs_epi8 (__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsb512_mask ((__v64qi) __A,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_abs_epi8 (__m512i __W, __mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsb512_mask ((__v64qi) __A,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_abs_epi8 (__mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsb512_mask ((__v64qi) __A,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_abs_epi16 (__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsw512_mask ((__v32hi) __A,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_abs_epi16 (__m512i __W, __mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsw512_mask ((__v32hi) __A,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_abs_epi16 (__mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsw512_mask ((__v32hi) __A,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_packs_epi32(__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_packssdw512((__v16si)__A, (__v16si)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_packs_epi32(__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__M,
                                       (__v32hi)_mm512_packs_epi32(__A, __B),
                                       (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_packs_epi32(__m512i __W, __mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__M,
                                       (__v32hi)_mm512_packs_epi32(__A, __B),
                                       (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_packs_epi16(__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_packsswb512((__v32hi)__A, (__v32hi) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_packs_epi16(__m512i __W, __mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__M,
                                        (__v64qi)_mm512_packs_epi16(__A, __B),
                                        (__v64qi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_packs_epi16(__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__M,
                                        (__v64qi)_mm512_packs_epi16(__A, __B),
                                        (__v64qi)_mm512_setzero_qi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_packus_epi32(__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_packusdw512((__v16si) __A, (__v16si) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_packus_epi32(__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__M,
                                       (__v32hi)_mm512_packus_epi32(__A, __B),
                                       (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_packus_epi32(__m512i __W, __mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__M,
                                       (__v32hi)_mm512_packus_epi32(__A, __B),
                                       (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_packus_epi16(__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_packuswb512((__v32hi) __A, (__v32hi) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_packus_epi16(__m512i __W, __mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__M,
                                        (__v64qi)_mm512_packus_epi16(__A, __B),
                                        (__v64qi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_packus_epi16(__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__M,
                                        (__v64qi)_mm512_packus_epi16(__A, __B),
                                        (__v64qi)_mm512_setzero_qi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_adds_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_adds_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_adds_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_adds_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_adds_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
      __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_adds_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_adds_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_adds_epu8 (__m512i __W, __mmask64 __U, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_adds_epu8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_adds_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_adds_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
      __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_adds_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_avg_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_avg_epu8 (__m512i __W, __mmask64 __U, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_avg_epu8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_avg_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_avg_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_avg_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_max_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_max_epi8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_max_epi8 (__m512i __W, __mmask64 __M, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_max_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_max_epi16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_max_epi16 (__m512i __W, __mmask32 __M, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_max_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_max_epu8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_max_epu8 (__m512i __W, __mmask64 __M, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_max_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_max_epu16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_max_epu16 (__m512i __W, __mmask32 __M, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_min_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_min_epi8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_min_epi8 (__m512i __W, __mmask64 __M, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_min_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_min_epi16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_min_epi16 (__m512i __W, __mmask32 __M, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_min_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_min_epu8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_min_epu8 (__m512i __W, __mmask64 __M, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_pminub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_min_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_min_epu16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_min_epu16 (__m512i __W, __mmask32 __M, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_shuffle_epi8(__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_pshufb512((__v64qi)__A,(__v64qi)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_shuffle_epi8(__m512i __W, __mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__U,
                                         (__v64qi)_mm512_shuffle_epi8(__A, __B),
                                         (__v64qi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_shuffle_epi8(__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__U,
                                         (__v64qi)_mm512_shuffle_epi8(__A, __B),
                                         (__v64qi)_mm512_setzero_qi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_subs_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_subs_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_subs_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_subs_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_subs_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
      __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_subs_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_subs_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_subs_epu8 (__m512i __W, __mmask64 __U, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_subs_epu8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_subs_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_subs_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
      __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_subs_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask2_permutex2var_epi16 (__m512i __A, __m512i __I,
         __mmask32 __U, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermi2varhi512_mask ((__v32hi) __A,
              (__v32hi) __I ,
              (__v32hi) __B,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_permutex2var_epi16 (__m512i __A, __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varhi512_mask ((__v32hi) __I ,
              (__v32hi) __A,
              (__v32hi) __B,
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_permutex2var_epi16 (__m512i __A, __mmask32 __U,
        __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varhi512_mask ((__v32hi) __I ,
              (__v32hi) __A,
              (__v32hi) __B,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_permutex2var_epi16 (__mmask32 __U, __m512i __A,
         __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varhi512_maskz ((__v32hi) __I
                        ,
              (__v32hi) __A,
              (__v32hi) __B,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mulhrs_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhrsw512_mask ((__v32hi) __A,
                (__v32hi) __B,
                (__v32hi) _mm512_setzero_hi(),
                (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_mulhrs_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhrsw512_mask ((__v32hi) __A,
                (__v32hi) __B,
                (__v32hi) __W,
                (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_mulhrs_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhrsw512_mask ((__v32hi) __A,
                (__v32hi) __B,
                (__v32hi) _mm512_setzero_hi(),
                (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mulhi_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_mulhi_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
       __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_mulhi_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mulhi_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhuw512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v32hi) _mm512_setzero_hi(),
               (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_mulhi_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
       __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhuw512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v32hi) __W,
               (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_mulhi_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhuw512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v32hi) _mm512_setzero_hi(),
               (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maddubs_epi16 (__m512i __X, __m512i __Y) {
  return (__m512i) __builtin_ia32_pmaddubsw512_mask ((__v64qi) __X,
                 (__v64qi) __Y,
                 (__v32hi) _mm512_setzero_hi(),
                 (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_maddubs_epi16 (__m512i __W, __mmask32 __U, __m512i __X,
         __m512i __Y) {
  return (__m512i) __builtin_ia32_pmaddubsw512_mask ((__v64qi) __X,
                 (__v64qi) __Y,
                 (__v32hi) __W,
                 (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_maddubs_epi16 (__mmask32 __U, __m512i __X, __m512i __Y) {
  return (__m512i) __builtin_ia32_pmaddubsw512_mask ((__v64qi) __X,
                 (__v64qi) __Y,
                 (__v32hi) _mm512_setzero_hi(),
                 (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_madd_epi16 (__m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_pmaddwd512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v16si) _mm512_setzero_si512(),
               (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_madd_epi16 (__m512i __W, __mmask16 __U, __m512i __A,
      __m512i __B) {
  return (__m512i) __builtin_ia32_pmaddwd512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v16si) __W,
               (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_madd_epi16 (__mmask16 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_pmaddwd512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v16si) _mm512_setzero_si512(),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cvtsepi16_epi8 (__m512i __A) {
  return (__m256i) __builtin_ia32_pmovswb512_mask ((__v32hi) __A,
               (__v32qi)_mm256_setzero_si256(),
               (__mmask32) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cvtsepi16_epi8 (__m256i __O, __mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovswb512_mask ((__v32hi) __A,
               (__v32qi)__O,
               __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_cvtsepi16_epi8 (__mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovswb512_mask ((__v32hi) __A,
               (__v32qi) _mm256_setzero_si256(),
               __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cvtusepi16_epi8 (__m512i __A) {
  return (__m256i) __builtin_ia32_pmovuswb512_mask ((__v32hi) __A,
                (__v32qi) _mm256_setzero_si256(),
                (__mmask32) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cvtusepi16_epi8 (__m256i __O, __mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovuswb512_mask ((__v32hi) __A,
                (__v32qi) __O,
                __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_cvtusepi16_epi8 (__mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovuswb512_mask ((__v32hi) __A,
                (__v32qi) _mm256_setzero_si256(),
                __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cvtepi16_epi8 (__m512i __A) {
  return (__m256i) __builtin_ia32_pmovwb512_mask ((__v32hi) __A,
              (__v32qi) _mm256_setzero_si256(),
              (__mmask32) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cvtepi16_epi8 (__m256i __O, __mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovwb512_mask ((__v32hi) __A,
              (__v32qi) __O,
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_cvtepi16_epi8 (__mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovwb512_mask ((__v32hi) __A,
              (__v32qi) _mm256_setzero_si256(),
              __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cvtepi16_storeu_epi8 (void * __P, __mmask32 __M, __m512i __A)
{
  __builtin_ia32_pmovwb512mem_mask ((__v32qi *) __P, (__v32hi) __A, __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cvtsepi16_storeu_epi8 (void * __P, __mmask32 __M, __m512i __A)
{
  __builtin_ia32_pmovswb512mem_mask ((__v32qi *) __P, (__v32hi) __A, __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cvtusepi16_storeu_epi8 (void * __P, __mmask32 __M, __m512i __A)
{
  __builtin_ia32_pmovuswb512mem_mask ((__v32qi *) __P, (__v32hi) __A, __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_unpackhi_epi8(__m512i __A, __m512i __B) {
  return (__m512i)__builtin_shufflevector((__v64qi)__A, (__v64qi)__B,
                                          8, 64+8, 9, 64+9,
                                          10, 64+10, 11, 64+11,
                                          12, 64+12, 13, 64+13,
                                          14, 64+14, 15, 64+15,
                                          24, 64+24, 25, 64+25,
                                          26, 64+26, 27, 64+27,
                                          28, 64+28, 29, 64+29,
                                          30, 64+30, 31, 64+31,
                                          40, 64+40, 41, 64+41,
                                          42, 64+42, 43, 64+43,
                                          44, 64+44, 45, 64+45,
                                          46, 64+46, 47, 64+47,
                                          56, 64+56, 57, 64+57,
                                          58, 64+58, 59, 64+59,
                                          60, 64+60, 61, 64+61,
                                          62, 64+62, 63, 64+63);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_unpackhi_epi8(__m512i __W, __mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__U,
                                        (__v64qi)_mm512_unpackhi_epi8(__A, __B),
                                        (__v64qi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_unpackhi_epi8(__mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__U,
                                        (__v64qi)_mm512_unpackhi_epi8(__A, __B),
                                        (__v64qi)_mm512_setzero_qi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_unpackhi_epi16(__m512i __A, __m512i __B) {
  return (__m512i)__builtin_shufflevector((__v32hi)__A, (__v32hi)__B,
                                          4, 32+4, 5, 32+5,
                                          6, 32+6, 7, 32+7,
                                          12, 32+12, 13, 32+13,
                                          14, 32+14, 15, 32+15,
                                          20, 32+20, 21, 32+21,
                                          22, 32+22, 23, 32+23,
                                          28, 32+28, 29, 32+29,
                                          30, 32+30, 31, 32+31);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_unpackhi_epi16(__m512i __W, __mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                       (__v32hi)_mm512_unpackhi_epi16(__A, __B),
                                       (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_unpackhi_epi16(__mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                       (__v32hi)_mm512_unpackhi_epi16(__A, __B),
                                       (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_unpacklo_epi8(__m512i __A, __m512i __B) {
  return (__m512i)__builtin_shufflevector((__v64qi)__A, (__v64qi)__B,
                                          0, 64+0, 1, 64+1,
                                          2, 64+2, 3, 64+3,
                                          4, 64+4, 5, 64+5,
                                          6, 64+6, 7, 64+7,
                                          16, 64+16, 17, 64+17,
                                          18, 64+18, 19, 64+19,
                                          20, 64+20, 21, 64+21,
                                          22, 64+22, 23, 64+23,
                                          32, 64+32, 33, 64+33,
                                          34, 64+34, 35, 64+35,
                                          36, 64+36, 37, 64+37,
                                          38, 64+38, 39, 64+39,
                                          48, 64+48, 49, 64+49,
                                          50, 64+50, 51, 64+51,
                                          52, 64+52, 53, 64+53,
                                          54, 64+54, 55, 64+55);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_unpacklo_epi8(__m512i __W, __mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__U,
                                        (__v64qi)_mm512_unpacklo_epi8(__A, __B),
                                        (__v64qi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_unpacklo_epi8(__mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectb_512((__mmask64)__U,
                                        (__v64qi)_mm512_unpacklo_epi8(__A, __B),
                                        (__v64qi)_mm512_setzero_qi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_unpacklo_epi16(__m512i __A, __m512i __B) {
  return (__m512i)__builtin_shufflevector((__v32hi)__A, (__v32hi)__B,
                                          0, 32+0, 1, 32+1,
                                          2, 32+2, 3, 32+3,
                                          8, 32+8, 9, 32+9,
                                          10, 32+10, 11, 32+11,
                                          16, 32+16, 17, 32+17,
                                          18, 32+18, 19, 32+19,
                                          24, 32+24, 25, 32+25,
                                          26, 32+26, 27, 32+27);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_unpacklo_epi16(__m512i __W, __mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                       (__v32hi)_mm512_unpacklo_epi16(__A, __B),
                                       (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_unpacklo_epi16(__mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                       (__v32hi)_mm512_unpacklo_epi16(__A, __B),
                                       (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cvtepi8_epi16(__m256i __A)
{


  return (__m512i)__builtin_convertvector((__v32qs)__A, __v32hi);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cvtepi8_epi16(__m512i __W, __mmask32 __U, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                             (__v32hi)_mm512_cvtepi8_epi16(__A),
                                             (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_cvtepi8_epi16(__mmask32 __U, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                             (__v32hi)_mm512_cvtepi8_epi16(__A),
                                             (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cvtepu8_epi16(__m256i __A)
{
  return (__m512i)__builtin_convertvector((__v32qu)__A, __v32hi);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cvtepu8_epi16(__m512i __W, __mmask32 __U, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                             (__v32hi)_mm512_cvtepu8_epi16(__A),
                                             (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_cvtepu8_epi16(__mmask32 __U, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                             (__v32hi)_mm512_cvtepu8_epi16(__A),
                                             (__v32hi)_mm512_setzero_hi());
}
# 1660 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512bwintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_sllv_epi16(__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_psllv32hi((__v32hi) __A, (__v32hi) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_sllv_epi16 (__m512i __W, __mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                           (__v32hi)_mm512_sllv_epi16(__A, __B),
                                           (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_sllv_epi16(__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                           (__v32hi)_mm512_sllv_epi16(__A, __B),
                                           (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_sll_epi16(__m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_psllw512((__v32hi) __A, (__v8hi) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_sll_epi16(__m512i __W, __mmask32 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                          (__v32hi)_mm512_sll_epi16(__A, __B),
                                          (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_sll_epi16(__mmask32 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                          (__v32hi)_mm512_sll_epi16(__A, __B),
                                          (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_slli_epi16(__m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_psllwi512((__v32hi)__A, __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_slli_epi16(__m512i __W, __mmask32 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                         (__v32hi)_mm512_slli_epi16(__A, __B),
                                         (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_slli_epi16(__mmask32 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                         (__v32hi)_mm512_slli_epi16(__A, __B),
                                         (__v32hi)_mm512_setzero_hi());
}
# 1795 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512bwintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_srlv_epi16(__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_psrlv32hi((__v32hi)__A, (__v32hi)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_srlv_epi16(__m512i __W, __mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                           (__v32hi)_mm512_srlv_epi16(__A, __B),
                                           (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_srlv_epi16(__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                           (__v32hi)_mm512_srlv_epi16(__A, __B),
                                           (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_srav_epi16(__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_psrav32hi((__v32hi)__A, (__v32hi)__B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_srav_epi16(__m512i __W, __mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                           (__v32hi)_mm512_srav_epi16(__A, __B),
                                           (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_srav_epi16(__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                           (__v32hi)_mm512_srav_epi16(__A, __B),
                                           (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_sra_epi16(__m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_psraw512((__v32hi) __A, (__v8hi) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_sra_epi16(__m512i __W, __mmask32 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                          (__v32hi)_mm512_sra_epi16(__A, __B),
                                          (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_sra_epi16(__mmask32 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                          (__v32hi)_mm512_sra_epi16(__A, __B),
                                          (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_srai_epi16(__m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_psrawi512((__v32hi)__A, __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_srai_epi16(__m512i __W, __mmask32 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                         (__v32hi)_mm512_srai_epi16(__A, __B),
                                         (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_srai_epi16(__mmask32 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                         (__v32hi)_mm512_srai_epi16(__A, __B),
                                         (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_srl_epi16(__m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_psrlw512((__v32hi) __A, (__v8hi) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_srl_epi16(__m512i __W, __mmask32 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                          (__v32hi)_mm512_srl_epi16(__A, __B),
                                          (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_srl_epi16(__mmask32 __U, __m512i __A, __m128i __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                          (__v32hi)_mm512_srl_epi16(__A, __B),
                                          (__v32hi)_mm512_setzero_hi());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_srli_epi16(__m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_psrlwi512((__v32hi)__A, __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_srli_epi16(__m512i __W, __mmask32 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                         (__v32hi)_mm512_srli_epi16(__A, __B),
                                         (__v32hi)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_srli_epi16(__mmask32 __U, __m512i __A, int __B)
{
  return (__m512i)__builtin_ia32_selectw_512((__mmask32)__U,
                                         (__v32hi)_mm512_srli_epi16(__A, __B),
                                         (__v32hi)_mm512_setzero_hi());
}
# 1996 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512bwintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_mov_epi16 (__m512i __W, __mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_selectw_512 ((__mmask32) __U,
                (__v32hi) __A,
                (__v32hi) __W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_mov_epi16 (__mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_selectw_512 ((__mmask32) __U,
                (__v32hi) __A,
                (__v32hi) _mm512_setzero_hi ());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_mov_epi8 (__m512i __W, __mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_selectb_512 ((__mmask64) __U,
                (__v64qi) __A,
                (__v64qi) __W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_mov_epi8 (__mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_selectb_512 ((__mmask64) __U,
                (__v64qi) __A,
                (__v64qi) _mm512_setzero_hi ());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_set1_epi8 (__m512i __O, __mmask64 __M, char __A)
{
  return (__m512i) __builtin_ia32_pbroadcastb512_gpr_mask (__A,
                 (__v64qi) __O,
                 __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_set1_epi8 (__mmask64 __M, char __A)
{
  return (__m512i) __builtin_ia32_pbroadcastb512_gpr_mask (__A,
                 (__v64qi)
                 _mm512_setzero_qi(),
                 __M);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_kunpackd (__mmask64 __A, __mmask64 __B)
{
  return (__mmask64) __builtin_ia32_kunpckdi ((__mmask64) __A,
                (__mmask64) __B);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_kunpackw (__mmask32 __A, __mmask32 __B)
{
  return (__mmask32) __builtin_ia32_kunpcksi ((__mmask32) __A,
                (__mmask32) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_loadu_epi16 (__m512i __W, __mmask32 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddquhi512_mask ((__v32hi *) __P,
                 (__v32hi) __W,
                 (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_loadu_epi16 (__mmask32 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddquhi512_mask ((__v32hi *) __P,
                 (__v32hi)
                 _mm512_setzero_hi (),
                 (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_loadu_epi8 (__m512i __W, __mmask64 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddquqi512_mask ((__v64qi *) __P,
                 (__v64qi) __W,
                 (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_loadu_epi8 (__mmask64 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddquqi512_mask ((__v64qi *) __P,
                 (__v64qi)
                 _mm512_setzero_hi (),
                 (__mmask64) __U);
}
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_storeu_epi16 (void *__P, __mmask32 __U, __m512i __A)
{
  __builtin_ia32_storedquhi512_mask ((__v32hi *) __P,
             (__v32hi) __A,
             (__mmask32) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_storeu_epi8 (void *__P, __mmask64 __U, __m512i __A)
{
  __builtin_ia32_storedquqi512_mask ((__v64qi *) __P,
             (__v64qi) __A,
             (__mmask64) __U);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_test_epi8_mask (__m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ptestmb512 ((__v64qi) __A,
            (__v64qi) __B,
            (__mmask64) -1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_test_epi8_mask (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ptestmb512 ((__v64qi) __A,
            (__v64qi) __B, __U);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_test_epi16_mask (__m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ptestmw512 ((__v32hi) __A,
            (__v32hi) __B,
            (__mmask32) -1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_test_epi16_mask (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ptestmw512 ((__v32hi) __A,
            (__v32hi) __B, __U);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_testn_epi8_mask (__m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ptestnmb512 ((__v64qi) __A,
             (__v64qi) __B,
             (__mmask64) -1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_testn_epi8_mask (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ptestnmb512 ((__v64qi) __A,
             (__v64qi) __B, __U);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_testn_epi16_mask (__m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ptestnmw512 ((__v32hi) __A,
             (__v32hi) __B,
             (__mmask32) -1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_testn_epi16_mask (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ptestnmw512 ((__v32hi) __A,
             (__v32hi) __B, __U);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_movepi8_mask (__m512i __A)
{
  return (__mmask64) __builtin_ia32_cvtb2mask512 ((__v64qi) __A);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_movepi16_mask (__m512i __A)
{
  return (__mmask32) __builtin_ia32_cvtw2mask512 ((__v32hi) __A);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_movm_epi8 (__mmask64 __A)
{
  return (__m512i) __builtin_ia32_cvtmask2b512 (__A);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_movm_epi16 (__mmask32 __A)
{
  return (__m512i) __builtin_ia32_cvtmask2w512 (__A);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_broadcastb_epi8 (__m128i __A)
{
  return (__m512i)__builtin_shufflevector((__v16qi) __A,
                                          (__v16qi)_mm_undefined_si128(),
                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_broadcastb_epi8 (__m512i __O, __mmask64 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectb_512(__M,
                                             (__v64qi) _mm512_broadcastb_epi8(__A),
                                             (__v64qi) __O);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_broadcastb_epi8 (__mmask64 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectb_512(__M,
                                             (__v64qi) _mm512_broadcastb_epi8(__A),
                                             (__v64qi) _mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_set1_epi16 (__m512i __O, __mmask32 __M, short __A)
{
  return (__m512i) __builtin_ia32_pbroadcastw512_gpr_mask (__A,
                 (__v32hi) __O,
                 __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_set1_epi16 (__mmask32 __M, short __A)
{
  return (__m512i) __builtin_ia32_pbroadcastw512_gpr_mask (__A,
                 (__v32hi) _mm512_setzero_hi(),
                 __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_broadcastw_epi16 (__m128i __A)
{
  return (__m512i)__builtin_shufflevector((__v8hi) __A,
                                          (__v8hi)_mm_undefined_si128(),
                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_broadcastw_epi16 (__m512i __O, __mmask32 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectw_512(__M,
                                             (__v32hi) _mm512_broadcastw_epi16(__A),
                                             (__v32hi) __O);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_broadcastw_epi16 (__mmask32 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectw_512(__M,
                                             (__v32hi) _mm512_broadcastw_epi16(__A),
                                             (__v32hi) _mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_permutexvar_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarhi512_mask ((__v32hi) __B,
                 (__v32hi) __A,
                 (__v32hi) _mm512_undefined_epi32 (),
                 (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_permutexvar_epi16 (__mmask32 __M, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarhi512_mask ((__v32hi) __B,
                 (__v32hi) __A,
                 (__v32hi) _mm512_setzero_hi(),
                 (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_permutexvar_epi16 (__m512i __W, __mmask32 __M, __m512i __A,
             __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarhi512_mask ((__v32hi) __B,
                 (__v32hi) __A,
                 (__v32hi) __W,
                 (__mmask32) __M);
}
# 2325 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512bwintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_sad_epu8 (__m512i __A, __m512i __B)
{
 return (__m512i) __builtin_ia32_psadbw512 ((__v64qi) __A,
               (__v64qi) __B);
}
# 143 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512cdintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512cdintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_conflict_epi64 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictdi_512_mask ((__v8di) __A,
                 (__v8di) _mm512_setzero_si512 (),
                 (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_mask_conflict_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictdi_512_mask ((__v8di) __A,
               (__v8di) __W,
               (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_maskz_conflict_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictdi_512_mask ((__v8di) __A,
                 (__v8di) _mm512_setzero_si512 (),
                 (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_conflict_epi32 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictsi_512_mask ((__v16si) __A,
                 (__v16si) _mm512_setzero_si512 (),
                 (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_mask_conflict_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictsi_512_mask ((__v16si) __A,
               (__v16si) __W,
               (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_maskz_conflict_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictsi_512_mask ((__v16si) __A,
                 (__v16si) _mm512_setzero_si512 (),
                 (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_lzcnt_epi32 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntd_512_mask ((__v16si) __A,
             (__v16si) _mm512_setzero_si512 (),
             (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_mask_lzcnt_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntd_512_mask ((__v16si) __A,
                 (__v16si) __W,
                 (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_maskz_lzcnt_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntd_512_mask ((__v16si) __A,
             (__v16si) _mm512_setzero_si512 (),
             (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_lzcnt_epi64 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntq_512_mask ((__v8di) __A,
             (__v8di) _mm512_setzero_si512 (),
             (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_mask_lzcnt_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntq_512_mask ((__v8di) __A,
                 (__v8di) __W,
                 (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_maskz_lzcnt_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntq_512_mask ((__v8di) __A,
             (__v8di) _mm512_setzero_si512 (),
             (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_broadcastmb_epi64 (__mmask8 __A)
{
  return (__m512i) __builtin_ia32_broadcastmb512 (__A);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_broadcastmw_epi32 (__mmask16 __A)
{
  return (__m512i) __builtin_ia32_broadcastmw512 (__A);
}
# 147 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vpopcntdqintrin.h" 1 3 4
# 38 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vpopcntdqintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vpopcntd" "q"))) _mm512_popcnt_epi64(__m512i __A) {
  return (__m512i)__builtin_ia32_vpopcntq_512((__v8di)__A);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vpopcntd" "q")))
_mm512_mask_popcnt_epi64(__m512i __W, __mmask8 __U, __m512i __A) {
  return (__m512i)__builtin_ia32_selectq_512(
      (__mmask8)__U, (__v8di)_mm512_popcnt_epi64(__A), (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vpopcntd" "q")))
_mm512_maskz_popcnt_epi64(__mmask8 __U, __m512i __A) {
  return _mm512_mask_popcnt_epi64((__m512i)_mm512_setzero_si512(), __U, __A);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vpopcntd" "q"))) _mm512_popcnt_epi32(__m512i __A) {
  return (__m512i)__builtin_ia32_vpopcntd_512((__v16si)__A);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vpopcntd" "q")))
_mm512_mask_popcnt_epi32(__m512i __W, __mmask16 __U, __m512i __A) {
  return (__m512i)__builtin_ia32_selectd_512(
      (__mmask16)__U, (__v16si)_mm512_popcnt_epi32(__A), (__v16si)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vpopcntd" "q")))
_mm512_maskz_popcnt_epi32(__mmask16 __U, __m512i __A) {
  return _mm512_mask_popcnt_epi32((__m512i)_mm512_setzero_si512(), __U, __A);
}
# 151 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mullo_epi64 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v8du) __A * (__v8du) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_mullo_epi64(__m512i __W, __mmask8 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_mullo_epi64(__A, __B),
                                             (__v8di)__W);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_mullo_epi64(__mmask8 __U, __m512i __A, __m512i __B) {
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__U,
                                             (__v8di)_mm512_mullo_epi64(__A, __B),
                                             (__v8di)_mm512_setzero_si512());
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_xor_pd(__m512d __A, __m512d __B) {
  return (__m512d)((__v8du)__A ^ (__v8du)__B);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_xor_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_xor_pd(__A, __B),
                                              (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_xor_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_xor_pd(__A, __B),
                                              (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_xor_ps (__m512 __A, __m512 __B) {
  return (__m512)((__v16su)__A ^ (__v16su)__B);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_xor_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_xor_ps(__A, __B),
                                             (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_xor_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_xor_ps(__A, __B),
                                             (__v16sf)_mm512_setzero_ps());
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_or_pd(__m512d __A, __m512d __B) {
  return (__m512d)((__v8du)__A | (__v8du)__B);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_or_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_or_pd(__A, __B),
                                              (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_or_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_or_pd(__A, __B),
                                              (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_or_ps(__m512 __A, __m512 __B) {
  return (__m512)((__v16su)__A | (__v16su)__B);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_or_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_or_ps(__A, __B),
                                             (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_or_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_or_ps(__A, __B),
                                             (__v16sf)_mm512_setzero_ps());
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_and_pd(__m512d __A, __m512d __B) {
  return (__m512d)((__v8du)__A & (__v8du)__B);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_and_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_and_pd(__A, __B),
                                              (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_and_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_and_pd(__A, __B),
                                              (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_and_ps(__m512 __A, __m512 __B) {
  return (__m512)((__v16su)__A & (__v16su)__B);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_and_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_and_ps(__A, __B),
                                             (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_and_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_and_ps(__A, __B),
                                             (__v16sf)_mm512_setzero_ps());
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_andnot_pd(__m512d __A, __m512d __B) {
  return (__m512d)(~(__v8du)__A & (__v8du)__B);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_andnot_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_andnot_pd(__A, __B),
                                              (__v8df)__W);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_andnot_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__U,
                                              (__v8df)_mm512_andnot_pd(__A, __B),
                                              (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_andnot_ps(__m512 __A, __m512 __B) {
  return (__m512)(~(__v16su)__A & (__v16su)__B);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_andnot_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_andnot_ps(__A, __B),
                                             (__v16sf)__W);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_andnot_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512)__builtin_ia32_selectps_512((__mmask16)__U,
                                             (__v16sf)_mm512_andnot_ps(__A, __B),
                                             (__v16sf)_mm512_setzero_ps());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtpd_epi64 (__m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2qq512_mask ((__v8df) __A,
                (__v8di) _mm512_setzero_si512(),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtpd_epi64 (__m512i __W, __mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2qq512_mask ((__v8df) __A,
                (__v8di) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtpd_epi64 (__mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2qq512_mask ((__v8df) __A,
                (__v8di) _mm512_setzero_si512(),
                (__mmask8) __U,
                0x04);
}
# 244 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtpd_epu64 (__m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2uqq512_mask ((__v8df) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) -1,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtpd_epu64 (__m512i __W, __mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2uqq512_mask ((__v8df) __A,
                 (__v8di) __W,
                 (__mmask8) __U,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtpd_epu64 (__mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2uqq512_mask ((__v8df) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) __U,
                 0x04);
}
# 283 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtps_epi64 (__m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2qq512_mask ((__v8sf) __A,
                (__v8di) _mm512_setzero_si512(),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtps_epi64 (__m512i __W, __mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2qq512_mask ((__v8sf) __A,
                (__v8di) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtps_epi64 (__mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2qq512_mask ((__v8sf) __A,
                (__v8di) _mm512_setzero_si512(),
                (__mmask8) __U,
                0x04);
}
# 322 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtps_epu64 (__m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2uqq512_mask ((__v8sf) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) -1,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtps_epu64 (__m512i __W, __mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2uqq512_mask ((__v8sf) __A,
                 (__v8di) __W,
                 (__mmask8) __U,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtps_epu64 (__mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2uqq512_mask ((__v8sf) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) __U,
                 0x04);
}
# 362 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtepi64_pd (__m512i __A) {
  return (__m512d) __builtin_ia32_cvtqq2pd512_mask ((__v8di) __A,
                (__v8df) _mm512_setzero_pd(),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtepi64_pd (__m512d __W, __mmask8 __U, __m512i __A) {
  return (__m512d) __builtin_ia32_cvtqq2pd512_mask ((__v8di) __A,
                (__v8df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtepi64_pd (__mmask8 __U, __m512i __A) {
  return (__m512d) __builtin_ia32_cvtqq2pd512_mask ((__v8di) __A,
                (__v8df) _mm512_setzero_pd(),
                (__mmask8) __U,
                0x04);
}
# 401 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtepi64_ps (__m512i __A) {
  return (__m256) __builtin_ia32_cvtqq2ps512_mask ((__v8di) __A,
               (__v8sf) _mm256_setzero_ps(),
               (__mmask8) -1,
               0x04);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtepi64_ps (__m256 __W, __mmask8 __U, __m512i __A) {
  return (__m256) __builtin_ia32_cvtqq2ps512_mask ((__v8di) __A,
               (__v8sf) __W,
               (__mmask8) __U,
               0x04);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtepi64_ps (__mmask8 __U, __m512i __A) {
  return (__m256) __builtin_ia32_cvtqq2ps512_mask ((__v8di) __A,
               (__v8sf) _mm256_setzero_ps(),
               (__mmask8) __U,
               0x04);
}
# 441 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvttpd_epi64 (__m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2qq512_mask ((__v8df) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) -1,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvttpd_epi64 (__m512i __W, __mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2qq512_mask ((__v8df) __A,
                 (__v8di) __W,
                 (__mmask8) __U,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvttpd_epi64 (__mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2qq512_mask ((__v8df) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) __U,
                 0x04);
}
# 480 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvttpd_epu64 (__m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2uqq512_mask ((__v8df) __A,
                  (__v8di) _mm512_setzero_si512(),
                  (__mmask8) -1,
                  0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvttpd_epu64 (__m512i __W, __mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2uqq512_mask ((__v8df) __A,
                  (__v8di) __W,
                  (__mmask8) __U,
                  0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvttpd_epu64 (__mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2uqq512_mask ((__v8df) __A,
                  (__v8di) _mm512_setzero_si512(),
                  (__mmask8) __U,
                  0x04);
}
# 519 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvttps_epi64 (__m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2qq512_mask ((__v8sf) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) -1,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvttps_epi64 (__m512i __W, __mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2qq512_mask ((__v8sf) __A,
                 (__v8di) __W,
                 (__mmask8) __U,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvttps_epi64 (__mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2qq512_mask ((__v8sf) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) __U,
                 0x04);
}
# 558 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvttps_epu64 (__m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2uqq512_mask ((__v8sf) __A,
                  (__v8di) _mm512_setzero_si512(),
                  (__mmask8) -1,
                  0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvttps_epu64 (__m512i __W, __mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2uqq512_mask ((__v8sf) __A,
                  (__v8di) __W,
                  (__mmask8) __U,
                  0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvttps_epu64 (__mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2uqq512_mask ((__v8sf) __A,
                  (__v8di) _mm512_setzero_si512(),
                  (__mmask8) __U,
                  0x04);
}
# 597 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtepu64_pd (__m512i __A) {
  return (__m512d) __builtin_ia32_cvtuqq2pd512_mask ((__v8di) __A,
                 (__v8df) _mm512_setzero_pd(),
                 (__mmask8) -1,
                 0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtepu64_pd (__m512d __W, __mmask8 __U, __m512i __A) {
  return (__m512d) __builtin_ia32_cvtuqq2pd512_mask ((__v8di) __A,
                 (__v8df) __W,
                 (__mmask8) __U,
                 0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtepu64_pd (__mmask8 __U, __m512i __A) {
  return (__m512d) __builtin_ia32_cvtuqq2pd512_mask ((__v8di) __A,
                 (__v8df) _mm512_setzero_pd(),
                 (__mmask8) __U,
                 0x04);
}
# 638 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtepu64_ps (__m512i __A) {
  return (__m256) __builtin_ia32_cvtuqq2ps512_mask ((__v8di) __A,
                (__v8sf) _mm256_setzero_ps(),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtepu64_ps (__m256 __W, __mmask8 __U, __m512i __A) {
  return (__m256) __builtin_ia32_cvtuqq2ps512_mask ((__v8di) __A,
                (__v8sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtepu64_ps (__mmask8 __U, __m512i __A) {
  return (__m256) __builtin_ia32_cvtuqq2ps512_mask ((__v8di) __A,
                (__v8sf) _mm256_setzero_ps(),
                (__mmask8) __U,
                0x04);
}
# 948 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512dqintrin.h" 3 4
static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_movepi32_mask (__m512i __A)
{
  return (__mmask16) __builtin_ia32_cvtd2mask512 ((__v16si) __A);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_movm_epi32 (__mmask16 __A)
{
  return (__m512i) __builtin_ia32_cvtmask2d512 (__A);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_movm_epi64 (__mmask8 __A)
{
  return (__m512i) __builtin_ia32_cvtmask2q512 (__A);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_movepi64_mask (__m512i __A)
{
  return (__mmask8) __builtin_ia32_cvtq2mask512 ((__v8di) __A);
}


static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_broadcast_f32x2 (__m128 __A)
{
  return (__m512) __builtin_ia32_broadcastf32x2_512_mask ((__v4sf) __A,
                (__v16sf)_mm512_undefined_ps(),
                (__mmask16) -1);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_broadcast_f32x2 (__m512 __O, __mmask16 __M, __m128 __A)
{
  return (__m512) __builtin_ia32_broadcastf32x2_512_mask ((__v4sf) __A,
                (__v16sf)
                __O, __M);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_broadcast_f32x2 (__mmask16 __M, __m128 __A)
{
  return (__m512) __builtin_ia32_broadcastf32x2_512_mask ((__v4sf) __A,
                (__v16sf)_mm512_setzero_ps (),
                __M);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_broadcast_f32x8(__m256 __A)
{
  return (__m512)__builtin_shufflevector((__v8sf)__A, (__v8sf)__A,
                                         0, 1, 2, 3, 4, 5, 6, 7,
                                         0, 1, 2, 3, 4, 5, 6, 7);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_broadcast_f32x8(__m512 __O, __mmask16 __M, __m256 __A)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask8)__M,
                                           (__v16sf)_mm512_broadcast_f32x8(__A),
                                           (__v16sf)__O);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_broadcast_f32x8(__mmask16 __M, __m256 __A)
{
  return (__m512)__builtin_ia32_selectps_512((__mmask8)__M,
                                           (__v16sf)_mm512_broadcast_f32x8(__A),
                                           (__v16sf)_mm512_setzero_ps());
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_broadcast_f64x2(__m128d __A)
{
  return (__m512d)__builtin_shufflevector((__v2df)__A, (__v2df)__A,
                                          0, 1, 0, 1, 0, 1, 0, 1);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_broadcast_f64x2(__m512d __O, __mmask8 __M, __m128d __A)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__M,
                                            (__v8df)_mm512_broadcast_f64x2(__A),
                                            (__v8df)__O);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_broadcast_f64x2(__mmask8 __M, __m128d __A)
{
  return (__m512d)__builtin_ia32_selectpd_512((__mmask8)__M,
                                            (__v8df)_mm512_broadcast_f64x2(__A),
                                            (__v8df)_mm512_setzero_pd());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_broadcast_i32x2 (__m128i __A)
{
  return (__m512i) __builtin_ia32_broadcasti32x2_512_mask ((__v4si) __A,
                 (__v16si)_mm512_setzero_si512(),
                 (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_broadcast_i32x2 (__m512i __O, __mmask16 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_broadcasti32x2_512_mask ((__v4si) __A,
                 (__v16si)
                 __O, __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_broadcast_i32x2 (__mmask16 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_broadcasti32x2_512_mask ((__v4si) __A,
                 (__v16si)_mm512_setzero_si512 (),
                 __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_broadcast_i32x8(__m256i __A)
{
  return (__m512i)__builtin_shufflevector((__v8si)__A, (__v8si)__A,
                                          0, 1, 2, 3, 4, 5, 6, 7,
                                          0, 1, 2, 3, 4, 5, 6, 7);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_broadcast_i32x8(__m512i __O, __mmask16 __M, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask8)__M,
                                           (__v16si)_mm512_broadcast_i32x8(__A),
                                           (__v16si)__O);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_broadcast_i32x8(__mmask16 __M, __m256i __A)
{
  return (__m512i)__builtin_ia32_selectd_512((__mmask8)__M,
                                           (__v16si)_mm512_broadcast_i32x8(__A),
                                           (__v16si)_mm512_setzero_si512());
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_broadcast_i64x2(__m128i __A)
{
  return (__m512i)__builtin_shufflevector((__v2di)__A, (__v2di)__A,
                                          0, 1, 0, 1, 0, 1, 0, 1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_broadcast_i64x2(__m512i __O, __mmask8 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__M,
                                            (__v8di)_mm512_broadcast_i64x2(__A),
                                            (__v8di)__O);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_broadcast_i64x2(__mmask8 __M, __m128i __A)
{
  return (__m512i)__builtin_ia32_selectq_512((__mmask8)__M,
                                            (__v8di)_mm512_broadcast_i64x2(__A),
                                            (__v8di)_mm512_setzero_si512());
}
# 155 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlbwintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlbwintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_setzero_hi(void){
    return (__m128i)(__v8hi){ 0, 0, 0, 0, 0, 0, 0, 0 };
}



static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpeq_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqb128_mask((__v16qi)__a, (__v16qi)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpeq_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqb128_mask((__v16qi)__a, (__v16qi)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpeq_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 0,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpeq_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 0,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpeq_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_pcmpeqb256_mask((__v32qi)__a, (__v32qi)__b,
                                                   (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpeq_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_pcmpeqb256_mask((__v32qi)__a, (__v32qi)__b,
                                                   __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpeq_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 0,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpeq_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 0,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpeq_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqw128_mask((__v8hi)__a, (__v8hi)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpeq_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqw128_mask((__v8hi)__a, (__v8hi)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpeq_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpeq_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 0,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpeq_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqw256_mask((__v16hi)__a, (__v16hi)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpeq_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqw256_mask((__v16hi)__a, (__v16hi)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpeq_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 0,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpeq_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 0,
                                                 __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpge_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 5,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpge_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 5,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpge_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 5,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpge_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 5,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpge_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 5,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpge_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 5,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpge_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 5,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpge_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 5,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpge_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpge_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpge_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpge_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 5,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpge_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 5,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpge_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 5,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpge_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 5,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpge_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 5,
                                                 __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpgt_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtb128_mask((__v16qi)__a, (__v16qi)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpgt_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtb128_mask((__v16qi)__a, (__v16qi)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpgt_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 6,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpgt_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 6,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpgt_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_pcmpgtb256_mask((__v32qi)__a, (__v32qi)__b,
                                                   (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpgt_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_pcmpgtb256_mask((__v32qi)__a, (__v32qi)__b,
                                                   __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpgt_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 6,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpgt_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 6,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpgt_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtw128_mask((__v8hi)__a, (__v8hi)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpgt_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtw128_mask((__v8hi)__a, (__v8hi)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpgt_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpgt_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 6,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpgt_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtw256_mask((__v16hi)__a, (__v16hi)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpgt_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtw256_mask((__v16hi)__a, (__v16hi)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpgt_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 6,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpgt_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 6,
                                                 __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmple_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 2,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmple_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 2,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmple_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 2,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmple_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 2,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmple_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 2,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmple_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 2,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmple_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 2,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmple_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 2,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmple_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmple_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmple_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmple_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 2,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmple_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 2,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmple_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 2,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmple_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 2,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmple_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 2,
                                                 __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmplt_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 1,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmplt_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 1,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmplt_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 1,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmplt_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 1,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmplt_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 1,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmplt_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 1,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmplt_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 1,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmplt_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 1,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmplt_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmplt_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmplt_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmplt_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 1,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmplt_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 1,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmplt_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 1,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmplt_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 1,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmplt_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 1,
                                                 __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpneq_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 4,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpneq_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 4,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpneq_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 4,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpneq_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 4,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpneq_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 4,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpneq_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 4,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpneq_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 4,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpneq_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 4,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpneq_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpneq_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpneq_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpneq_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 4,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpneq_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 4,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpneq_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 4,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpneq_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 4,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpneq_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 4,
                                                 __u);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_add_epi8(__m256i __W, __mmask32 __U, __m256i __A, __m256i __B){
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                             (__v32qi)_mm256_add_epi8(__A, __B),
                                             (__v32qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_add_epi8(__mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                             (__v32qi)_mm256_add_epi8(__A, __B),
                                             (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_add_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_add_epi16(__A, __B),
                                             (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_add_epi16(__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_add_epi16(__A, __B),
                                             (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_sub_epi8(__m256i __W, __mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                             (__v32qi)_mm256_sub_epi8(__A, __B),
                                             (__v32qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_sub_epi8(__mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                             (__v32qi)_mm256_sub_epi8(__A, __B),
                                             (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_sub_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_sub_epi16(__A, __B),
                                             (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_sub_epi16(__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_sub_epi16(__A, __B),
                                             (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_add_epi8(__m128i __W, __mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_add_epi8(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_add_epi8(__mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_add_epi8(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_add_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_add_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_add_epi16(__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_add_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_sub_epi8(__m128i __W, __mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_sub_epi8(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_sub_epi8(__mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_sub_epi8(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_sub_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_sub_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_sub_epi16(__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_sub_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_mullo_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_mullo_epi16(__A, __B),
                                             (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_mullo_epi16(__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_mullo_epi16(__A, __B),
                                             (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_mullo_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_mullo_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_mullo_epi16(__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_mullo_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_blend_epi8 (__mmask16 __U, __m128i __A, __m128i __W)
{
  return (__m128i) __builtin_ia32_selectb_128 ((__mmask16) __U,
              (__v16qi) __W,
              (__v16qi) __A);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_blend_epi8 (__mmask32 __U, __m256i __A, __m256i __W)
{
  return (__m256i) __builtin_ia32_selectb_256 ((__mmask32) __U,
               (__v32qi) __W,
               (__v32qi) __A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_blend_epi16 (__mmask8 __U, __m128i __A, __m128i __W)
{
  return (__m128i) __builtin_ia32_selectw_128 ((__mmask8) __U,
               (__v8hi) __W,
               (__v8hi) __A);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_blend_epi16 (__mmask16 __U, __m256i __A, __m256i __W)
{
  return (__m256i) __builtin_ia32_selectw_256 ((__mmask16) __U,
               (__v16hi) __W,
               (__v16hi) __A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_abs_epi8(__m128i __W, __mmask16 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_abs_epi8(__A),
                                             (__v16qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_abs_epi8(__mmask16 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_abs_epi8(__A),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_abs_epi8(__m256i __W, __mmask32 __U, __m256i __A)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                             (__v32qi)_mm256_abs_epi8(__A),
                                             (__v32qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_abs_epi8 (__mmask32 __U, __m256i __A)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                             (__v32qi)_mm256_abs_epi8(__A),
                                             (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_abs_epi16(__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_abs_epi16(__A),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_abs_epi16(__mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_abs_epi16(__A),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_abs_epi16(__m256i __W, __mmask16 __U, __m256i __A)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_abs_epi16(__A),
                                             (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_abs_epi16(__mmask16 __U, __m256i __A)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_abs_epi16(__A),
                                             (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_packs_epi32(__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_packs_epi32(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_packs_epi32(__m128i __W, __mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_packs_epi32(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_packs_epi32(__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                          (__v16hi)_mm256_packs_epi32(__A, __B),
                                          (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_packs_epi32(__m256i __W, __mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                          (__v16hi)_mm256_packs_epi32(__A, __B),
                                          (__v16hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_packs_epi16(__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                             (__v16qi)_mm_packs_epi16(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_packs_epi16(__m128i __W, __mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                             (__v16qi)_mm_packs_epi16(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_packs_epi16(__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                          (__v32qi)_mm256_packs_epi16(__A, __B),
                                          (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_packs_epi16(__m256i __W, __mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                          (__v32qi)_mm256_packs_epi16(__A, __B),
                                          (__v32qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_packus_epi32(__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_packus_epi32(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_packus_epi32(__m128i __W, __mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_packus_epi32(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_packus_epi32(__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                         (__v16hi)_mm256_packus_epi32(__A, __B),
                                         (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_packus_epi32(__m256i __W, __mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                         (__v16hi)_mm256_packus_epi32(__A, __B),
                                         (__v16hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_packus_epi16(__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                            (__v16qi)_mm_packus_epi16(__A, __B),
                                            (__v16qi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_packus_epi16(__m128i __W, __mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                            (__v16qi)_mm_packus_epi16(__A, __B),
                                            (__v16qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_packus_epi16(__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                         (__v32qi)_mm256_packus_epi16(__A, __B),
                                         (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_packus_epi16(__m256i __W, __mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                         (__v32qi)_mm256_packus_epi16(__A, __B),
                                         (__v32qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_adds_epi8(__m128i __W, __mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_adds_epi8(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_adds_epi8(__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_adds_epi8(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_adds_epi8(__m256i __W, __mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                            (__v32qi)_mm256_adds_epi8(__A, __B),
                                            (__v32qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_adds_epi8(__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                            (__v32qi)_mm256_adds_epi8(__A, __B),
                                            (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_adds_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_adds_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_adds_epi16(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_adds_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_adds_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_adds_epi16(__A, __B),
                                           (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_adds_epi16(__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_adds_epi16(__A, __B),
                                           (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_adds_epu8(__m128i __W, __mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_adds_epu8(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_adds_epu8(__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_adds_epu8(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_adds_epu8(__m256i __W, __mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                            (__v32qi)_mm256_adds_epu8(__A, __B),
                                            (__v32qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_adds_epu8(__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                            (__v32qi)_mm256_adds_epu8(__A, __B),
                                            (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_adds_epu16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_adds_epu16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_adds_epu16(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_adds_epu16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_adds_epu16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_adds_epu16(__A, __B),
                                           (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_adds_epu16(__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_adds_epu16(__A, __B),
                                           (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_avg_epu8(__m128i __W, __mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_avg_epu8(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_avg_epu8(__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_avg_epu8(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_avg_epu8(__m256i __W, __mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                             (__v32qi)_mm256_avg_epu8(__A, __B),
                                             (__v32qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_avg_epu8(__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                             (__v32qi)_mm256_avg_epu8(__A, __B),
                                             (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_avg_epu16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_avg_epu16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_avg_epu16(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_avg_epu16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_avg_epu16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                            (__v16hi)_mm256_avg_epu16(__A, __B),
                                            (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_avg_epu16(__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                            (__v16hi)_mm256_avg_epu16(__A, __B),
                                            (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_max_epi8(__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                             (__v16qi)_mm_max_epi8(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_max_epi8(__m128i __W, __mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                             (__v16qi)_mm_max_epi8(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_max_epi8(__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                             (__v32qi)_mm256_max_epi8(__A, __B),
                                             (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_max_epi8(__m256i __W, __mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                             (__v32qi)_mm256_max_epi8(__A, __B),
                                             (__v32qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_max_epi16(__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_max_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_max_epi16(__m128i __W, __mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_max_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_max_epi16(__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                            (__v16hi)_mm256_max_epi16(__A, __B),
                                            (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_max_epi16(__m256i __W, __mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                            (__v16hi)_mm256_max_epi16(__A, __B),
                                            (__v16hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_max_epu8(__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                             (__v16qi)_mm_max_epu8(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_max_epu8(__m128i __W, __mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                             (__v16qi)_mm_max_epu8(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_max_epu8 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                             (__v32qi)_mm256_max_epu8(__A, __B),
                                             (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_max_epu8(__m256i __W, __mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                             (__v32qi)_mm256_max_epu8(__A, __B),
                                             (__v32qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_max_epu16(__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_max_epu16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_max_epu16(__m128i __W, __mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_max_epu16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_max_epu16(__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                            (__v16hi)_mm256_max_epu16(__A, __B),
                                            (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_max_epu16(__m256i __W, __mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                            (__v16hi)_mm256_max_epu16(__A, __B),
                                            (__v16hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_min_epi8(__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                             (__v16qi)_mm_min_epi8(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_min_epi8(__m128i __W, __mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                             (__v16qi)_mm_min_epi8(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_min_epi8(__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                             (__v32qi)_mm256_min_epi8(__A, __B),
                                             (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_min_epi8(__m256i __W, __mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                             (__v32qi)_mm256_min_epi8(__A, __B),
                                             (__v32qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_min_epi16(__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_min_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_min_epi16(__m128i __W, __mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_min_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_min_epi16(__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                            (__v16hi)_mm256_min_epi16(__A, __B),
                                            (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_min_epi16(__m256i __W, __mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                            (__v16hi)_mm256_min_epi16(__A, __B),
                                            (__v16hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_min_epu8(__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                             (__v16qi)_mm_min_epu8(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_min_epu8(__m128i __W, __mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__M,
                                             (__v16qi)_mm_min_epu8(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_min_epu8 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                             (__v32qi)_mm256_min_epu8(__A, __B),
                                             (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_min_epu8(__m256i __W, __mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__M,
                                             (__v32qi)_mm256_min_epu8(__A, __B),
                                             (__v32qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_min_epu16(__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_min_epu16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_min_epu16(__m128i __W, __mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__M,
                                             (__v8hi)_mm_min_epu16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_min_epu16(__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                            (__v16hi)_mm256_min_epu16(__A, __B),
                                            (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_min_epu16(__m256i __W, __mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__M,
                                            (__v16hi)_mm256_min_epu16(__A, __B),
                                            (__v16hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_shuffle_epi8(__m128i __W, __mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                            (__v16qi)_mm_shuffle_epi8(__A, __B),
                                            (__v16qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_shuffle_epi8(__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                            (__v16qi)_mm_shuffle_epi8(__A, __B),
                                            (__v16qi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_shuffle_epi8(__m256i __W, __mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                         (__v32qi)_mm256_shuffle_epi8(__A, __B),
                                         (__v32qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_shuffle_epi8(__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                         (__v32qi)_mm256_shuffle_epi8(__A, __B),
                                         (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_subs_epi8(__m128i __W, __mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_subs_epi8(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_subs_epi8(__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_subs_epi8(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_subs_epi8(__m256i __W, __mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                            (__v32qi)_mm256_subs_epi8(__A, __B),
                                            (__v32qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_subs_epi8(__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                            (__v32qi)_mm256_subs_epi8(__A, __B),
                                            (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_subs_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_subs_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_subs_epi16(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_subs_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_subs_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_subs_epi16(__A, __B),
                                           (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_subs_epi16(__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_subs_epi16(__A, __B),
                                           (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_subs_epu8(__m128i __W, __mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_subs_epu8(__A, __B),
                                             (__v16qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_subs_epu8(__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                             (__v16qi)_mm_subs_epu8(__A, __B),
                                             (__v16qi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_subs_epu8(__m256i __W, __mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                            (__v32qi)_mm256_subs_epu8(__A, __B),
                                            (__v32qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_subs_epu8(__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                            (__v32qi)_mm256_subs_epu8(__A, __B),
                                            (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_subs_epu16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_subs_epu16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_subs_epu16(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_subs_epu16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_subs_epu16(__m256i __W, __mmask16 __U, __m256i __A,
      __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_subs_epu16(__A, __B),
                                           (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_subs_epu16(__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_subs_epu16(__A, __B),
                                           (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask2_permutex2var_epi16 (__m128i __A, __m128i __I, __mmask8 __U,
            __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermi2varhi128_mask ((__v8hi) __A,
               (__v8hi) __I ,
               (__v8hi) __B,
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask2_permutex2var_epi16 (__m256i __A, __m256i __I,
         __mmask16 __U, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermi2varhi256_mask ((__v16hi) __A,
               (__v16hi) __I ,
               (__v16hi) __B,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_permutex2var_epi16 (__m128i __A, __m128i __I, __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varhi128_mask ((__v8hi) __I ,
               (__v8hi) __A,
               (__v8hi) __B,
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_permutex2var_epi16 (__m128i __A, __mmask8 __U, __m128i __I,
           __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varhi128_mask ((__v8hi) __I ,
               (__v8hi) __A,
               (__v8hi) __B,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_permutex2var_epi16 (__mmask8 __U, __m128i __A, __m128i __I,
            __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varhi128_maskz ((__v8hi) __I ,
               (__v8hi) __A,
               (__v8hi) __B,
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_permutex2var_epi16 (__m256i __A, __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varhi256_mask ((__v16hi) __I ,
               (__v16hi) __A,
               (__v16hi) __B,
               (__mmask16) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_permutex2var_epi16 (__m256i __A, __mmask16 __U,
        __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varhi256_mask ((__v16hi) __I ,
               (__v16hi) __A,
               (__v16hi) __B,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_permutex2var_epi16 (__mmask16 __U, __m256i __A,
         __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varhi256_maskz ((__v16hi) __I ,
               (__v16hi) __A,
               (__v16hi) __B,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_maddubs_epi16(__m128i __W, __mmask8 __U, __m128i __X, __m128i __Y) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                            (__v8hi)_mm_maddubs_epi16(__X, __Y),
                                            (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_maddubs_epi16(__mmask8 __U, __m128i __X, __m128i __Y) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                            (__v8hi)_mm_maddubs_epi16(__X, __Y),
                                            (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_maddubs_epi16(__m256i __W, __mmask16 __U, __m256i __X,
                          __m256i __Y) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                        (__v16hi)_mm256_maddubs_epi16(__X, __Y),
                                        (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_maddubs_epi16(__mmask16 __U, __m256i __X, __m256i __Y) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                        (__v16hi)_mm256_maddubs_epi16(__X, __Y),
                                        (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_madd_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_madd_epi16(__A, __B),
                                             (__v4si)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_madd_epi16(__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectd_128((__mmask8)__U,
                                             (__v4si)_mm_madd_epi16(__A, __B),
                                             (__v4si)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_madd_epi16(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                            (__v8si)_mm256_madd_epi16(__A, __B),
                                            (__v8si)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_madd_epi16(__mmask8 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectd_256((__mmask8)__U,
                                            (__v8si)_mm256_madd_epi16(__A, __B),
                                            (__v8si)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cvtsepi16_epi8 (__m128i __A) {
  return (__m128i) __builtin_ia32_pmovswb128_mask ((__v8hi) __A,
               (__v16qi) _mm_setzero_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cvtsepi16_epi8 (__m128i __O, __mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovswb128_mask ((__v8hi) __A,
               (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_cvtsepi16_epi8 (__mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovswb128_mask ((__v8hi) __A,
               (__v16qi) _mm_setzero_si128(),
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cvtsepi16_epi8 (__m256i __A) {
  return (__m128i) __builtin_ia32_pmovswb256_mask ((__v16hi) __A,
               (__v16qi) _mm_setzero_si128(),
               (__mmask16) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cvtsepi16_epi8 (__m128i __O, __mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovswb256_mask ((__v16hi) __A,
               (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_cvtsepi16_epi8 (__mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovswb256_mask ((__v16hi) __A,
               (__v16qi) _mm_setzero_si128(),
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cvtusepi16_epi8 (__m128i __A) {
  return (__m128i) __builtin_ia32_pmovuswb128_mask ((__v8hi) __A,
                (__v16qi) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cvtusepi16_epi8 (__m128i __O, __mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovuswb128_mask ((__v8hi) __A,
                (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_cvtusepi16_epi8 (__mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovuswb128_mask ((__v8hi) __A,
                (__v16qi) _mm_setzero_si128(),
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cvtusepi16_epi8 (__m256i __A) {
  return (__m128i) __builtin_ia32_pmovuswb256_mask ((__v16hi) __A,
                (__v16qi) _mm_setzero_si128(),
                (__mmask16) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cvtusepi16_epi8 (__m128i __O, __mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovuswb256_mask ((__v16hi) __A,
                (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_cvtusepi16_epi8 (__mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovuswb256_mask ((__v16hi) __A,
                (__v16qi) _mm_setzero_si128(),
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cvtepi16_epi8 (__m128i __A) {

  return (__m128i) __builtin_ia32_pmovwb128_mask ((__v8hi) __A,
               (__v16qi) _mm_setzero_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cvtepi16_epi8 (__m128i __O, __mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovwb128_mask ((__v8hi) __A,
               (__v16qi) __O,
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_cvtepi16_epi8 (__mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovwb128_mask ((__v8hi) __A,
               (__v16qi) _mm_setzero_si128(),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cvtepi16_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovwb128mem_mask ((__v16qi *) __P, (__v8hi) __A, __M);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cvtsepi16_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovswb128mem_mask ((__v16qi *) __P, (__v8hi) __A, __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cvtusepi16_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovuswb128mem_mask ((__v16qi *) __P, (__v8hi) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cvtepi16_epi8 (__m256i __A) {
  return (__m128i) __builtin_ia32_pmovwb256_mask ((__v16hi) __A,
               (__v16qi) _mm_setzero_si128(),
               (__mmask16) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cvtepi16_epi8 (__m128i __O, __mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovwb256_mask ((__v16hi) __A,
               (__v16qi) __O,
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_cvtepi16_epi8 (__mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovwb256_mask ((__v16hi) __A,
               (__v16qi) _mm_setzero_si128(),
               __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cvtepi16_storeu_epi8 (void * __P, __mmask16 __M, __m256i __A)
{
  __builtin_ia32_pmovwb256mem_mask ((__v16qi *) __P, (__v16hi) __A, __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cvtsepi16_storeu_epi8 (void * __P, __mmask16 __M, __m256i __A)
{
  __builtin_ia32_pmovswb256mem_mask ((__v16qi *) __P, (__v16hi) __A, __M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cvtusepi16_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovuswb256mem_mask ((__v16qi*) __P, (__v16hi) __A, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_mulhrs_epi16(__m128i __W, __mmask8 __U, __m128i __X, __m128i __Y) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_mulhrs_epi16(__X, __Y),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_mulhrs_epi16(__mmask8 __U, __m128i __X, __m128i __Y) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_mulhrs_epi16(__X, __Y),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_mulhrs_epi16(__m256i __W, __mmask16 __U, __m256i __X, __m256i __Y) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                         (__v16hi)_mm256_mulhrs_epi16(__X, __Y),
                                         (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_mulhrs_epi16(__mmask16 __U, __m256i __X, __m256i __Y) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                         (__v16hi)_mm256_mulhrs_epi16(__X, __Y),
                                         (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_mulhi_epu16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_mulhi_epu16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_mulhi_epu16(__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_mulhi_epu16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_mulhi_epu16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                          (__v16hi)_mm256_mulhi_epu16(__A, __B),
                                          (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_mulhi_epu16(__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                          (__v16hi)_mm256_mulhi_epu16(__A, __B),
                                          (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_mulhi_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_mulhi_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_mulhi_epi16(__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_mulhi_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_mulhi_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                          (__v16hi)_mm256_mulhi_epi16(__A, __B),
                                          (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_mulhi_epi16(__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                          (__v16hi)_mm256_mulhi_epi16(__A, __B),
                                          (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_unpackhi_epi8(__m128i __W, __mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                           (__v16qi)_mm_unpackhi_epi8(__A, __B),
                                           (__v16qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_unpackhi_epi8(__mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                           (__v16qi)_mm_unpackhi_epi8(__A, __B),
                                           (__v16qi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_unpackhi_epi8(__m256i __W, __mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                        (__v32qi)_mm256_unpackhi_epi8(__A, __B),
                                        (__v32qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_unpackhi_epi8(__mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                        (__v32qi)_mm256_unpackhi_epi8(__A, __B),
                                        (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_unpackhi_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                           (__v8hi)_mm_unpackhi_epi16(__A, __B),
                                           (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_unpackhi_epi16(__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                           (__v8hi)_mm_unpackhi_epi16(__A, __B),
                                           (__v8hi) _mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_unpackhi_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                       (__v16hi)_mm256_unpackhi_epi16(__A, __B),
                                       (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_unpackhi_epi16(__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                       (__v16hi)_mm256_unpackhi_epi16(__A, __B),
                                       (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_unpacklo_epi8(__m128i __W, __mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                           (__v16qi)_mm_unpacklo_epi8(__A, __B),
                                           (__v16qi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_unpacklo_epi8(__mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectb_128((__mmask16)__U,
                                           (__v16qi)_mm_unpacklo_epi8(__A, __B),
                                           (__v16qi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_unpacklo_epi8(__m256i __W, __mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                        (__v32qi)_mm256_unpacklo_epi8(__A, __B),
                                        (__v32qi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_unpacklo_epi8(__mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectb_256((__mmask32)__U,
                                        (__v32qi)_mm256_unpacklo_epi8(__A, __B),
                                        (__v32qi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_unpacklo_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                           (__v8hi)_mm_unpacklo_epi16(__A, __B),
                                           (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_unpacklo_epi16(__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                           (__v8hi)_mm_unpacklo_epi16(__A, __B),
                                           (__v8hi) _mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_unpacklo_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                       (__v16hi)_mm256_unpacklo_epi16(__A, __B),
                                       (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_unpacklo_epi16(__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                       (__v16hi)_mm256_unpacklo_epi16(__A, __B),
                                       (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cvtepi8_epi16(__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_cvtepi8_epi16(__A),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_cvtepi8_epi16(__mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_cvtepi8_epi16(__A),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cvtepi8_epi16(__m256i __W, __mmask16 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_cvtepi8_epi16(__A),
                                             (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_cvtepi8_epi16(__mmask16 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_cvtepi8_epi16(__A),
                                             (__v16hi)_mm256_setzero_si256());
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cvtepu8_epi16(__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_cvtepu8_epi16(__A),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_cvtepu8_epi16(__mmask8 __U, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_cvtepu8_epi16(__A),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cvtepu8_epi16(__m256i __W, __mmask16 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_cvtepu8_epi16(__A),
                                             (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_cvtepu8_epi16 (__mmask16 __U, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                             (__v16hi)_mm256_cvtepu8_epi16(__A),
                                             (__v16hi)_mm256_setzero_si256());
}
# 2271 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlbwintrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_sllv_epi16(__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_psllv16hi((__v16hi)__A, (__v16hi)__B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_sllv_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_sllv_epi16(__A, __B),
                                           (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_sllv_epi16(__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_sllv_epi16(__A, __B),
                                           (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_sllv_epi16(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psllv8hi((__v8hi)__A, (__v8hi)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_sllv_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_sllv_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_sllv_epi16(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_sllv_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_sll_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_sll_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_sll_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_sll_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_sll_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                          (__v16hi)_mm256_sll_epi16(__A, __B),
                                          (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_sll_epi16(__mmask16 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                          (__v16hi)_mm256_sll_epi16(__A, __B),
                                          (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_slli_epi16(__m128i __W, __mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_slli_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_slli_epi16 (__mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_slli_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_slli_epi16(__m256i __W, __mmask16 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                         (__v16hi)_mm256_slli_epi16(__A, __B),
                                         (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_slli_epi16(__mmask16 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                         (__v16hi)_mm256_slli_epi16(__A, __B),
                                         (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_srlv_epi16(__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_psrlv16hi((__v16hi)__A, (__v16hi)__B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_srlv_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_srlv_epi16(__A, __B),
                                           (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_srlv_epi16(__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_srlv_epi16(__A, __B),
                                           (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_srlv_epi16(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrlv8hi((__v8hi)__A, (__v8hi)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_srlv_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_srlv_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_srlv_epi16(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_srlv_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_srav_epi16(__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_psrav16hi((__v16hi)__A, (__v16hi)__B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_srav_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_srav_epi16(__A, __B),
                                           (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_srav_epi16(__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                           (__v16hi)_mm256_srav_epi16(__A, __B),
                                           (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_srav_epi16(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrav8hi((__v8hi)__A, (__v8hi)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_srav_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_srav_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_srav_epi16(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_srav_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_sra_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_sra_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_sra_epi16(__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_sra_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_sra_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                          (__v16hi)_mm256_sra_epi16(__A, __B),
                                          (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_sra_epi16(__mmask16 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                          (__v16hi)_mm256_sra_epi16(__A, __B),
                                          (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_srai_epi16(__m128i __W, __mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_srai_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_srai_epi16(__mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_srai_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_srai_epi16(__m256i __W, __mmask16 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                         (__v16hi)_mm256_srai_epi16(__A, __B),
                                         (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_srai_epi16(__mmask16 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                         (__v16hi)_mm256_srai_epi16(__A, __B),
                                         (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_srl_epi16(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_srl_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_srl_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_srl_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_srl_epi16(__m256i __W, __mmask16 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                          (__v16hi)_mm256_srl_epi16(__A, __B),
                                          (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_srl_epi16(__mmask16 __U, __m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                          (__v16hi)_mm256_srl_epi16(__A, __B),
                                          (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_srli_epi16(__m128i __W, __mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_srli_epi16(__A, __B),
                                             (__v8hi)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_srli_epi16 (__mmask8 __U, __m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_selectw_128((__mmask8)__U,
                                             (__v8hi)_mm_srli_epi16(__A, __B),
                                             (__v8hi)_mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_srli_epi16(__m256i __W, __mmask16 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                         (__v16hi)_mm256_srli_epi16(__A, __B),
                                         (__v16hi)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_srli_epi16(__mmask16 __U, __m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_selectw_256((__mmask16)__U,
                                         (__v16hi)_mm256_srli_epi16(__A, __B),
                                         (__v16hi)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_mov_epi16 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_selectw_128 ((__mmask8) __U,
                (__v8hi) __A,
                (__v8hi) __W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_mov_epi16 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_selectw_128 ((__mmask8) __U,
                (__v8hi) __A,
                (__v8hi) _mm_setzero_hi ());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_mov_epi16 (__m256i __W, __mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_selectw_256 ((__mmask16) __U,
                (__v16hi) __A,
                (__v16hi) __W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_mov_epi16 (__mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_selectw_256 ((__mmask16) __U,
                (__v16hi) __A,
                (__v16hi) _mm256_setzero_si256 ());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_mov_epi8 (__m128i __W, __mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_selectb_128 ((__mmask16) __U,
                (__v16qi) __A,
                (__v16qi) __W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_mov_epi8 (__mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_selectb_128 ((__mmask16) __U,
                (__v16qi) __A,
                (__v16qi) _mm_setzero_hi ());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_mov_epi8 (__m256i __W, __mmask32 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_selectb_256 ((__mmask32) __U,
                (__v32qi) __A,
                (__v32qi) __W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_mov_epi8 (__mmask32 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_selectb_256 ((__mmask32) __U,
                (__v32qi) __A,
                (__v32qi) _mm256_setzero_si256 ());
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_set1_epi8 (__m128i __O, __mmask16 __M, char __A)
{
  return (__m128i) __builtin_ia32_pbroadcastb128_gpr_mask (__A,
                 (__v16qi) __O,
                 __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_set1_epi8 (__mmask16 __M, char __A)
{
  return (__m128i) __builtin_ia32_pbroadcastb128_gpr_mask (__A,
                 (__v16qi)
                 _mm_setzero_si128 (),
                 __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_set1_epi8 (__m256i __O, __mmask32 __M, char __A)
{
  return (__m256i) __builtin_ia32_pbroadcastb256_gpr_mask (__A,
                 (__v32qi) __O,
                 __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_set1_epi8 (__mmask32 __M, char __A)
{
  return (__m256i) __builtin_ia32_pbroadcastb256_gpr_mask (__A,
                 (__v32qi)
                 _mm256_setzero_si256 (),
                 __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_loadu_epi16 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddquhi128_mask ((__v8hi *) __P,
                 (__v8hi) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_loadu_epi16 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddquhi128_mask ((__v8hi *) __P,
                 (__v8hi)
                 _mm_setzero_hi (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_loadu_epi16 (__m256i __W, __mmask16 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddquhi256_mask ((__v16hi *) __P,
                 (__v16hi) __W,
                 (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_loadu_epi16 (__mmask16 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddquhi256_mask ((__v16hi *) __P,
                 (__v16hi)
                 _mm256_setzero_si256 (),
                 (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_loadu_epi8 (__m128i __W, __mmask16 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddquqi128_mask ((__v16qi *) __P,
                 (__v16qi) __W,
                 (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_loadu_epi8 (__mmask16 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddquqi128_mask ((__v16qi *) __P,
                 (__v16qi)
                 _mm_setzero_si128 (),
                 (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_loadu_epi8 (__m256i __W, __mmask32 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddquqi256_mask ((__v32qi *) __P,
                 (__v32qi) __W,
                 (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_loadu_epi8 (__mmask32 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddquqi256_mask ((__v32qi *) __P,
                 (__v32qi)
                 _mm256_setzero_si256 (),
                 (__mmask32) __U);
}
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_storeu_epi16 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_storedquhi128_mask ((__v8hi *) __P,
             (__v8hi) __A,
             (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_storeu_epi16 (void *__P, __mmask16 __U, __m256i __A)
{
  __builtin_ia32_storedquhi256_mask ((__v16hi *) __P,
             (__v16hi) __A,
             (__mmask16) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_storeu_epi8 (void *__P, __mmask16 __U, __m128i __A)
{
  __builtin_ia32_storedquqi128_mask ((__v16qi *) __P,
             (__v16qi) __A,
             (__mmask16) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_storeu_epi8 (void *__P, __mmask32 __U, __m256i __A)
{
  __builtin_ia32_storedquqi256_mask ((__v32qi *) __P,
             (__v32qi) __A,
             (__mmask32) __U);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_test_epi8_mask (__m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ptestmb128 ((__v16qi) __A,
            (__v16qi) __B,
            (__mmask16) -1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_test_epi8_mask (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ptestmb128 ((__v16qi) __A,
            (__v16qi) __B, __U);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_test_epi8_mask (__m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ptestmb256 ((__v32qi) __A,
            (__v32qi) __B,
            (__mmask32) -1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_test_epi8_mask (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ptestmb256 ((__v32qi) __A,
            (__v32qi) __B, __U);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_test_epi16_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmw128 ((__v8hi) __A,
                 (__v8hi) __B,
                 (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_test_epi16_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmw128 ((__v8hi) __A,
                 (__v8hi) __B, __U);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_test_epi16_mask (__m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ptestmw256 ((__v16hi) __A,
            (__v16hi) __B,
            (__mmask16) -1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_test_epi16_mask (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ptestmw256 ((__v16hi) __A,
            (__v16hi) __B, __U);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_testn_epi8_mask (__m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmb128 ((__v16qi) __A,
             (__v16qi) __B,
             (__mmask16) -1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_testn_epi8_mask (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmb128 ((__v16qi) __A,
             (__v16qi) __B, __U);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_testn_epi8_mask (__m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ptestnmb256 ((__v32qi) __A,
             (__v32qi) __B,
             (__mmask32) -1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_testn_epi8_mask (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ptestnmb256 ((__v32qi) __A,
             (__v32qi) __B, __U);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_testn_epi16_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmw128 ((__v8hi) __A,
            (__v8hi) __B,
            (__mmask8) -1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_testn_epi16_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmw128 ((__v8hi) __A,
            (__v8hi) __B, __U);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_testn_epi16_mask (__m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmw256 ((__v16hi) __A,
             (__v16hi) __B,
             (__mmask16) -1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_testn_epi16_mask (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmw256 ((__v16hi) __A,
             (__v16hi) __B, __U);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_movepi8_mask (__m128i __A)
{
  return (__mmask16) __builtin_ia32_cvtb2mask128 ((__v16qi) __A);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_movepi8_mask (__m256i __A)
{
  return (__mmask32) __builtin_ia32_cvtb2mask256 ((__v32qi) __A);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_movepi16_mask (__m128i __A)
{
  return (__mmask8) __builtin_ia32_cvtw2mask128 ((__v8hi) __A);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_movepi16_mask (__m256i __A)
{
  return (__mmask16) __builtin_ia32_cvtw2mask256 ((__v16hi) __A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_movm_epi8 (__mmask16 __A)
{
  return (__m128i) __builtin_ia32_cvtmask2b128 (__A);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_movm_epi8 (__mmask32 __A)
{
  return (__m256i) __builtin_ia32_cvtmask2b256 (__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_movm_epi16 (__mmask8 __A)
{
  return (__m128i) __builtin_ia32_cvtmask2w128 (__A);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_movm_epi16 (__mmask16 __A)
{
  return (__m256i) __builtin_ia32_cvtmask2w256 (__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_broadcastb_epi8 (__m128i __O, __mmask16 __M, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectb_128(__M,
                                             (__v16qi) _mm_broadcastb_epi8(__A),
                                             (__v16qi) __O);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_broadcastb_epi8 (__mmask16 __M, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectb_128(__M,
                                             (__v16qi) _mm_broadcastb_epi8(__A),
                                             (__v16qi) _mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_broadcastb_epi8 (__m256i __O, __mmask32 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectb_256(__M,
                                             (__v32qi) _mm256_broadcastb_epi8(__A),
                                             (__v32qi) __O);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_broadcastb_epi8 (__mmask32 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectb_256(__M,
                                             (__v32qi) _mm256_broadcastb_epi8(__A),
                                             (__v32qi) _mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_broadcastw_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectw_128(__M,
                                             (__v8hi) _mm_broadcastw_epi16(__A),
                                             (__v8hi) __O);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_broadcastw_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i)__builtin_ia32_selectw_128(__M,
                                             (__v8hi) _mm_broadcastw_epi16(__A),
                                             (__v8hi) _mm_setzero_si128());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_broadcastw_epi16 (__m256i __O, __mmask16 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectw_256(__M,
                                             (__v16hi) _mm256_broadcastw_epi16(__A),
                                             (__v16hi) __O);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_broadcastw_epi16 (__mmask16 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectw_256(__M,
                                             (__v16hi) _mm256_broadcastw_epi16(__A),
                                             (__v16hi) _mm256_setzero_si256());
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_set1_epi16 (__m256i __O, __mmask16 __M, short __A)
{
  return (__m256i) __builtin_ia32_pbroadcastw256_gpr_mask (__A,
                 (__v16hi) __O,
                 __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_set1_epi16 (__mmask16 __M, short __A)
{
  return (__m256i) __builtin_ia32_pbroadcastw256_gpr_mask (__A,
                 (__v16hi) _mm256_setzero_si256 (),
                 __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_set1_epi16 (__m128i __O, __mmask8 __M, short __A)
{
  return (__m128i) __builtin_ia32_pbroadcastw128_gpr_mask (__A,
                 (__v8hi) __O,
                 __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_set1_epi16 (__mmask8 __M, short __A)
{
  return (__m128i) __builtin_ia32_pbroadcastw128_gpr_mask (__A,
                 (__v8hi) _mm_setzero_si128 (),
                 __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_permutexvar_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarhi128_mask ((__v8hi) __B,
                 (__v8hi) __A,
                 (__v8hi) _mm_undefined_si128 (),
                 (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_permutexvar_epi16 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarhi128_mask ((__v8hi) __B,
                 (__v8hi) __A,
                 (__v8hi) _mm_setzero_si128 (),
                 (__mmask8) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_permutexvar_epi16 (__m128i __W, __mmask8 __M, __m128i __A,
          __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarhi128_mask ((__v8hi) __B,
                 (__v8hi) __A,
                 (__v8hi) __W,
                 (__mmask8) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_permutexvar_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarhi256_mask ((__v16hi) __B,
                 (__v16hi) __A,
                 (__v16hi) _mm256_undefined_si256 (),
                 (__mmask16) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_permutexvar_epi16 (__mmask16 __M, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarhi256_mask ((__v16hi) __B,
                 (__v16hi) __A,
                 (__v16hi) _mm256_setzero_si256 (),
                 (__mmask16) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_permutexvar_epi16 (__m256i __W, __mmask16 __M, __m256i __A,
             __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarhi256_mask ((__v16hi) __B,
                 (__v16hi) __A,
                 (__v16hi) __W,
                 (__mmask16) __M);
}
# 160 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlcdintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vlcdintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_broadcastmb_epi64 (__mmask8 __A)
{
  return (__m128i) __builtin_ia32_broadcastmb128 (__A);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_broadcastmb_epi64 (__mmask8 __A)
{
  return (__m256i) __builtin_ia32_broadcastmb256 (__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_broadcastmw_epi32 (__mmask16 __A)
{
  return (__m128i) __builtin_ia32_broadcastmw128 (__A);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_broadcastmw_epi32 (__mmask16 __A)
{
  return (__m256i) __builtin_ia32_broadcastmw256 (__A);
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_conflict_epi64 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictdi_128_mask ((__v2di) __A,
               (__v2di) _mm_undefined_si128 (),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_mask_conflict_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictdi_128_mask ((__v2di) __A,
               (__v2di) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_maskz_conflict_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictdi_128_mask ((__v2di) __A,
               (__v2di)
               _mm_setzero_di (),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_conflict_epi64 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictdi_256_mask ((__v4di) __A,
               (__v4di) _mm256_undefined_si256 (),
               (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_mask_conflict_epi64 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictdi_256_mask ((__v4di) __A,
               (__v4di) __W,
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_maskz_conflict_epi64 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictdi_256_mask ((__v4di) __A,
               (__v4di) _mm256_setzero_si256 (),
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_conflict_epi32 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictsi_128_mask ((__v4si) __A,
               (__v4si) _mm_undefined_si128 (),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_mask_conflict_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictsi_128_mask ((__v4si) __A,
               (__v4si) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_maskz_conflict_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictsi_128_mask ((__v4si) __A,
               (__v4si) _mm_setzero_si128 (),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_conflict_epi32 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictsi_256_mask ((__v8si) __A,
               (__v8si) _mm256_undefined_si256 (),
               (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_mask_conflict_epi32 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictsi_256_mask ((__v8si) __A,
               (__v8si) __W,
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_maskz_conflict_epi32 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictsi_256_mask ((__v8si) __A,
               (__v8si)
               _mm256_setzero_si256 (),
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_lzcnt_epi32 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntd_128_mask ((__v4si) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_mask_lzcnt_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntd_128_mask ((__v4si) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_maskz_lzcnt_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntd_128_mask ((__v4si) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_lzcnt_epi32 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntd_256_mask ((__v8si) __A,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_mask_lzcnt_epi32 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntd_256_mask ((__v8si) __A,
                 (__v8si) __W,
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_maskz_lzcnt_epi32 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntd_256_mask ((__v8si) __A,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_lzcnt_epi64 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntq_128_mask ((__v2di) __A,
                 (__v2di)
                 _mm_setzero_di (),
                 (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_mask_lzcnt_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntq_128_mask ((__v2di) __A,
                 (__v2di) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm_maskz_lzcnt_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntq_128_mask ((__v2di) __A,
                 (__v2di)
                 _mm_setzero_di (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_lzcnt_epi64 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntq_256_mask ((__v4di) __A,
                 (__v4di)
                 _mm256_setzero_si256 (),
                 (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_mask_lzcnt_epi64 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntq_256_mask ((__v4di) __A,
                 (__v4di) __W,
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512cd")))
_mm256_maskz_lzcnt_epi64 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntq_256_mask ((__v4di) __A,
                 (__v4di)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}
# 165 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vldqintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vldqintrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mullo_epi64 (__m256i __A, __m256i __B) {
  return (__m256i) ((__v4du) __A * (__v4du) __B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_mullo_epi64(__m256i __W, __mmask8 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_mullo_epi64(__A, __B),
                                             (__v4di)__W);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_mullo_epi64(__mmask8 __U, __m256i __A, __m256i __B) {
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__U,
                                             (__v4di)_mm256_mullo_epi64(__A, __B),
                                             (__v4di)_mm256_setzero_si256());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mullo_epi64 (__m128i __A, __m128i __B) {
  return (__m128i) ((__v2du) __A * (__v2du) __B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_mullo_epi64(__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_mullo_epi64(__A, __B),
                                             (__v2di)__W);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_mullo_epi64(__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i)__builtin_ia32_selectq_128((__mmask8)__U,
                                             (__v2di)_mm_mullo_epi64(__A, __B),
                                             (__v2di)_mm_setzero_si128());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_andnot_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_andnot_pd(__A, __B),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_andnot_pd(__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_andnot_pd(__A, __B),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_andnot_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_andnot_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_andnot_pd(__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_andnot_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_andnot_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_andnot_ps(__A, __B),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_andnot_ps(__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_andnot_ps(__A, __B),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_andnot_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_andnot_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_andnot_ps(__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_andnot_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_and_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_and_pd(__A, __B),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_and_pd(__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_and_pd(__A, __B),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_and_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_and_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_and_pd(__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_and_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_and_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_and_ps(__A, __B),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_and_ps(__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_and_ps(__A, __B),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_and_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_and_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_and_ps(__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_and_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_xor_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_xor_pd(__A, __B),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_xor_pd(__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_xor_pd(__A, __B),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_xor_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_xor_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_xor_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_xor_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_xor_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_xor_ps(__A, __B),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_xor_ps(__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_xor_ps(__A, __B),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_xor_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_xor_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_xor_ps(__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_xor_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_or_pd(__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_or_pd(__A, __B),
                                              (__v4df)__W);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_or_pd(__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__U,
                                              (__v4df)_mm256_or_pd(__A, __B),
                                              (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_or_pd(__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_or_pd(__A, __B),
                                              (__v2df)__W);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_or_pd(__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d)__builtin_ia32_selectpd_128((__mmask8)__U,
                                              (__v2df)_mm_or_pd(__A, __B),
                                              (__v2df)_mm_setzero_pd());
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_or_ps(__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_or_ps(__A, __B),
                                             (__v8sf)__W);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_or_ps(__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256)__builtin_ia32_selectps_256((__mmask8)__U,
                                             (__v8sf)_mm256_or_ps(__A, __B),
                                             (__v8sf)_mm256_setzero_ps());
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_or_ps(__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_or_ps(__A, __B),
                                             (__v4sf)__W);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_or_ps(__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128)__builtin_ia32_selectps_128((__mmask8)__U,
                                             (__v4sf)_mm_or_ps(__A, __B),
                                             (__v4sf)_mm_setzero_ps());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtpd_epi64 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2qq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtpd_epi64 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2qq128_mask ((__v2df) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtpd_epi64 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2qq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtpd_epi64 (__m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2qq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtpd_epi64 (__m256i __W, __mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2qq256_mask ((__v4df) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtpd_epi64 (__mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2qq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtpd_epu64 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2uqq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtpd_epu64 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2uqq128_mask ((__v2df) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtpd_epu64 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2uqq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtpd_epu64 (__m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2uqq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtpd_epu64 (__m256i __W, __mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2uqq256_mask ((__v4df) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtpd_epu64 (__mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2uqq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtps_epi64 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2qq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtps_epi64 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2qq128_mask ((__v4sf) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtps_epi64 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2qq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtps_epi64 (__m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2qq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtps_epi64 (__m256i __W, __mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2qq256_mask ((__v4sf) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtps_epi64 (__mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2qq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtps_epu64 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2uqq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtps_epu64 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2uqq128_mask ((__v4sf) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtps_epu64 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2uqq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtps_epu64 (__m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2uqq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtps_epu64 (__m256i __W, __mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2uqq256_mask ((__v4sf) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtps_epu64 (__mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2uqq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtepi64_pd (__m128i __A) {
  return (__m128d) __builtin_ia32_cvtqq2pd128_mask ((__v2di) __A,
                (__v2df) _mm_setzero_pd(),
                (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtepi64_pd (__m128d __W, __mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtqq2pd128_mask ((__v2di) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtepi64_pd (__mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtqq2pd128_mask ((__v2di) __A,
                (__v2df) _mm_setzero_pd(),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtepi64_pd (__m256i __A) {
  return (__m256d) __builtin_ia32_cvtqq2pd256_mask ((__v4di) __A,
                (__v4df) _mm256_setzero_pd(),
                (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtepi64_pd (__m256d __W, __mmask8 __U, __m256i __A) {
  return (__m256d) __builtin_ia32_cvtqq2pd256_mask ((__v4di) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtepi64_pd (__mmask8 __U, __m256i __A) {
  return (__m256d) __builtin_ia32_cvtqq2pd256_mask ((__v4di) __A,
                (__v4df) _mm256_setzero_pd(),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtepi64_ps (__m128i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps128_mask ((__v2di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtepi64_ps (__m128 __W, __mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps128_mask ((__v2di) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtepi64_ps (__mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps128_mask ((__v2di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtepi64_ps (__m256i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps256_mask ((__v4di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtepi64_ps (__m128 __W, __mmask8 __U, __m256i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps256_mask ((__v4di) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtepi64_ps (__mmask8 __U, __m256i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps256_mask ((__v4di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvttpd_epi64 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2qq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvttpd_epi64 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2qq128_mask ((__v2df) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvttpd_epi64 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2qq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvttpd_epi64 (__m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2qq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvttpd_epi64 (__m256i __W, __mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2qq256_mask ((__v4df) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvttpd_epi64 (__mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2qq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvttpd_epu64 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2uqq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvttpd_epu64 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2uqq128_mask ((__v2df) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvttpd_epu64 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2uqq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvttpd_epu64 (__m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2uqq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvttpd_epu64 (__m256i __W, __mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2uqq256_mask ((__v4df) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvttpd_epu64 (__mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2uqq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvttps_epi64 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2qq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvttps_epi64 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2qq128_mask ((__v4sf) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvttps_epi64 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2qq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvttps_epi64 (__m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2qq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvttps_epi64 (__m256i __W, __mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2qq256_mask ((__v4sf) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvttps_epi64 (__mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2qq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvttps_epu64 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2uqq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvttps_epu64 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2uqq128_mask ((__v4sf) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvttps_epu64 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2uqq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvttps_epu64 (__m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2uqq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvttps_epu64 (__m256i __W, __mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2uqq256_mask ((__v4sf) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvttps_epu64 (__mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2uqq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtepu64_pd (__m128i __A) {
  return (__m128d) __builtin_ia32_cvtuqq2pd128_mask ((__v2di) __A,
                (__v2df) _mm_setzero_pd(),
                (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtepu64_pd (__m128d __W, __mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtuqq2pd128_mask ((__v2di) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtepu64_pd (__mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtuqq2pd128_mask ((__v2di) __A,
                (__v2df) _mm_setzero_pd(),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtepu64_pd (__m256i __A) {
  return (__m256d) __builtin_ia32_cvtuqq2pd256_mask ((__v4di) __A,
                (__v4df) _mm256_setzero_pd(),
                (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtepu64_pd (__m256d __W, __mmask8 __U, __m256i __A) {
  return (__m256d) __builtin_ia32_cvtuqq2pd256_mask ((__v4di) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtepu64_pd (__mmask8 __U, __m256i __A) {
  return (__m256d) __builtin_ia32_cvtuqq2pd256_mask ((__v4di) __A,
                (__v4df) _mm256_setzero_pd(),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtepu64_ps (__m128i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps128_mask ((__v2di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtepu64_ps (__m128 __W, __mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps128_mask ((__v2di) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtepu64_ps (__mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps128_mask ((__v2di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtepu64_ps (__m256i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps256_mask ((__v4di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtepu64_ps (__m128 __W, __mmask8 __U, __m256i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps256_mask ((__v4di) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtepu64_ps (__mmask8 __U, __m256i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps256_mask ((__v4di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) __U);
}
# 930 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vldqintrin.h" 3 4
static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_movepi32_mask (__m128i __A)
{
  return (__mmask8) __builtin_ia32_cvtd2mask128 ((__v4si) __A);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_movepi32_mask (__m256i __A)
{
  return (__mmask8) __builtin_ia32_cvtd2mask256 ((__v8si) __A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_movm_epi32 (__mmask8 __A)
{
  return (__m128i) __builtin_ia32_cvtmask2d128 (__A);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_movm_epi32 (__mmask8 __A)
{
  return (__m256i) __builtin_ia32_cvtmask2d256 (__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_movm_epi64 (__mmask8 __A)
{
  return (__m128i) __builtin_ia32_cvtmask2q128 (__A);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_movm_epi64 (__mmask8 __A)
{
  return (__m256i) __builtin_ia32_cvtmask2q256 (__A);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_movepi64_mask (__m128i __A)
{
  return (__mmask8) __builtin_ia32_cvtq2mask128 ((__v2di) __A);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_movepi64_mask (__m256i __A)
{
  return (__mmask8) __builtin_ia32_cvtq2mask256 ((__v4di) __A);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_broadcast_f32x2 (__m128 __A)
{
  return (__m256) __builtin_ia32_broadcastf32x2_256_mask ((__v4sf) __A,
                (__v8sf)_mm256_undefined_ps(),
                (__mmask8) -1);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_broadcast_f32x2 (__m256 __O, __mmask8 __M, __m128 __A)
{
  return (__m256) __builtin_ia32_broadcastf32x2_256_mask ((__v4sf) __A,
                (__v8sf) __O,
                __M);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_broadcast_f32x2 (__mmask8 __M, __m128 __A)
{
  return (__m256) __builtin_ia32_broadcastf32x2_256_mask ((__v4sf) __A,
                (__v8sf) _mm256_setzero_ps (),
                __M);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_broadcast_f64x2(__m128d __A)
{
  return (__m256d)__builtin_shufflevector((__v2df)__A, (__v2df)__A,
                                          0, 1, 0, 1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_broadcast_f64x2(__m256d __O, __mmask8 __M, __m128d __A)
{
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__M,
                                            (__v4df)_mm256_broadcast_f64x2(__A),
                                            (__v4df)__O);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_broadcast_f64x2 (__mmask8 __M, __m128d __A)
{
  return (__m256d)__builtin_ia32_selectpd_256((__mmask8)__M,
                                            (__v4df)_mm256_broadcast_f64x2(__A),
                                            (__v4df)_mm256_setzero_pd());
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_broadcast_i32x2 (__m128i __A)
{
  return (__m128i) __builtin_ia32_broadcasti32x2_128_mask ((__v4si) __A,
                 (__v4si)_mm_undefined_si128(),
                 (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_broadcast_i32x2 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_broadcasti32x2_128_mask ((__v4si) __A,
                 (__v4si) __O,
                 __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_broadcast_i32x2 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_broadcasti32x2_128_mask ((__v4si) __A,
                 (__v4si) _mm_setzero_si128 (),
                 __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_broadcast_i32x2 (__m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti32x2_256_mask ((__v4si) __A,
                 (__v8si)_mm256_undefined_si256(),
                 (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_broadcast_i32x2 (__m256i __O, __mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti32x2_256_mask ((__v4si) __A,
                 (__v8si) __O,
                 __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_broadcast_i32x2 (__mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti32x2_256_mask ((__v4si) __A,
                 (__v8si) _mm256_setzero_si256 (),
                 __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_broadcast_i64x2(__m128i __A)
{
  return (__m256i)__builtin_shufflevector((__v2di)__A, (__v2di)__A,
                                          0, 1, 0, 1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_broadcast_i64x2(__m256i __O, __mmask8 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__M,
                                            (__v4di)_mm256_broadcast_i64x2(__A),
                                            (__v4di)__O);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_broadcast_i64x2 (__mmask8 __M, __m128i __A)
{
  return (__m256i)__builtin_ia32_selectq_256((__mmask8)__M,
                                            (__v4di)_mm256_broadcast_i64x2(__A),
                                            (__v4di)_mm256_setzero_si256());
}
# 170 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512erintrin.h" 1 3 4
# 174 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512ifmaintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512ifmaintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma")))
_mm512_madd52hi_epu64 (__m512i __X, __m512i __Y, __m512i __Z)
{
  return (__m512i) __builtin_ia32_vpmadd52huq512_mask ((__v8di) __X,
                   (__v8di) __Y,
                   (__v8di) __Z,
                   (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma")))
_mm512_mask_madd52hi_epu64 (__m512i __W, __mmask8 __M, __m512i __X,
          __m512i __Y)
{
  return (__m512i) __builtin_ia32_vpmadd52huq512_mask ((__v8di) __W,
                   (__v8di) __X,
                   (__v8di) __Y,
                   (__mmask8) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma")))
_mm512_maskz_madd52hi_epu64 (__mmask8 __M, __m512i __X, __m512i __Y, __m512i __Z)
{
  return (__m512i) __builtin_ia32_vpmadd52huq512_maskz ((__v8di) __X,
              (__v8di) __Y,
              (__v8di) __Z,
              (__mmask8) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma")))
_mm512_madd52lo_epu64 (__m512i __X, __m512i __Y, __m512i __Z)
{
  return (__m512i) __builtin_ia32_vpmadd52luq512_mask ((__v8di) __X,
                   (__v8di) __Y,
                   (__v8di) __Z,
                   (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma")))
_mm512_mask_madd52lo_epu64 (__m512i __W, __mmask8 __M, __m512i __X,
          __m512i __Y)
{
  return (__m512i) __builtin_ia32_vpmadd52luq512_mask ((__v8di) __W,
                   (__v8di) __X,
                   (__v8di) __Y,
                   (__mmask8) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma")))
_mm512_maskz_madd52lo_epu64 (__mmask8 __M, __m512i __X, __m512i __Y, __m512i __Z)
{
  return (__m512i) __builtin_ia32_vpmadd52luq512_maskz ((__v8di) __X,
              (__v8di) __Y,
              (__v8di) __Z,
              (__mmask8) __M);
}
# 178 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512ifmavlintrin.h" 1 3 4
# 36 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512ifmavlintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm_madd52hi_epu64 (__m128i __X, __m128i __Y, __m128i __Z)
{
  return (__m128i) __builtin_ia32_vpmadd52huq128_mask ((__v2di) __X,
                   (__v2di) __Y,
                   (__v2di) __Z,
                   (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm_mask_madd52hi_epu64 (__m128i __W, __mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_vpmadd52huq128_mask ((__v2di) __W,
                   (__v2di) __X,
                   (__v2di) __Y,
                   (__mmask8) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm_maskz_madd52hi_epu64 (__mmask8 __M, __m128i __X, __m128i __Y, __m128i __Z)
{
  return (__m128i) __builtin_ia32_vpmadd52huq128_maskz ((__v2di) __X,
              (__v2di) __Y,
              (__v2di) __Z,
              (__mmask8) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm256_madd52hi_epu64 (__m256i __X, __m256i __Y, __m256i __Z)
{
  return (__m256i) __builtin_ia32_vpmadd52huq256_mask ((__v4di) __X,
                   (__v4di) __Y,
                   (__v4di) __Z,
                   (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm256_mask_madd52hi_epu64 (__m256i __W, __mmask8 __M, __m256i __X,
          __m256i __Y)
{
  return (__m256i) __builtin_ia32_vpmadd52huq256_mask ((__v4di) __W,
                   (__v4di) __X,
                   (__v4di) __Y,
                   (__mmask8) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm256_maskz_madd52hi_epu64 (__mmask8 __M, __m256i __X, __m256i __Y, __m256i __Z)
{
  return (__m256i) __builtin_ia32_vpmadd52huq256_maskz ((__v4di) __X,
              (__v4di) __Y,
              (__v4di) __Z,
              (__mmask8) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm_madd52lo_epu64 (__m128i __X, __m128i __Y, __m128i __Z)
{
  return (__m128i) __builtin_ia32_vpmadd52luq128_mask ((__v2di) __X,
                   (__v2di) __Y,
                   (__v2di) __Z,
                   (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm_mask_madd52lo_epu64 (__m128i __W, __mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_vpmadd52luq128_mask ((__v2di) __W,
                   (__v2di) __X,
                   (__v2di) __Y,
                   (__mmask8) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm_maskz_madd52lo_epu64 (__mmask8 __M, __m128i __X, __m128i __Y, __m128i __Z)
{
  return (__m128i) __builtin_ia32_vpmadd52luq128_maskz ((__v2di) __X,
              (__v2di) __Y,
              (__v2di) __Z,
              (__mmask8) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm256_madd52lo_epu64 (__m256i __X, __m256i __Y, __m256i __Z)
{
  return (__m256i) __builtin_ia32_vpmadd52luq256_mask ((__v4di) __X,
                   (__v4di) __Y,
                   (__v4di) __Z,
                   (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm256_mask_madd52lo_epu64 (__m256i __W, __mmask8 __M, __m256i __X,
          __m256i __Y)
{
  return (__m256i) __builtin_ia32_vpmadd52luq256_mask ((__v4di) __W,
                   (__v4di) __X,
                   (__v4di) __Y,
                   (__mmask8) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512ifma,avx512vl")))
_mm256_maskz_madd52lo_epu64 (__mmask8 __M, __m256i __X, __m256i __Y, __m256i __Z)
{
  return (__m256i) __builtin_ia32_vpmadd52luq256_maskz ((__v4di) __X,
              (__v4di) __Y,
              (__v4di) __Z,
              (__mmask8) __M);
}
# 183 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vbmiintrin.h" 1 3 4
# 35 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vbmiintrin.h" 3 4
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi")))
_mm512_mask2_permutex2var_epi8 (__m512i __A, __m512i __I,
         __mmask64 __U, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermi2varqi512_mask ((__v64qi) __A,
              (__v64qi) __I
                        ,
              (__v64qi) __B,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi")))
_mm512_permutex2var_epi8 (__m512i __A, __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varqi512_mask ((__v64qi) __I
                        ,
              (__v64qi) __A,
              (__v64qi) __B,
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi")))
_mm512_mask_permutex2var_epi8 (__m512i __A, __mmask64 __U,
        __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varqi512_mask ((__v64qi) __I
                        ,
              (__v64qi) __A,
              (__v64qi) __B,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi")))
_mm512_maskz_permutex2var_epi8 (__mmask64 __U, __m512i __A,
         __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varqi512_maskz ((__v64qi) __I
                         ,
               (__v64qi) __A,
               (__v64qi) __B,
               (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi")))
_mm512_permutexvar_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarqi512_mask ((__v64qi) __B,
                 (__v64qi) __A,
                 (__v64qi) _mm512_undefined_epi32 (),
                 (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi")))
_mm512_maskz_permutexvar_epi8 (__mmask64 __M, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarqi512_mask ((__v64qi) __B,
                 (__v64qi) __A,
                 (__v64qi) _mm512_setzero_si512(),
                 (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi")))
_mm512_mask_permutexvar_epi8 (__m512i __W, __mmask64 __M, __m512i __A,
             __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarqi512_mask ((__v64qi) __B,
                 (__v64qi) __A,
                 (__v64qi) __W,
                 (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi")))
_mm512_mask_multishift_epi64_epi8 (__m512i __W, __mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_vpmultishiftqb512_mask ((__v64qi) __X,
                (__v64qi) __Y,
                (__v64qi) __W,
                (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi")))
_mm512_maskz_multishift_epi64_epi8 (__mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_vpmultishiftqb512_mask ((__v64qi) __X,
                (__v64qi) __Y,
                (__v64qi) _mm512_setzero_si512 (),
                (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi")))
_mm512_multishift_epi64_epi8 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_vpmultishiftqb512_mask ((__v64qi) __X,
                (__v64qi) __Y,
                (__v64qi) _mm512_undefined_epi32 (),
                (__mmask64) -1);
}
# 187 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vbmivlintrin.h" 1 3 4
# 35 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512vbmivlintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm_mask2_permutex2var_epi8 (__m128i __A, __m128i __I, __mmask16 __U,
            __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermi2varqi128_mask ((__v16qi) __A,
              (__v16qi) __I
                        ,
              (__v16qi) __B,
              (__mmask16)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm256_mask2_permutex2var_epi8 (__m256i __A, __m256i __I,
         __mmask32 __U, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermi2varqi256_mask ((__v32qi) __A,
              (__v32qi) __I
                        ,
              (__v32qi) __B,
              (__mmask32)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm_permutex2var_epi8 (__m128i __A, __m128i __I, __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varqi128_mask ((__v16qi) __I
                        ,
              (__v16qi) __A,
              (__v16qi) __B,
              (__mmask16) -
              1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm_mask_permutex2var_epi8 (__m128i __A, __mmask16 __U, __m128i __I,
           __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varqi128_mask ((__v16qi) __I
                        ,
              (__v16qi) __A,
              (__v16qi) __B,
              (__mmask16)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm_maskz_permutex2var_epi8 (__mmask16 __U, __m128i __A, __m128i __I,
            __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varqi128_maskz ((__v16qi) __I
                         ,
               (__v16qi) __A,
               (__v16qi) __B,
               (__mmask16)
               __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm256_permutex2var_epi8 (__m256i __A, __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varqi256_mask ((__v32qi) __I
                        ,
              (__v32qi) __A,
              (__v32qi) __B,
              (__mmask32) -
              1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm256_mask_permutex2var_epi8 (__m256i __A, __mmask32 __U,
        __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varqi256_mask ((__v32qi) __I
                        ,
              (__v32qi) __A,
              (__v32qi) __B,
              (__mmask32)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm256_maskz_permutex2var_epi8 (__mmask32 __U, __m256i __A,
         __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varqi256_maskz ((__v32qi) __I
                         ,
               (__v32qi) __A,
               (__v32qi) __B,
               (__mmask32)
               __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm_permutexvar_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarqi128_mask ((__v16qi) __B,
                 (__v16qi) __A,
                 (__v16qi) _mm_undefined_si128 (),
                 (__mmask16) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm_maskz_permutexvar_epi8 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarqi128_mask ((__v16qi) __B,
                 (__v16qi) __A,
                 (__v16qi) _mm_setzero_si128 (),
                 (__mmask16) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm_mask_permutexvar_epi8 (__m128i __W, __mmask16 __M, __m128i __A,
          __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarqi128_mask ((__v16qi) __B,
                 (__v16qi) __A,
                 (__v16qi) __W,
                 (__mmask16) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm256_permutexvar_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarqi256_mask ((__v32qi) __B,
                 (__v32qi) __A,
                 (__v32qi) _mm256_undefined_si256 (),
                 (__mmask32) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm256_maskz_permutexvar_epi8 (__mmask32 __M, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarqi256_mask ((__v32qi) __B,
                 (__v32qi) __A,
                 (__v32qi) _mm256_setzero_si256 (),
                 (__mmask32) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm256_mask_permutexvar_epi8 (__m256i __W, __mmask32 __M, __m256i __A,
             __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarqi256_mask ((__v32qi) __B,
                 (__v32qi) __A,
                 (__v32qi) __W,
                 (__mmask32) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm_mask_multishift_epi64_epi8 (__m128i __W, __mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_vpmultishiftqb128_mask ((__v16qi) __X,
                (__v16qi) __Y,
                (__v16qi) __W,
                (__mmask16) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm_maskz_multishift_epi64_epi8 (__mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_vpmultishiftqb128_mask ((__v16qi) __X,
                (__v16qi) __Y,
                (__v16qi)
                _mm_setzero_si128 (),
                (__mmask16) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm_multishift_epi64_epi8 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_vpmultishiftqb128_mask ((__v16qi) __X,
                (__v16qi) __Y,
                (__v16qi)
                _mm_undefined_si128 (),
                (__mmask16) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm256_mask_multishift_epi64_epi8 (__m256i __W, __mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_vpmultishiftqb256_mask ((__v32qi) __X,
                (__v32qi) __Y,
                (__v32qi) __W,
                (__mmask32) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm256_maskz_multishift_epi64_epi8 (__mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_vpmultishiftqb256_mask ((__v32qi) __X,
                (__v32qi) __Y,
                (__v32qi)
                _mm256_setzero_si256 (),
                (__mmask32) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vbmi,avx512vl")))
_mm256_multishift_epi64_epi8 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_vpmultishiftqb256_mask ((__v32qi) __X,
                (__v32qi) __Y,
                (__v32qi)
                _mm256_undefined_si256 (),
                (__mmask32) -1);
}
# 192 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/avx512pfintrin.h" 1 3 4
# 196 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pkuintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/pkuintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("pku")))
_rdpkru_u32(void)
{
  return __builtin_ia32_rdpkru();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("pku")))
_wrpkru(unsigned int __val)
{
  return __builtin_ia32_wrpkru(__val);
}
# 200 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdrnd")))
_rdrand16_step(unsigned short *__p)
{
  return __builtin_ia32_rdrand16_step(__p);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdrnd")))
_rdrand32_step(unsigned int *__p)
{
  return __builtin_ia32_rdrand32_step(__p);
}


static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdrnd")))
_rdrand64_step(unsigned long long *__p)
{
  return __builtin_ia32_rdrand64_step(__p);
}




static __inline__ int __attribute__((__always_inline__, __nodebug__))
_bit_scan_forward(int __A) {
  return __builtin_ctz(__A);
}


static __inline__ int __attribute__((__always_inline__, __nodebug__))
_bit_scan_reverse(int __A) {
  return 31 - __builtin_clz(__A);
}



static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readfsbase_u32(void)
{
  return __builtin_ia32_rdfsbase32();
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readfsbase_u64(void)
{
  return __builtin_ia32_rdfsbase64();
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readgsbase_u32(void)
{
  return __builtin_ia32_rdgsbase32();
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readgsbase_u64(void)
{
  return __builtin_ia32_rdgsbase64();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writefsbase_u32(unsigned int __V)
{
  return __builtin_ia32_wrfsbase32(__V);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writefsbase_u64(unsigned long long __V)
{
  return __builtin_ia32_wrfsbase64(__V);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writegsbase_u32(unsigned int __V)
{
  return __builtin_ia32_wrgsbase32(__V);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writegsbase_u64(unsigned long long __V)
{
  return __builtin_ia32_wrgsbase64(__V);
}






# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/rtmintrin.h" 1 3 4
# 43 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/rtmintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("rtm")))
_xbegin(void)
{
  return __builtin_ia32_xbegin();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("rtm")))
_xend(void)
{
  __builtin_ia32_xend();
}
# 291 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xtestintrin.h" 1 3 4
# 35 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xtestintrin.h" 3 4
static __inline__ int
    __attribute__((__always_inline__, __nodebug__, __target__("rtm")))
    _xtest(void) {
  return __builtin_ia32_xtest();
}
# 292 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/shaintrin.h" 1 3 4
# 37 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/shaintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha1nexte_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha1nexte((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha1msg1_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha1msg1((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha1msg2_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha1msg2((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha256rnds2_epu32(__m128i __X, __m128i __Y, __m128i __Z)
{
  return (__m128i)__builtin_ia32_sha256rnds2((__v4si)__X, (__v4si)__Y, (__v4si)__Z);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha256msg1_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha256msg1((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha256msg2_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha256msg2((__v4si)__X, (__v4si)__Y);
}
# 296 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/fxsrintrin.h" 1 3 4
# 43 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxsave(void *__p)
{
  return __builtin_ia32_fxsave(__p);
}
# 61 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxrstor(void *__p)
{
  return __builtin_ia32_fxrstor(__p);
}
# 78 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxsave64(void *__p)
{
  return __builtin_ia32_fxsave64(__p);
}
# 96 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxrstor64(void *__p)
{
  return __builtin_ia32_fxrstor64(__p);
}
# 300 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xsaveintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xsaveintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xsave(void *__p, unsigned long long __m) {
  return __builtin_ia32_xsave(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xrstor(void *__p, unsigned long long __m) {
  return __builtin_ia32_xrstor(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xsave64(void *__p, unsigned long long __m) {
  return __builtin_ia32_xsave64(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xrstor64(void *__p, unsigned long long __m) {
  return __builtin_ia32_xrstor64(__p, __m);
}
# 304 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xsaveoptintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xsaveoptintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaveopt")))
_xsaveopt(void *__p, unsigned long long __m) {
  return __builtin_ia32_xsaveopt(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaveopt")))
_xsaveopt64(void *__p, unsigned long long __m) {
  return __builtin_ia32_xsaveopt64(__p, __m);
}
# 308 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xsavecintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xsavecintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsavec")))
_xsavec(void *__p, unsigned long long __m) {
  __builtin_ia32_xsavec(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsavec")))
_xsavec64(void *__p, unsigned long long __m) {
  __builtin_ia32_xsavec64(__p, __m);
}
# 312 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xsavesintrin.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/xsavesintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xsaves(void *__p, unsigned long long __m) {
  __builtin_ia32_xsaves(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xrstors(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstors(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xrstors64(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstors64(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xsaves64(void *__p, unsigned long long __m) {
  __builtin_ia32_xsaves64(__p, __m);
}
# 316 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/adxintrin.h" 1 3 4
# 35 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/adxintrin.h" 3 4
static inline unsigned char __attribute__((__always_inline__, __nodebug__, __target__("adx")))
_addcarryx_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
               unsigned int *__p)
{
  return __builtin_ia32_addcarryx_u32(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__, __target__("adx")))
_addcarryx_u64(unsigned char __cf, unsigned long long __x,
               unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_addcarryx_u64(__cf, __x, __y, __p);
}



static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_addcarry_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
              unsigned int *__p)
{
  return __builtin_ia32_addcarry_u32(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_addcarry_u64(unsigned char __cf, unsigned long long __x,
              unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_addcarry_u64(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_subborrow_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
              unsigned int *__p)
{
  return __builtin_ia32_subborrow_u32(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_subborrow_u64(unsigned char __cf, unsigned long long __x,
               unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_subborrow_u64(__cf, __x, __y, __p);
}
# 321 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/immintrin.h" 2 3 4
# 65 "/usr/local/include/SDL2/SDL_cpuinfo.h" 2
# 81 "/usr/local/include/SDL2/SDL_cpuinfo.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 82 "/usr/local/include/SDL2/SDL_cpuinfo.h" 2


extern "C" {
# 97 "/usr/local/include/SDL2/SDL_cpuinfo.h"
extern __attribute__ ((visibility("default"))) int SDL_GetCPUCount(void);







extern __attribute__ ((visibility("default"))) int SDL_GetCPUCacheLineSize(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasRDTSC(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasAltiVec(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasMMX(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_Has3DNow(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE2(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE3(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE41(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE42(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasAVX(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasAVX2(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasNEON(void);




extern __attribute__ ((visibility("default"))) int SDL_GetSystemRAM(void);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 178 "/usr/local/include/SDL2/SDL_cpuinfo.h" 2
# 39 "/usr/local/include/SDL2/SDL.h" 2


# 1 "/usr/local/include/SDL2/SDL_events.h" 1
# 33 "/usr/local/include/SDL2/SDL_events.h"
# 1 "/usr/local/include/SDL2/SDL_video.h" 1
# 32 "/usr/local/include/SDL2/SDL_video.h"
# 1 "/usr/local/include/SDL2/SDL_pixels.h" 1
# 34 "/usr/local/include/SDL2/SDL_pixels.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 35 "/usr/local/include/SDL2/SDL_pixels.h" 2


extern "C" {
# 51 "/usr/local/include/SDL2/SDL_pixels.h"
enum
{
    SDL_PIXELTYPE_UNKNOWN,
    SDL_PIXELTYPE_INDEX1,
    SDL_PIXELTYPE_INDEX4,
    SDL_PIXELTYPE_INDEX8,
    SDL_PIXELTYPE_PACKED8,
    SDL_PIXELTYPE_PACKED16,
    SDL_PIXELTYPE_PACKED32,
    SDL_PIXELTYPE_ARRAYU8,
    SDL_PIXELTYPE_ARRAYU16,
    SDL_PIXELTYPE_ARRAYU32,
    SDL_PIXELTYPE_ARRAYF16,
    SDL_PIXELTYPE_ARRAYF32
};


enum
{
    SDL_BITMAPORDER_NONE,
    SDL_BITMAPORDER_4321,
    SDL_BITMAPORDER_1234
};


enum
{
    SDL_PACKEDORDER_NONE,
    SDL_PACKEDORDER_XRGB,
    SDL_PACKEDORDER_RGBX,
    SDL_PACKEDORDER_ARGB,
    SDL_PACKEDORDER_RGBA,
    SDL_PACKEDORDER_XBGR,
    SDL_PACKEDORDER_BGRX,
    SDL_PACKEDORDER_ABGR,
    SDL_PACKEDORDER_BGRA
};




enum
{
    SDL_ARRAYORDER_NONE,
    SDL_ARRAYORDER_RGB,
    SDL_ARRAYORDER_RGBA,
    SDL_ARRAYORDER_ARGB,
    SDL_ARRAYORDER_BGR,
    SDL_ARRAYORDER_BGRA,
    SDL_ARRAYORDER_ABGR
};


enum
{
    SDL_PACKEDLAYOUT_NONE,
    SDL_PACKEDLAYOUT_332,
    SDL_PACKEDLAYOUT_4444,
    SDL_PACKEDLAYOUT_1555,
    SDL_PACKEDLAYOUT_5551,
    SDL_PACKEDLAYOUT_565,
    SDL_PACKEDLAYOUT_8888,
    SDL_PACKEDLAYOUT_2101010,
    SDL_PACKEDLAYOUT_1010102
};
# 171 "/usr/local/include/SDL2/SDL_pixels.h"
enum
{
    SDL_PIXELFORMAT_UNKNOWN,
    SDL_PIXELFORMAT_INDEX1LSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX1) << 24) | ((SDL_BITMAPORDER_4321) << 20) | ((0) << 16) | ((1) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX1MSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX1) << 24) | ((SDL_BITMAPORDER_1234) << 20) | ((0) << 16) | ((1) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX4LSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX4) << 24) | ((SDL_BITMAPORDER_4321) << 20) | ((0) << 16) | ((4) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX4MSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX4) << 24) | ((SDL_BITMAPORDER_1234) << 20) | ((0) << 16) | ((4) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX8 =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX8) << 24) | ((0) << 20) | ((0) << 16) | ((8) << 8) | ((1) << 0)),
    SDL_PIXELFORMAT_RGB332 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED8) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_332) << 16) | ((8) << 8) | ((1) << 0)),

    SDL_PIXELFORMAT_RGB444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((12) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGB555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((15) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGR555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((15) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ARGB4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGBA4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ABGR4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGRA4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ARGB1555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGBA5551 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_5551) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ABGR1555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGRA5551 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_5551) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGB565 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_565) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGR565 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_565) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGB24 =
        ((1 << 28) | ((SDL_PIXELTYPE_ARRAYU8) << 24) | ((SDL_ARRAYORDER_RGB) << 20) | ((0) << 16) | ((24) << 8) | ((3) << 0)),

    SDL_PIXELFORMAT_BGR24 =
        ((1 << 28) | ((SDL_PIXELTYPE_ARRAYU8) << 24) | ((SDL_ARRAYORDER_BGR) << 20) | ((0) << 16) | ((24) << 8) | ((3) << 0)),

    SDL_PIXELFORMAT_RGB888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_RGBX8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_RGBX) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_BGR888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_BGRX8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_BGRX) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_ARGB8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_RGBA8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_ABGR8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_BGRA8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_ARGB2101010 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_2101010) << 16) | ((32) << 8) | ((4) << 0)),
# 271 "/usr/local/include/SDL2/SDL_pixels.h"
    SDL_PIXELFORMAT_RGBA32 = SDL_PIXELFORMAT_ABGR8888,
    SDL_PIXELFORMAT_ARGB32 = SDL_PIXELFORMAT_BGRA8888,
    SDL_PIXELFORMAT_BGRA32 = SDL_PIXELFORMAT_ARGB8888,
    SDL_PIXELFORMAT_ABGR32 = SDL_PIXELFORMAT_RGBA8888,


    SDL_PIXELFORMAT_YV12 =
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_IYUV =
        ((static_cast<Uint32>(static_cast<Uint8>(('I'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 24)),
    SDL_PIXELFORMAT_YUY2 =
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_UYVY =
        ((static_cast<Uint32>(static_cast<Uint8>(('U'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 24)),
    SDL_PIXELFORMAT_YVYU =
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 24)),
    SDL_PIXELFORMAT_NV12 =
        ((static_cast<Uint32>(static_cast<Uint8>(('N'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_NV21 =
        ((static_cast<Uint32>(static_cast<Uint8>(('N'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 24)),
    SDL_PIXELFORMAT_EXTERNAL_OES =
        ((static_cast<Uint32>(static_cast<Uint8>(('O'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('E'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('S'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>((' '))) << 24))
};

typedef struct SDL_Color
{
    Uint8 r;
    Uint8 g;
    Uint8 b;
    Uint8 a;
} SDL_Color;


typedef struct SDL_Palette
{
    int ncolors;
    SDL_Color *colors;
    Uint32 version;
    int refcount;
} SDL_Palette;




typedef struct SDL_PixelFormat
{
    Uint32 format;
    SDL_Palette *palette;
    Uint8 BitsPerPixel;
    Uint8 BytesPerPixel;
    Uint8 padding[2];
    Uint32 Rmask;
    Uint32 Gmask;
    Uint32 Bmask;
    Uint32 Amask;
    Uint8 Rloss;
    Uint8 Gloss;
    Uint8 Bloss;
    Uint8 Aloss;
    Uint8 Rshift;
    Uint8 Gshift;
    Uint8 Bshift;
    Uint8 Ashift;
    int refcount;
    struct SDL_PixelFormat *next;
} SDL_PixelFormat;




extern __attribute__ ((visibility("default"))) const char* SDL_GetPixelFormatName(Uint32 format);
# 350 "/usr/local/include/SDL2/SDL_pixels.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_PixelFormatEnumToMasks(Uint32 format,
                                                            int *bpp,
                                                            Uint32 * Rmask,
                                                            Uint32 * Gmask,
                                                            Uint32 * Bmask,
                                                            Uint32 * Amask);
# 365 "/usr/local/include/SDL2/SDL_pixels.h"
extern __attribute__ ((visibility("default"))) Uint32 SDL_MasksToPixelFormatEnum(int bpp,
                                                          Uint32 Rmask,
                                                          Uint32 Gmask,
                                                          Uint32 Bmask,
                                                          Uint32 Amask);




extern __attribute__ ((visibility("default"))) SDL_PixelFormat * SDL_AllocFormat(Uint32 pixel_format);




extern __attribute__ ((visibility("default"))) void SDL_FreeFormat(SDL_PixelFormat *format);
# 391 "/usr/local/include/SDL2/SDL_pixels.h"
extern __attribute__ ((visibility("default"))) SDL_Palette * SDL_AllocPalette(int ncolors);




extern __attribute__ ((visibility("default"))) int SDL_SetPixelFormatPalette(SDL_PixelFormat * format,
                                                      SDL_Palette *palette);
# 409 "/usr/local/include/SDL2/SDL_pixels.h"
extern __attribute__ ((visibility("default"))) int SDL_SetPaletteColors(SDL_Palette * palette,
                                                 const SDL_Color * colors,
                                                 int firstcolor, int ncolors);






extern __attribute__ ((visibility("default"))) void SDL_FreePalette(SDL_Palette * palette);






extern __attribute__ ((visibility("default"))) Uint32 SDL_MapRGB(const SDL_PixelFormat * format,
                                          Uint8 r, Uint8 g, Uint8 b);






extern __attribute__ ((visibility("default"))) Uint32 SDL_MapRGBA(const SDL_PixelFormat * format,
                                           Uint8 r, Uint8 g, Uint8 b,
                                           Uint8 a);






extern __attribute__ ((visibility("default"))) void SDL_GetRGB(Uint32 pixel,
                                        const SDL_PixelFormat * format,
                                        Uint8 * r, Uint8 * g, Uint8 * b);






extern __attribute__ ((visibility("default"))) void SDL_GetRGBA(Uint32 pixel,
                                         const SDL_PixelFormat * format,
                                         Uint8 * r, Uint8 * g, Uint8 * b,
                                         Uint8 * a);




extern __attribute__ ((visibility("default"))) void SDL_CalculateGammaRamp(float gamma, Uint16 * ramp);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 467 "/usr/local/include/SDL2/SDL_pixels.h" 2
# 33 "/usr/local/include/SDL2/SDL_video.h" 2
# 1 "/usr/local/include/SDL2/SDL_rect.h" 1
# 36 "/usr/local/include/SDL2/SDL_rect.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 37 "/usr/local/include/SDL2/SDL_rect.h" 2


extern "C" {
# 48 "/usr/local/include/SDL2/SDL_rect.h"
typedef struct SDL_Point
{
    int x;
    int y;
} SDL_Point;
# 64 "/usr/local/include/SDL2/SDL_rect.h"
typedef struct SDL_Rect
{
    int x, y;
    int w, h;
} SDL_Rect;




__attribute__((always_inline)) static __inline__ SDL_bool SDL_PointInRect(const SDL_Point *p, const SDL_Rect *r)
{
    return ( (p->x >= r->x) && (p->x < (r->x + r->w)) &&
             (p->y >= r->y) && (p->y < (r->y + r->h)) ) ? SDL_TRUE : SDL_FALSE;
}




__attribute__((always_inline)) static __inline__ SDL_bool SDL_RectEmpty(const SDL_Rect *r)
{
    return ((!r) || (r->w <= 0) || (r->h <= 0)) ? SDL_TRUE : SDL_FALSE;
}




__attribute__((always_inline)) static __inline__ SDL_bool SDL_RectEquals(const SDL_Rect *a, const SDL_Rect *b)
{
    return (a && b && (a->x == b->x) && (a->y == b->y) &&
            (a->w == b->w) && (a->h == b->h)) ? SDL_TRUE : SDL_FALSE;
}






extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasIntersection(const SDL_Rect * A,
                                                     const SDL_Rect * B);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_IntersectRect(const SDL_Rect * A,
                                                   const SDL_Rect * B,
                                                   SDL_Rect * result);




extern __attribute__ ((visibility("default"))) void SDL_UnionRect(const SDL_Rect * A,
                                           const SDL_Rect * B,
                                           SDL_Rect * result);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_EnclosePoints(const SDL_Point * points,
                                                   int count,
                                                   const SDL_Rect * clip,
                                                   SDL_Rect * result);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_IntersectRectAndLine(const SDL_Rect *
                                                          rect, int *X1,
                                                          int *Y1, int *X2,
                                                          int *Y2);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 145 "/usr/local/include/SDL2/SDL_rect.h" 2
# 34 "/usr/local/include/SDL2/SDL_video.h" 2
# 1 "/usr/local/include/SDL2/SDL_surface.h" 1
# 34 "/usr/local/include/SDL2/SDL_surface.h"
# 1 "/usr/local/include/SDL2/SDL_blendmode.h" 1
# 31 "/usr/local/include/SDL2/SDL_blendmode.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 32 "/usr/local/include/SDL2/SDL_blendmode.h" 2


extern "C" {





typedef enum
{
    SDL_BLENDMODE_NONE = 0x00000000,

    SDL_BLENDMODE_BLEND = 0x00000001,


    SDL_BLENDMODE_ADD = 0x00000002,


    SDL_BLENDMODE_MOD = 0x00000004,


    SDL_BLENDMODE_INVALID = 0x7FFFFFFF



} SDL_BlendMode;




typedef enum
{
    SDL_BLENDOPERATION_ADD = 0x1,
    SDL_BLENDOPERATION_SUBTRACT = 0x2,
    SDL_BLENDOPERATION_REV_SUBTRACT = 0x3,
    SDL_BLENDOPERATION_MINIMUM = 0x4,
    SDL_BLENDOPERATION_MAXIMUM = 0x5

} SDL_BlendOperation;




typedef enum
{
    SDL_BLENDFACTOR_ZERO = 0x1,
    SDL_BLENDFACTOR_ONE = 0x2,
    SDL_BLENDFACTOR_SRC_COLOR = 0x3,
    SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 0x4,
    SDL_BLENDFACTOR_SRC_ALPHA = 0x5,
    SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 0x6,
    SDL_BLENDFACTOR_DST_COLOR = 0x7,
    SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 0x8,
    SDL_BLENDFACTOR_DST_ALPHA = 0x9,
    SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 0xA

} SDL_BlendFactor;
# 105 "/usr/local/include/SDL2/SDL_blendmode.h"
extern __attribute__ ((visibility("default"))) SDL_BlendMode SDL_ComposeCustomBlendMode(SDL_BlendFactor srcColorFactor,
                                                                 SDL_BlendFactor dstColorFactor,
                                                                 SDL_BlendOperation colorOperation,
                                                                 SDL_BlendFactor srcAlphaFactor,
                                                                 SDL_BlendFactor dstAlphaFactor,
                                                                 SDL_BlendOperation alphaOperation);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 117 "/usr/local/include/SDL2/SDL_blendmode.h" 2
# 35 "/usr/local/include/SDL2/SDL_surface.h" 2


# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 38 "/usr/local/include/SDL2/SDL_surface.h" 2


extern "C" {
# 69 "/usr/local/include/SDL2/SDL_surface.h"
typedef struct SDL_Surface
{
    Uint32 flags;
    SDL_PixelFormat *format;
    int w, h;
    int pitch;
    void *pixels;


    void *userdata;


    int locked;
    void *lock_data;


    SDL_Rect clip_rect;


    struct SDL_BlitMap *map;


    int refcount;
} SDL_Surface;




typedef int ( *SDL_blit) (struct SDL_Surface * src, SDL_Rect * srcrect,
                                 struct SDL_Surface * dst, SDL_Rect * dstrect);




typedef enum
{
    SDL_YUV_CONVERSION_JPEG,
    SDL_YUV_CONVERSION_BT601,
    SDL_YUV_CONVERSION_BT709,
    SDL_YUV_CONVERSION_AUTOMATIC
} SDL_YUV_CONVERSION_MODE;
# 129 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_CreateRGBSurface
    (Uint32 flags, int width, int height, int depth,
     Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);


extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_CreateRGBSurfaceWithFormat
    (Uint32 flags, int width, int height, int depth, Uint32 format);

extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_CreateRGBSurfaceFrom(void *pixels,
                                                              int width,
                                                              int height,
                                                              int depth,
                                                              int pitch,
                                                              Uint32 Rmask,
                                                              Uint32 Gmask,
                                                              Uint32 Bmask,
                                                              Uint32 Amask);
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_CreateRGBSurfaceWithFormatFrom
    (void *pixels, int width, int height, int depth, int pitch, Uint32 format);
extern __attribute__ ((visibility("default"))) void SDL_FreeSurface(SDL_Surface * surface);
# 157 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_SetSurfacePalette(SDL_Surface * surface,
                                                  SDL_Palette * palette);
# 179 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_LockSurface(SDL_Surface * surface);

extern __attribute__ ((visibility("default"))) void SDL_UnlockSurface(SDL_Surface * surface);
# 192 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_LoadBMP_RW(SDL_RWops * src,
                                                    int freesrc);
# 215 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_SaveBMP_RW
    (SDL_Surface * surface, SDL_RWops * dst, int freedst);
# 234 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_SetSurfaceRLE(SDL_Surface * surface,
                                              int flag);
# 248 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_SetColorKey(SDL_Surface * surface,
                                            int flag, Uint32 key);
# 261 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_GetColorKey(SDL_Surface * surface,
                                            Uint32 * key);
# 276 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_SetSurfaceColorMod(SDL_Surface * surface,
                                                   Uint8 r, Uint8 g, Uint8 b);
# 292 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_GetSurfaceColorMod(SDL_Surface * surface,
                                                   Uint8 * r, Uint8 * g,
                                                   Uint8 * b);
# 306 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_SetSurfaceAlphaMod(SDL_Surface * surface,
                                                   Uint8 alpha);
# 319 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_GetSurfaceAlphaMod(SDL_Surface * surface,
                                                   Uint8 * alpha);
# 332 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_SetSurfaceBlendMode(SDL_Surface * surface,
                                                    SDL_BlendMode blendMode);
# 345 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_GetSurfaceBlendMode(SDL_Surface * surface,
                                                    SDL_BlendMode *blendMode);
# 361 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_SetClipRect(SDL_Surface * surface,
                                                 const SDL_Rect * rect);







extern __attribute__ ((visibility("default"))) void SDL_GetClipRect(SDL_Surface * surface,
                                             SDL_Rect * rect);




extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_DuplicateSurface(SDL_Surface * surface);
# 388 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_ConvertSurface
    (SDL_Surface * src, const SDL_PixelFormat * fmt, Uint32 flags);
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_ConvertSurfaceFormat
    (SDL_Surface * src, Uint32 pixel_format, Uint32 flags);






extern __attribute__ ((visibility("default"))) int SDL_ConvertPixels(int width, int height,
                                              Uint32 src_format,
                                              const void * src, int src_pitch,
                                              Uint32 dst_format,
                                              void * dst, int dst_pitch);
# 414 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_FillRect
    (SDL_Surface * dst, const SDL_Rect * rect, Uint32 color);
extern __attribute__ ((visibility("default"))) int SDL_FillRects
    (SDL_Surface * dst, const SDL_Rect * rects, int count, Uint32 color);
# 482 "/usr/local/include/SDL2/SDL_surface.h"
extern __attribute__ ((visibility("default"))) int SDL_UpperBlit
    (SDL_Surface * src, const SDL_Rect * srcrect,
     SDL_Surface * dst, SDL_Rect * dstrect);





extern __attribute__ ((visibility("default"))) int SDL_LowerBlit
    (SDL_Surface * src, SDL_Rect * srcrect,
     SDL_Surface * dst, SDL_Rect * dstrect);







extern __attribute__ ((visibility("default"))) int SDL_SoftStretch(SDL_Surface * src,
                                            const SDL_Rect * srcrect,
                                            SDL_Surface * dst,
                                            const SDL_Rect * dstrect);







extern __attribute__ ((visibility("default"))) int SDL_UpperBlitScaled
    (SDL_Surface * src, const SDL_Rect * srcrect,
    SDL_Surface * dst, SDL_Rect * dstrect);





extern __attribute__ ((visibility("default"))) int SDL_LowerBlitScaled
    (SDL_Surface * src, SDL_Rect * srcrect,
    SDL_Surface * dst, SDL_Rect * dstrect);




extern __attribute__ ((visibility("default"))) void SDL_SetYUVConversionMode(SDL_YUV_CONVERSION_MODE mode);




extern __attribute__ ((visibility("default"))) SDL_YUV_CONVERSION_MODE SDL_GetYUVConversionMode(void);




extern __attribute__ ((visibility("default"))) SDL_YUV_CONVERSION_MODE SDL_GetYUVConversionModeForResolution(int width, int height);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 543 "/usr/local/include/SDL2/SDL_surface.h" 2
# 35 "/usr/local/include/SDL2/SDL_video.h" 2

# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 37 "/usr/local/include/SDL2/SDL_video.h" 2


extern "C" {
# 53 "/usr/local/include/SDL2/SDL_video.h"
typedef struct
{
    Uint32 format;
    int w;
    int h;
    int refresh_rate;
    void *driverdata;
} SDL_DisplayMode;
# 90 "/usr/local/include/SDL2/SDL_video.h"
typedef struct SDL_Window SDL_Window;






typedef enum
{

    SDL_WINDOW_FULLSCREEN = 0x00000001,
    SDL_WINDOW_OPENGL = 0x00000002,
    SDL_WINDOW_SHOWN = 0x00000004,
    SDL_WINDOW_HIDDEN = 0x00000008,
    SDL_WINDOW_BORDERLESS = 0x00000010,
    SDL_WINDOW_RESIZABLE = 0x00000020,
    SDL_WINDOW_MINIMIZED = 0x00000040,
    SDL_WINDOW_MAXIMIZED = 0x00000080,
    SDL_WINDOW_INPUT_GRABBED = 0x00000100,
    SDL_WINDOW_INPUT_FOCUS = 0x00000200,
    SDL_WINDOW_MOUSE_FOCUS = 0x00000400,
    SDL_WINDOW_FULLSCREEN_DESKTOP = ( SDL_WINDOW_FULLSCREEN | 0x00001000 ),
    SDL_WINDOW_FOREIGN = 0x00000800,
    SDL_WINDOW_ALLOW_HIGHDPI = 0x00002000,


    SDL_WINDOW_MOUSE_CAPTURE = 0x00004000,
    SDL_WINDOW_ALWAYS_ON_TOP = 0x00008000,
    SDL_WINDOW_SKIP_TASKBAR = 0x00010000,
    SDL_WINDOW_UTILITY = 0x00020000,
    SDL_WINDOW_TOOLTIP = 0x00040000,
    SDL_WINDOW_POPUP_MENU = 0x00080000,
    SDL_WINDOW_VULKAN = 0x10000000
} SDL_WindowFlags;
# 146 "/usr/local/include/SDL2/SDL_video.h"
typedef enum
{
    SDL_WINDOWEVENT_NONE,
    SDL_WINDOWEVENT_SHOWN,
    SDL_WINDOWEVENT_HIDDEN,
    SDL_WINDOWEVENT_EXPOSED,

    SDL_WINDOWEVENT_MOVED,

    SDL_WINDOWEVENT_RESIZED,
    SDL_WINDOWEVENT_SIZE_CHANGED,


    SDL_WINDOWEVENT_MINIMIZED,
    SDL_WINDOWEVENT_MAXIMIZED,
    SDL_WINDOWEVENT_RESTORED,

    SDL_WINDOWEVENT_ENTER,
    SDL_WINDOWEVENT_LEAVE,
    SDL_WINDOWEVENT_FOCUS_GAINED,
    SDL_WINDOWEVENT_FOCUS_LOST,
    SDL_WINDOWEVENT_CLOSE,
    SDL_WINDOWEVENT_TAKE_FOCUS,
    SDL_WINDOWEVENT_HIT_TEST
} SDL_WindowEventID;




typedef void *SDL_GLContext;




typedef enum
{
    SDL_GL_RED_SIZE,
    SDL_GL_GREEN_SIZE,
    SDL_GL_BLUE_SIZE,
    SDL_GL_ALPHA_SIZE,
    SDL_GL_BUFFER_SIZE,
    SDL_GL_DOUBLEBUFFER,
    SDL_GL_DEPTH_SIZE,
    SDL_GL_STENCIL_SIZE,
    SDL_GL_ACCUM_RED_SIZE,
    SDL_GL_ACCUM_GREEN_SIZE,
    SDL_GL_ACCUM_BLUE_SIZE,
    SDL_GL_ACCUM_ALPHA_SIZE,
    SDL_GL_STEREO,
    SDL_GL_MULTISAMPLEBUFFERS,
    SDL_GL_MULTISAMPLESAMPLES,
    SDL_GL_ACCELERATED_VISUAL,
    SDL_GL_RETAINED_BACKING,
    SDL_GL_CONTEXT_MAJOR_VERSION,
    SDL_GL_CONTEXT_MINOR_VERSION,
    SDL_GL_CONTEXT_EGL,
    SDL_GL_CONTEXT_FLAGS,
    SDL_GL_CONTEXT_PROFILE_MASK,
    SDL_GL_SHARE_WITH_CURRENT_CONTEXT,
    SDL_GL_FRAMEBUFFER_SRGB_CAPABLE,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR,
    SDL_GL_CONTEXT_RESET_NOTIFICATION,
    SDL_GL_CONTEXT_NO_ERROR
} SDL_GLattr;

typedef enum
{
    SDL_GL_CONTEXT_PROFILE_CORE = 0x0001,
    SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 0x0002,
    SDL_GL_CONTEXT_PROFILE_ES = 0x0004
} SDL_GLprofile;

typedef enum
{
    SDL_GL_CONTEXT_DEBUG_FLAG = 0x0001,
    SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 0x0002,
    SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 0x0004,
    SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 0x0008
} SDL_GLcontextFlag;

typedef enum
{
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0x0000,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x0001
} SDL_GLcontextReleaseFlag;

typedef enum
{
    SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0x0000,
    SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = 0x0001
} SDL_GLContextResetNotification;
# 245 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GetNumVideoDrivers(void);
# 255 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) const char * SDL_GetVideoDriver(int index);
# 271 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_VideoInit(const char *driver_name);
# 280 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_VideoQuit(void);
# 291 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) const char * SDL_GetCurrentVideoDriver(void);






extern __attribute__ ((visibility("default"))) int SDL_GetNumVideoDisplays(void);
# 307 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) const char * SDL_GetDisplayName(int displayIndex);
# 317 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GetDisplayBounds(int displayIndex, SDL_Rect * rect);
# 329 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GetDisplayDPI(int displayIndex, float * ddpi, float * hdpi, float * vdpi);
# 348 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GetDisplayUsableBounds(int displayIndex, SDL_Rect * rect);






extern __attribute__ ((visibility("default"))) int SDL_GetNumDisplayModes(int displayIndex);
# 368 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GetDisplayMode(int displayIndex, int modeIndex,
                                               SDL_DisplayMode * mode);




extern __attribute__ ((visibility("default"))) int SDL_GetDesktopDisplayMode(int displayIndex, SDL_DisplayMode * mode);




extern __attribute__ ((visibility("default"))) int SDL_GetCurrentDisplayMode(int displayIndex, SDL_DisplayMode * mode);
# 403 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) SDL_DisplayMode * SDL_GetClosestDisplayMode(int displayIndex, const SDL_DisplayMode * mode, SDL_DisplayMode * closest);







extern __attribute__ ((visibility("default"))) int SDL_GetWindowDisplayIndex(SDL_Window * window);
# 427 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_SetWindowDisplayMode(SDL_Window * window,
                                                     const SDL_DisplayMode
                                                         * mode);
# 438 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GetWindowDisplayMode(SDL_Window * window,
                                                     SDL_DisplayMode * mode);




extern __attribute__ ((visibility("default"))) Uint32 SDL_GetWindowPixelFormat(SDL_Window * window);
# 488 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) SDL_Window * SDL_CreateWindow(const char *title,
                                                      int x, int y, int w,
                                                      int h, Uint32 flags);
# 501 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) SDL_Window * SDL_CreateWindowFrom(const void *data);




extern __attribute__ ((visibility("default"))) Uint32 SDL_GetWindowID(SDL_Window * window);




extern __attribute__ ((visibility("default"))) SDL_Window * SDL_GetWindowFromID(Uint32 id);




extern __attribute__ ((visibility("default"))) Uint32 SDL_GetWindowFlags(SDL_Window * window);






extern __attribute__ ((visibility("default"))) void SDL_SetWindowTitle(SDL_Window * window,
                                                const char *title);






extern __attribute__ ((visibility("default"))) const char * SDL_GetWindowTitle(SDL_Window * window);







extern __attribute__ ((visibility("default"))) void SDL_SetWindowIcon(SDL_Window * window,
                                               SDL_Surface * icon);
# 555 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void* SDL_SetWindowData(SDL_Window * window,
                                                const char *name,
                                                void *userdata);
# 569 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void * SDL_GetWindowData(SDL_Window * window,
                                                const char *name);
# 585 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_SetWindowPosition(SDL_Window * window,
                                                   int x, int y);
# 599 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_GetWindowPosition(SDL_Window * window,
                                                   int *x, int *y);
# 620 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_SetWindowSize(SDL_Window * window, int w,
                                               int h);
# 639 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_GetWindowSize(SDL_Window * window, int *w,
                                               int *h);
# 657 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GetWindowBordersSize(SDL_Window * window,
                                                     int *top, int *left,
                                                     int *bottom, int *right);
# 674 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_SetWindowMinimumSize(SDL_Window * window,
                                                      int min_w, int min_h);
# 687 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_GetWindowMinimumSize(SDL_Window * window,
                                                      int *w, int *h);
# 703 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_SetWindowMaximumSize(SDL_Window * window,
                                                      int max_w, int max_h);
# 716 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_GetWindowMaximumSize(SDL_Window * window,
                                                      int *w, int *h);
# 733 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_SetWindowBordered(SDL_Window * window,
                                                   SDL_bool bordered);
# 750 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_SetWindowResizable(SDL_Window * window,
                                                    SDL_bool resizable);






extern __attribute__ ((visibility("default"))) void SDL_ShowWindow(SDL_Window * window);






extern __attribute__ ((visibility("default"))) void SDL_HideWindow(SDL_Window * window);




extern __attribute__ ((visibility("default"))) void SDL_RaiseWindow(SDL_Window * window);






extern __attribute__ ((visibility("default"))) void SDL_MaximizeWindow(SDL_Window * window);






extern __attribute__ ((visibility("default"))) void SDL_MinimizeWindow(SDL_Window * window);







extern __attribute__ ((visibility("default"))) void SDL_RestoreWindow(SDL_Window * window);
# 802 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_SetWindowFullscreen(SDL_Window * window,
                                                    Uint32 flags);
# 818 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_GetWindowSurface(SDL_Window * window);
# 828 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_UpdateWindowSurface(SDL_Window * window);
# 838 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_UpdateWindowSurfaceRects(SDL_Window * window,
                                                         const SDL_Rect * rects,
                                                         int numrects);
# 853 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_SetWindowGrab(SDL_Window * window,
                                               SDL_bool grabbed);
# 863 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_GetWindowGrab(SDL_Window * window);
# 872 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) SDL_Window * SDL_GetGrabbedWindow(void);
# 882 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_SetWindowBrightness(SDL_Window * window, float brightness);
# 891 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) float SDL_GetWindowBrightness(SDL_Window * window);
# 904 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_SetWindowOpacity(SDL_Window * window, float opacity);
# 919 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GetWindowOpacity(SDL_Window * window, float * out_opacity);
# 929 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_SetWindowModalFor(SDL_Window * modal_window, SDL_Window * parent_window);
# 943 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_SetWindowInputFocus(SDL_Window * window);
# 963 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_SetWindowGammaRamp(SDL_Window * window,
                                                   const Uint16 * red,
                                                   const Uint16 * green,
                                                   const Uint16 * blue);
# 983 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GetWindowGammaRamp(SDL_Window * window,
                                                   Uint16 * red,
                                                   Uint16 * green,
                                                   Uint16 * blue);






typedef enum
{
    SDL_HITTEST_NORMAL,
    SDL_HITTEST_DRAGGABLE,
    SDL_HITTEST_RESIZE_TOPLEFT,
    SDL_HITTEST_RESIZE_TOP,
    SDL_HITTEST_RESIZE_TOPRIGHT,
    SDL_HITTEST_RESIZE_RIGHT,
    SDL_HITTEST_RESIZE_BOTTOMRIGHT,
    SDL_HITTEST_RESIZE_BOTTOM,
    SDL_HITTEST_RESIZE_BOTTOMLEFT,
    SDL_HITTEST_RESIZE_LEFT
} SDL_HitTestResult;






typedef SDL_HitTestResult ( *SDL_HitTest)(SDL_Window *win,
                                                 const SDL_Point *area,
                                                 void *data);
# 1053 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_SetWindowHitTest(SDL_Window * window,
                                                 SDL_HitTest callback,
                                                 void *callback_data);




extern __attribute__ ((visibility("default"))) void SDL_DestroyWindow(SDL_Window * window);
# 1069 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_IsScreenSaverEnabled(void);







extern __attribute__ ((visibility("default"))) void SDL_EnableScreenSaver(void);







extern __attribute__ ((visibility("default"))) void SDL_DisableScreenSaver(void);
# 1111 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GL_LoadLibrary(const char *path);




extern __attribute__ ((visibility("default"))) void * SDL_GL_GetProcAddress(const char *proc);






extern __attribute__ ((visibility("default"))) void SDL_GL_UnloadLibrary(void);





extern __attribute__ ((visibility("default"))) SDL_bool SDL_GL_ExtensionSupported(const char
                                                           *extension);




extern __attribute__ ((visibility("default"))) void SDL_GL_ResetAttributes(void);






extern __attribute__ ((visibility("default"))) int SDL_GL_SetAttribute(SDL_GLattr attr, int value);







extern __attribute__ ((visibility("default"))) int SDL_GL_GetAttribute(SDL_GLattr attr, int *value);







extern __attribute__ ((visibility("default"))) SDL_GLContext SDL_GL_CreateContext(SDL_Window *
                                                           window);






extern __attribute__ ((visibility("default"))) int SDL_GL_MakeCurrent(SDL_Window * window,
                                               SDL_GLContext context);




extern __attribute__ ((visibility("default"))) SDL_Window* SDL_GL_GetCurrentWindow(void);




extern __attribute__ ((visibility("default"))) SDL_GLContext SDL_GL_GetCurrentContext(void);
# 1195 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) void SDL_GL_GetDrawableSize(SDL_Window * window, int *w,
                                                    int *h);
# 1210 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GL_SetSwapInterval(int interval);
# 1223 "/usr/local/include/SDL2/SDL_video.h"
extern __attribute__ ((visibility("default"))) int SDL_GL_GetSwapInterval(void);





extern __attribute__ ((visibility("default"))) void SDL_GL_SwapWindow(SDL_Window * window);






extern __attribute__ ((visibility("default"))) void SDL_GL_DeleteContext(SDL_GLContext context);






}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 1246 "/usr/local/include/SDL2/SDL_video.h" 2
# 34 "/usr/local/include/SDL2/SDL_events.h" 2
# 1 "/usr/local/include/SDL2/SDL_keyboard.h" 1
# 33 "/usr/local/include/SDL2/SDL_keyboard.h"
# 1 "/usr/local/include/SDL2/SDL_keycode.h" 1
# 32 "/usr/local/include/SDL2/SDL_keycode.h"
# 1 "/usr/local/include/SDL2/SDL_scancode.h" 1
# 43 "/usr/local/include/SDL2/SDL_scancode.h"
typedef enum
{
    SDL_SCANCODE_UNKNOWN = 0,
# 54 "/usr/local/include/SDL2/SDL_scancode.h"
    SDL_SCANCODE_A = 4,
    SDL_SCANCODE_B = 5,
    SDL_SCANCODE_C = 6,
    SDL_SCANCODE_D = 7,
    SDL_SCANCODE_E = 8,
    SDL_SCANCODE_F = 9,
    SDL_SCANCODE_G = 10,
    SDL_SCANCODE_H = 11,
    SDL_SCANCODE_I = 12,
    SDL_SCANCODE_J = 13,
    SDL_SCANCODE_K = 14,
    SDL_SCANCODE_L = 15,
    SDL_SCANCODE_M = 16,
    SDL_SCANCODE_N = 17,
    SDL_SCANCODE_O = 18,
    SDL_SCANCODE_P = 19,
    SDL_SCANCODE_Q = 20,
    SDL_SCANCODE_R = 21,
    SDL_SCANCODE_S = 22,
    SDL_SCANCODE_T = 23,
    SDL_SCANCODE_U = 24,
    SDL_SCANCODE_V = 25,
    SDL_SCANCODE_W = 26,
    SDL_SCANCODE_X = 27,
    SDL_SCANCODE_Y = 28,
    SDL_SCANCODE_Z = 29,

    SDL_SCANCODE_1 = 30,
    SDL_SCANCODE_2 = 31,
    SDL_SCANCODE_3 = 32,
    SDL_SCANCODE_4 = 33,
    SDL_SCANCODE_5 = 34,
    SDL_SCANCODE_6 = 35,
    SDL_SCANCODE_7 = 36,
    SDL_SCANCODE_8 = 37,
    SDL_SCANCODE_9 = 38,
    SDL_SCANCODE_0 = 39,

    SDL_SCANCODE_RETURN = 40,
    SDL_SCANCODE_ESCAPE = 41,
    SDL_SCANCODE_BACKSPACE = 42,
    SDL_SCANCODE_TAB = 43,
    SDL_SCANCODE_SPACE = 44,

    SDL_SCANCODE_MINUS = 45,
    SDL_SCANCODE_EQUALS = 46,
    SDL_SCANCODE_LEFTBRACKET = 47,
    SDL_SCANCODE_RIGHTBRACKET = 48,
    SDL_SCANCODE_BACKSLASH = 49,
# 116 "/usr/local/include/SDL2/SDL_scancode.h"
    SDL_SCANCODE_NONUSHASH = 50,
# 128 "/usr/local/include/SDL2/SDL_scancode.h"
    SDL_SCANCODE_SEMICOLON = 51,
    SDL_SCANCODE_APOSTROPHE = 52,
    SDL_SCANCODE_GRAVE = 53,
# 147 "/usr/local/include/SDL2/SDL_scancode.h"
    SDL_SCANCODE_COMMA = 54,
    SDL_SCANCODE_PERIOD = 55,
    SDL_SCANCODE_SLASH = 56,

    SDL_SCANCODE_CAPSLOCK = 57,

    SDL_SCANCODE_F1 = 58,
    SDL_SCANCODE_F2 = 59,
    SDL_SCANCODE_F3 = 60,
    SDL_SCANCODE_F4 = 61,
    SDL_SCANCODE_F5 = 62,
    SDL_SCANCODE_F6 = 63,
    SDL_SCANCODE_F7 = 64,
    SDL_SCANCODE_F8 = 65,
    SDL_SCANCODE_F9 = 66,
    SDL_SCANCODE_F10 = 67,
    SDL_SCANCODE_F11 = 68,
    SDL_SCANCODE_F12 = 69,

    SDL_SCANCODE_PRINTSCREEN = 70,
    SDL_SCANCODE_SCROLLLOCK = 71,
    SDL_SCANCODE_PAUSE = 72,
    SDL_SCANCODE_INSERT = 73,

    SDL_SCANCODE_HOME = 74,
    SDL_SCANCODE_PAGEUP = 75,
    SDL_SCANCODE_DELETE = 76,
    SDL_SCANCODE_END = 77,
    SDL_SCANCODE_PAGEDOWN = 78,
    SDL_SCANCODE_RIGHT = 79,
    SDL_SCANCODE_LEFT = 80,
    SDL_SCANCODE_DOWN = 81,
    SDL_SCANCODE_UP = 82,

    SDL_SCANCODE_NUMLOCKCLEAR = 83,

    SDL_SCANCODE_KP_DIVIDE = 84,
    SDL_SCANCODE_KP_MULTIPLY = 85,
    SDL_SCANCODE_KP_MINUS = 86,
    SDL_SCANCODE_KP_PLUS = 87,
    SDL_SCANCODE_KP_ENTER = 88,
    SDL_SCANCODE_KP_1 = 89,
    SDL_SCANCODE_KP_2 = 90,
    SDL_SCANCODE_KP_3 = 91,
    SDL_SCANCODE_KP_4 = 92,
    SDL_SCANCODE_KP_5 = 93,
    SDL_SCANCODE_KP_6 = 94,
    SDL_SCANCODE_KP_7 = 95,
    SDL_SCANCODE_KP_8 = 96,
    SDL_SCANCODE_KP_9 = 97,
    SDL_SCANCODE_KP_0 = 98,
    SDL_SCANCODE_KP_PERIOD = 99,

    SDL_SCANCODE_NONUSBACKSLASH = 100,
# 210 "/usr/local/include/SDL2/SDL_scancode.h"
    SDL_SCANCODE_APPLICATION = 101,
    SDL_SCANCODE_POWER = 102,


    SDL_SCANCODE_KP_EQUALS = 103,
    SDL_SCANCODE_F13 = 104,
    SDL_SCANCODE_F14 = 105,
    SDL_SCANCODE_F15 = 106,
    SDL_SCANCODE_F16 = 107,
    SDL_SCANCODE_F17 = 108,
    SDL_SCANCODE_F18 = 109,
    SDL_SCANCODE_F19 = 110,
    SDL_SCANCODE_F20 = 111,
    SDL_SCANCODE_F21 = 112,
    SDL_SCANCODE_F22 = 113,
    SDL_SCANCODE_F23 = 114,
    SDL_SCANCODE_F24 = 115,
    SDL_SCANCODE_EXECUTE = 116,
    SDL_SCANCODE_HELP = 117,
    SDL_SCANCODE_MENU = 118,
    SDL_SCANCODE_SELECT = 119,
    SDL_SCANCODE_STOP = 120,
    SDL_SCANCODE_AGAIN = 121,
    SDL_SCANCODE_UNDO = 122,
    SDL_SCANCODE_CUT = 123,
    SDL_SCANCODE_COPY = 124,
    SDL_SCANCODE_PASTE = 125,
    SDL_SCANCODE_FIND = 126,
    SDL_SCANCODE_MUTE = 127,
    SDL_SCANCODE_VOLUMEUP = 128,
    SDL_SCANCODE_VOLUMEDOWN = 129,




    SDL_SCANCODE_KP_COMMA = 133,
    SDL_SCANCODE_KP_EQUALSAS400 = 134,

    SDL_SCANCODE_INTERNATIONAL1 = 135,

    SDL_SCANCODE_INTERNATIONAL2 = 136,
    SDL_SCANCODE_INTERNATIONAL3 = 137,
    SDL_SCANCODE_INTERNATIONAL4 = 138,
    SDL_SCANCODE_INTERNATIONAL5 = 139,
    SDL_SCANCODE_INTERNATIONAL6 = 140,
    SDL_SCANCODE_INTERNATIONAL7 = 141,
    SDL_SCANCODE_INTERNATIONAL8 = 142,
    SDL_SCANCODE_INTERNATIONAL9 = 143,
    SDL_SCANCODE_LANG1 = 144,
    SDL_SCANCODE_LANG2 = 145,
    SDL_SCANCODE_LANG3 = 146,
    SDL_SCANCODE_LANG4 = 147,
    SDL_SCANCODE_LANG5 = 148,
    SDL_SCANCODE_LANG6 = 149,
    SDL_SCANCODE_LANG7 = 150,
    SDL_SCANCODE_LANG8 = 151,
    SDL_SCANCODE_LANG9 = 152,

    SDL_SCANCODE_ALTERASE = 153,
    SDL_SCANCODE_SYSREQ = 154,
    SDL_SCANCODE_CANCEL = 155,
    SDL_SCANCODE_CLEAR = 156,
    SDL_SCANCODE_PRIOR = 157,
    SDL_SCANCODE_RETURN2 = 158,
    SDL_SCANCODE_SEPARATOR = 159,
    SDL_SCANCODE_OUT = 160,
    SDL_SCANCODE_OPER = 161,
    SDL_SCANCODE_CLEARAGAIN = 162,
    SDL_SCANCODE_CRSEL = 163,
    SDL_SCANCODE_EXSEL = 164,

    SDL_SCANCODE_KP_00 = 176,
    SDL_SCANCODE_KP_000 = 177,
    SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
    SDL_SCANCODE_DECIMALSEPARATOR = 179,
    SDL_SCANCODE_CURRENCYUNIT = 180,
    SDL_SCANCODE_CURRENCYSUBUNIT = 181,
    SDL_SCANCODE_KP_LEFTPAREN = 182,
    SDL_SCANCODE_KP_RIGHTPAREN = 183,
    SDL_SCANCODE_KP_LEFTBRACE = 184,
    SDL_SCANCODE_KP_RIGHTBRACE = 185,
    SDL_SCANCODE_KP_TAB = 186,
    SDL_SCANCODE_KP_BACKSPACE = 187,
    SDL_SCANCODE_KP_A = 188,
    SDL_SCANCODE_KP_B = 189,
    SDL_SCANCODE_KP_C = 190,
    SDL_SCANCODE_KP_D = 191,
    SDL_SCANCODE_KP_E = 192,
    SDL_SCANCODE_KP_F = 193,
    SDL_SCANCODE_KP_XOR = 194,
    SDL_SCANCODE_KP_POWER = 195,
    SDL_SCANCODE_KP_PERCENT = 196,
    SDL_SCANCODE_KP_LESS = 197,
    SDL_SCANCODE_KP_GREATER = 198,
    SDL_SCANCODE_KP_AMPERSAND = 199,
    SDL_SCANCODE_KP_DBLAMPERSAND = 200,
    SDL_SCANCODE_KP_VERTICALBAR = 201,
    SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
    SDL_SCANCODE_KP_COLON = 203,
    SDL_SCANCODE_KP_HASH = 204,
    SDL_SCANCODE_KP_SPACE = 205,
    SDL_SCANCODE_KP_AT = 206,
    SDL_SCANCODE_KP_EXCLAM = 207,
    SDL_SCANCODE_KP_MEMSTORE = 208,
    SDL_SCANCODE_KP_MEMRECALL = 209,
    SDL_SCANCODE_KP_MEMCLEAR = 210,
    SDL_SCANCODE_KP_MEMADD = 211,
    SDL_SCANCODE_KP_MEMSUBTRACT = 212,
    SDL_SCANCODE_KP_MEMMULTIPLY = 213,
    SDL_SCANCODE_KP_MEMDIVIDE = 214,
    SDL_SCANCODE_KP_PLUSMINUS = 215,
    SDL_SCANCODE_KP_CLEAR = 216,
    SDL_SCANCODE_KP_CLEARENTRY = 217,
    SDL_SCANCODE_KP_BINARY = 218,
    SDL_SCANCODE_KP_OCTAL = 219,
    SDL_SCANCODE_KP_DECIMAL = 220,
    SDL_SCANCODE_KP_HEXADECIMAL = 221,

    SDL_SCANCODE_LCTRL = 224,
    SDL_SCANCODE_LSHIFT = 225,
    SDL_SCANCODE_LALT = 226,
    SDL_SCANCODE_LGUI = 227,
    SDL_SCANCODE_RCTRL = 228,
    SDL_SCANCODE_RSHIFT = 229,
    SDL_SCANCODE_RALT = 230,
    SDL_SCANCODE_RGUI = 231,

    SDL_SCANCODE_MODE = 257,
# 351 "/usr/local/include/SDL2/SDL_scancode.h"
    SDL_SCANCODE_AUDIONEXT = 258,
    SDL_SCANCODE_AUDIOPREV = 259,
    SDL_SCANCODE_AUDIOSTOP = 260,
    SDL_SCANCODE_AUDIOPLAY = 261,
    SDL_SCANCODE_AUDIOMUTE = 262,
    SDL_SCANCODE_MEDIASELECT = 263,
    SDL_SCANCODE_WWW = 264,
    SDL_SCANCODE_MAIL = 265,
    SDL_SCANCODE_CALCULATOR = 266,
    SDL_SCANCODE_COMPUTER = 267,
    SDL_SCANCODE_AC_SEARCH = 268,
    SDL_SCANCODE_AC_HOME = 269,
    SDL_SCANCODE_AC_BACK = 270,
    SDL_SCANCODE_AC_FORWARD = 271,
    SDL_SCANCODE_AC_STOP = 272,
    SDL_SCANCODE_AC_REFRESH = 273,
    SDL_SCANCODE_AC_BOOKMARKS = 274,
# 378 "/usr/local/include/SDL2/SDL_scancode.h"
    SDL_SCANCODE_BRIGHTNESSDOWN = 275,
    SDL_SCANCODE_BRIGHTNESSUP = 276,
    SDL_SCANCODE_DISPLAYSWITCH = 277,

    SDL_SCANCODE_KBDILLUMTOGGLE = 278,
    SDL_SCANCODE_KBDILLUMDOWN = 279,
    SDL_SCANCODE_KBDILLUMUP = 280,
    SDL_SCANCODE_EJECT = 281,
    SDL_SCANCODE_SLEEP = 282,

    SDL_SCANCODE_APP1 = 283,
    SDL_SCANCODE_APP2 = 284,
# 400 "/usr/local/include/SDL2/SDL_scancode.h"
    SDL_SCANCODE_AUDIOREWIND = 285,
    SDL_SCANCODE_AUDIOFASTFORWARD = 286,





    SDL_NUM_SCANCODES = 512

} SDL_Scancode;
# 33 "/usr/local/include/SDL2/SDL_keycode.h" 2
# 45 "/usr/local/include/SDL2/SDL_keycode.h"
typedef Sint32 SDL_Keycode;




enum
{
    SDLK_UNKNOWN = 0,

    SDLK_RETURN = '\r',
    SDLK_ESCAPE = '\033',
    SDLK_BACKSPACE = '\b',
    SDLK_TAB = '\t',
    SDLK_SPACE = ' ',
    SDLK_EXCLAIM = '!',
    SDLK_QUOTEDBL = '"',
    SDLK_HASH = '#',
    SDLK_PERCENT = '%',
    SDLK_DOLLAR = '$',
    SDLK_AMPERSAND = '&',
    SDLK_QUOTE = '\'',
    SDLK_LEFTPAREN = '(',
    SDLK_RIGHTPAREN = ')',
    SDLK_ASTERISK = '*',
    SDLK_PLUS = '+',
    SDLK_COMMA = ',',
    SDLK_MINUS = '-',
    SDLK_PERIOD = '.',
    SDLK_SLASH = '/',
    SDLK_0 = '0',
    SDLK_1 = '1',
    SDLK_2 = '2',
    SDLK_3 = '3',
    SDLK_4 = '4',
    SDLK_5 = '5',
    SDLK_6 = '6',
    SDLK_7 = '7',
    SDLK_8 = '8',
    SDLK_9 = '9',
    SDLK_COLON = ':',
    SDLK_SEMICOLON = ';',
    SDLK_LESS = '<',
    SDLK_EQUALS = '=',
    SDLK_GREATER = '>',
    SDLK_QUESTION = '?',
    SDLK_AT = '@',



    SDLK_LEFTBRACKET = '[',
    SDLK_BACKSLASH = '\\',
    SDLK_RIGHTBRACKET = ']',
    SDLK_CARET = '^',
    SDLK_UNDERSCORE = '_',
    SDLK_BACKQUOTE = '`',
    SDLK_a = 'a',
    SDLK_b = 'b',
    SDLK_c = 'c',
    SDLK_d = 'd',
    SDLK_e = 'e',
    SDLK_f = 'f',
    SDLK_g = 'g',
    SDLK_h = 'h',
    SDLK_i = 'i',
    SDLK_j = 'j',
    SDLK_k = 'k',
    SDLK_l = 'l',
    SDLK_m = 'm',
    SDLK_n = 'n',
    SDLK_o = 'o',
    SDLK_p = 'p',
    SDLK_q = 'q',
    SDLK_r = 'r',
    SDLK_s = 's',
    SDLK_t = 't',
    SDLK_u = 'u',
    SDLK_v = 'v',
    SDLK_w = 'w',
    SDLK_x = 'x',
    SDLK_y = 'y',
    SDLK_z = 'z',

    SDLK_CAPSLOCK = (SDL_SCANCODE_CAPSLOCK | (1<<30)),

    SDLK_F1 = (SDL_SCANCODE_F1 | (1<<30)),
    SDLK_F2 = (SDL_SCANCODE_F2 | (1<<30)),
    SDLK_F3 = (SDL_SCANCODE_F3 | (1<<30)),
    SDLK_F4 = (SDL_SCANCODE_F4 | (1<<30)),
    SDLK_F5 = (SDL_SCANCODE_F5 | (1<<30)),
    SDLK_F6 = (SDL_SCANCODE_F6 | (1<<30)),
    SDLK_F7 = (SDL_SCANCODE_F7 | (1<<30)),
    SDLK_F8 = (SDL_SCANCODE_F8 | (1<<30)),
    SDLK_F9 = (SDL_SCANCODE_F9 | (1<<30)),
    SDLK_F10 = (SDL_SCANCODE_F10 | (1<<30)),
    SDLK_F11 = (SDL_SCANCODE_F11 | (1<<30)),
    SDLK_F12 = (SDL_SCANCODE_F12 | (1<<30)),

    SDLK_PRINTSCREEN = (SDL_SCANCODE_PRINTSCREEN | (1<<30)),
    SDLK_SCROLLLOCK = (SDL_SCANCODE_SCROLLLOCK | (1<<30)),
    SDLK_PAUSE = (SDL_SCANCODE_PAUSE | (1<<30)),
    SDLK_INSERT = (SDL_SCANCODE_INSERT | (1<<30)),
    SDLK_HOME = (SDL_SCANCODE_HOME | (1<<30)),
    SDLK_PAGEUP = (SDL_SCANCODE_PAGEUP | (1<<30)),
    SDLK_DELETE = '\177',
    SDLK_END = (SDL_SCANCODE_END | (1<<30)),
    SDLK_PAGEDOWN = (SDL_SCANCODE_PAGEDOWN | (1<<30)),
    SDLK_RIGHT = (SDL_SCANCODE_RIGHT | (1<<30)),
    SDLK_LEFT = (SDL_SCANCODE_LEFT | (1<<30)),
    SDLK_DOWN = (SDL_SCANCODE_DOWN | (1<<30)),
    SDLK_UP = (SDL_SCANCODE_UP | (1<<30)),

    SDLK_NUMLOCKCLEAR = (SDL_SCANCODE_NUMLOCKCLEAR | (1<<30)),
    SDLK_KP_DIVIDE = (SDL_SCANCODE_KP_DIVIDE | (1<<30)),
    SDLK_KP_MULTIPLY = (SDL_SCANCODE_KP_MULTIPLY | (1<<30)),
    SDLK_KP_MINUS = (SDL_SCANCODE_KP_MINUS | (1<<30)),
    SDLK_KP_PLUS = (SDL_SCANCODE_KP_PLUS | (1<<30)),
    SDLK_KP_ENTER = (SDL_SCANCODE_KP_ENTER | (1<<30)),
    SDLK_KP_1 = (SDL_SCANCODE_KP_1 | (1<<30)),
    SDLK_KP_2 = (SDL_SCANCODE_KP_2 | (1<<30)),
    SDLK_KP_3 = (SDL_SCANCODE_KP_3 | (1<<30)),
    SDLK_KP_4 = (SDL_SCANCODE_KP_4 | (1<<30)),
    SDLK_KP_5 = (SDL_SCANCODE_KP_5 | (1<<30)),
    SDLK_KP_6 = (SDL_SCANCODE_KP_6 | (1<<30)),
    SDLK_KP_7 = (SDL_SCANCODE_KP_7 | (1<<30)),
    SDLK_KP_8 = (SDL_SCANCODE_KP_8 | (1<<30)),
    SDLK_KP_9 = (SDL_SCANCODE_KP_9 | (1<<30)),
    SDLK_KP_0 = (SDL_SCANCODE_KP_0 | (1<<30)),
    SDLK_KP_PERIOD = (SDL_SCANCODE_KP_PERIOD | (1<<30)),

    SDLK_APPLICATION = (SDL_SCANCODE_APPLICATION | (1<<30)),
    SDLK_POWER = (SDL_SCANCODE_POWER | (1<<30)),
    SDLK_KP_EQUALS = (SDL_SCANCODE_KP_EQUALS | (1<<30)),
    SDLK_F13 = (SDL_SCANCODE_F13 | (1<<30)),
    SDLK_F14 = (SDL_SCANCODE_F14 | (1<<30)),
    SDLK_F15 = (SDL_SCANCODE_F15 | (1<<30)),
    SDLK_F16 = (SDL_SCANCODE_F16 | (1<<30)),
    SDLK_F17 = (SDL_SCANCODE_F17 | (1<<30)),
    SDLK_F18 = (SDL_SCANCODE_F18 | (1<<30)),
    SDLK_F19 = (SDL_SCANCODE_F19 | (1<<30)),
    SDLK_F20 = (SDL_SCANCODE_F20 | (1<<30)),
    SDLK_F21 = (SDL_SCANCODE_F21 | (1<<30)),
    SDLK_F22 = (SDL_SCANCODE_F22 | (1<<30)),
    SDLK_F23 = (SDL_SCANCODE_F23 | (1<<30)),
    SDLK_F24 = (SDL_SCANCODE_F24 | (1<<30)),
    SDLK_EXECUTE = (SDL_SCANCODE_EXECUTE | (1<<30)),
    SDLK_HELP = (SDL_SCANCODE_HELP | (1<<30)),
    SDLK_MENU = (SDL_SCANCODE_MENU | (1<<30)),
    SDLK_SELECT = (SDL_SCANCODE_SELECT | (1<<30)),
    SDLK_STOP = (SDL_SCANCODE_STOP | (1<<30)),
    SDLK_AGAIN = (SDL_SCANCODE_AGAIN | (1<<30)),
    SDLK_UNDO = (SDL_SCANCODE_UNDO | (1<<30)),
    SDLK_CUT = (SDL_SCANCODE_CUT | (1<<30)),
    SDLK_COPY = (SDL_SCANCODE_COPY | (1<<30)),
    SDLK_PASTE = (SDL_SCANCODE_PASTE | (1<<30)),
    SDLK_FIND = (SDL_SCANCODE_FIND | (1<<30)),
    SDLK_MUTE = (SDL_SCANCODE_MUTE | (1<<30)),
    SDLK_VOLUMEUP = (SDL_SCANCODE_VOLUMEUP | (1<<30)),
    SDLK_VOLUMEDOWN = (SDL_SCANCODE_VOLUMEDOWN | (1<<30)),
    SDLK_KP_COMMA = (SDL_SCANCODE_KP_COMMA | (1<<30)),
    SDLK_KP_EQUALSAS400 =
        (SDL_SCANCODE_KP_EQUALSAS400 | (1<<30)),

    SDLK_ALTERASE = (SDL_SCANCODE_ALTERASE | (1<<30)),
    SDLK_SYSREQ = (SDL_SCANCODE_SYSREQ | (1<<30)),
    SDLK_CANCEL = (SDL_SCANCODE_CANCEL | (1<<30)),
    SDLK_CLEAR = (SDL_SCANCODE_CLEAR | (1<<30)),
    SDLK_PRIOR = (SDL_SCANCODE_PRIOR | (1<<30)),
    SDLK_RETURN2 = (SDL_SCANCODE_RETURN2 | (1<<30)),
    SDLK_SEPARATOR = (SDL_SCANCODE_SEPARATOR | (1<<30)),
    SDLK_OUT = (SDL_SCANCODE_OUT | (1<<30)),
    SDLK_OPER = (SDL_SCANCODE_OPER | (1<<30)),
    SDLK_CLEARAGAIN = (SDL_SCANCODE_CLEARAGAIN | (1<<30)),
    SDLK_CRSEL = (SDL_SCANCODE_CRSEL | (1<<30)),
    SDLK_EXSEL = (SDL_SCANCODE_EXSEL | (1<<30)),

    SDLK_KP_00 = (SDL_SCANCODE_KP_00 | (1<<30)),
    SDLK_KP_000 = (SDL_SCANCODE_KP_000 | (1<<30)),
    SDLK_THOUSANDSSEPARATOR =
        (SDL_SCANCODE_THOUSANDSSEPARATOR | (1<<30)),
    SDLK_DECIMALSEPARATOR =
        (SDL_SCANCODE_DECIMALSEPARATOR | (1<<30)),
    SDLK_CURRENCYUNIT = (SDL_SCANCODE_CURRENCYUNIT | (1<<30)),
    SDLK_CURRENCYSUBUNIT =
        (SDL_SCANCODE_CURRENCYSUBUNIT | (1<<30)),
    SDLK_KP_LEFTPAREN = (SDL_SCANCODE_KP_LEFTPAREN | (1<<30)),
    SDLK_KP_RIGHTPAREN = (SDL_SCANCODE_KP_RIGHTPAREN | (1<<30)),
    SDLK_KP_LEFTBRACE = (SDL_SCANCODE_KP_LEFTBRACE | (1<<30)),
    SDLK_KP_RIGHTBRACE = (SDL_SCANCODE_KP_RIGHTBRACE | (1<<30)),
    SDLK_KP_TAB = (SDL_SCANCODE_KP_TAB | (1<<30)),
    SDLK_KP_BACKSPACE = (SDL_SCANCODE_KP_BACKSPACE | (1<<30)),
    SDLK_KP_A = (SDL_SCANCODE_KP_A | (1<<30)),
    SDLK_KP_B = (SDL_SCANCODE_KP_B | (1<<30)),
    SDLK_KP_C = (SDL_SCANCODE_KP_C | (1<<30)),
    SDLK_KP_D = (SDL_SCANCODE_KP_D | (1<<30)),
    SDLK_KP_E = (SDL_SCANCODE_KP_E | (1<<30)),
    SDLK_KP_F = (SDL_SCANCODE_KP_F | (1<<30)),
    SDLK_KP_XOR = (SDL_SCANCODE_KP_XOR | (1<<30)),
    SDLK_KP_POWER = (SDL_SCANCODE_KP_POWER | (1<<30)),
    SDLK_KP_PERCENT = (SDL_SCANCODE_KP_PERCENT | (1<<30)),
    SDLK_KP_LESS = (SDL_SCANCODE_KP_LESS | (1<<30)),
    SDLK_KP_GREATER = (SDL_SCANCODE_KP_GREATER | (1<<30)),
    SDLK_KP_AMPERSAND = (SDL_SCANCODE_KP_AMPERSAND | (1<<30)),
    SDLK_KP_DBLAMPERSAND =
        (SDL_SCANCODE_KP_DBLAMPERSAND | (1<<30)),
    SDLK_KP_VERTICALBAR =
        (SDL_SCANCODE_KP_VERTICALBAR | (1<<30)),
    SDLK_KP_DBLVERTICALBAR =
        (SDL_SCANCODE_KP_DBLVERTICALBAR | (1<<30)),
    SDLK_KP_COLON = (SDL_SCANCODE_KP_COLON | (1<<30)),
    SDLK_KP_HASH = (SDL_SCANCODE_KP_HASH | (1<<30)),
    SDLK_KP_SPACE = (SDL_SCANCODE_KP_SPACE | (1<<30)),
    SDLK_KP_AT = (SDL_SCANCODE_KP_AT | (1<<30)),
    SDLK_KP_EXCLAM = (SDL_SCANCODE_KP_EXCLAM | (1<<30)),
    SDLK_KP_MEMSTORE = (SDL_SCANCODE_KP_MEMSTORE | (1<<30)),
    SDLK_KP_MEMRECALL = (SDL_SCANCODE_KP_MEMRECALL | (1<<30)),
    SDLK_KP_MEMCLEAR = (SDL_SCANCODE_KP_MEMCLEAR | (1<<30)),
    SDLK_KP_MEMADD = (SDL_SCANCODE_KP_MEMADD | (1<<30)),
    SDLK_KP_MEMSUBTRACT =
        (SDL_SCANCODE_KP_MEMSUBTRACT | (1<<30)),
    SDLK_KP_MEMMULTIPLY =
        (SDL_SCANCODE_KP_MEMMULTIPLY | (1<<30)),
    SDLK_KP_MEMDIVIDE = (SDL_SCANCODE_KP_MEMDIVIDE | (1<<30)),
    SDLK_KP_PLUSMINUS = (SDL_SCANCODE_KP_PLUSMINUS | (1<<30)),
    SDLK_KP_CLEAR = (SDL_SCANCODE_KP_CLEAR | (1<<30)),
    SDLK_KP_CLEARENTRY = (SDL_SCANCODE_KP_CLEARENTRY | (1<<30)),
    SDLK_KP_BINARY = (SDL_SCANCODE_KP_BINARY | (1<<30)),
    SDLK_KP_OCTAL = (SDL_SCANCODE_KP_OCTAL | (1<<30)),
    SDLK_KP_DECIMAL = (SDL_SCANCODE_KP_DECIMAL | (1<<30)),
    SDLK_KP_HEXADECIMAL =
        (SDL_SCANCODE_KP_HEXADECIMAL | (1<<30)),

    SDLK_LCTRL = (SDL_SCANCODE_LCTRL | (1<<30)),
    SDLK_LSHIFT = (SDL_SCANCODE_LSHIFT | (1<<30)),
    SDLK_LALT = (SDL_SCANCODE_LALT | (1<<30)),
    SDLK_LGUI = (SDL_SCANCODE_LGUI | (1<<30)),
    SDLK_RCTRL = (SDL_SCANCODE_RCTRL | (1<<30)),
    SDLK_RSHIFT = (SDL_SCANCODE_RSHIFT | (1<<30)),
    SDLK_RALT = (SDL_SCANCODE_RALT | (1<<30)),
    SDLK_RGUI = (SDL_SCANCODE_RGUI | (1<<30)),

    SDLK_MODE = (SDL_SCANCODE_MODE | (1<<30)),

    SDLK_AUDIONEXT = (SDL_SCANCODE_AUDIONEXT | (1<<30)),
    SDLK_AUDIOPREV = (SDL_SCANCODE_AUDIOPREV | (1<<30)),
    SDLK_AUDIOSTOP = (SDL_SCANCODE_AUDIOSTOP | (1<<30)),
    SDLK_AUDIOPLAY = (SDL_SCANCODE_AUDIOPLAY | (1<<30)),
    SDLK_AUDIOMUTE = (SDL_SCANCODE_AUDIOMUTE | (1<<30)),
    SDLK_MEDIASELECT = (SDL_SCANCODE_MEDIASELECT | (1<<30)),
    SDLK_WWW = (SDL_SCANCODE_WWW | (1<<30)),
    SDLK_MAIL = (SDL_SCANCODE_MAIL | (1<<30)),
    SDLK_CALCULATOR = (SDL_SCANCODE_CALCULATOR | (1<<30)),
    SDLK_COMPUTER = (SDL_SCANCODE_COMPUTER | (1<<30)),
    SDLK_AC_SEARCH = (SDL_SCANCODE_AC_SEARCH | (1<<30)),
    SDLK_AC_HOME = (SDL_SCANCODE_AC_HOME | (1<<30)),
    SDLK_AC_BACK = (SDL_SCANCODE_AC_BACK | (1<<30)),
    SDLK_AC_FORWARD = (SDL_SCANCODE_AC_FORWARD | (1<<30)),
    SDLK_AC_STOP = (SDL_SCANCODE_AC_STOP | (1<<30)),
    SDLK_AC_REFRESH = (SDL_SCANCODE_AC_REFRESH | (1<<30)),
    SDLK_AC_BOOKMARKS = (SDL_SCANCODE_AC_BOOKMARKS | (1<<30)),

    SDLK_BRIGHTNESSDOWN =
        (SDL_SCANCODE_BRIGHTNESSDOWN | (1<<30)),
    SDLK_BRIGHTNESSUP = (SDL_SCANCODE_BRIGHTNESSUP | (1<<30)),
    SDLK_DISPLAYSWITCH = (SDL_SCANCODE_DISPLAYSWITCH | (1<<30)),
    SDLK_KBDILLUMTOGGLE =
        (SDL_SCANCODE_KBDILLUMTOGGLE | (1<<30)),
    SDLK_KBDILLUMDOWN = (SDL_SCANCODE_KBDILLUMDOWN | (1<<30)),
    SDLK_KBDILLUMUP = (SDL_SCANCODE_KBDILLUMUP | (1<<30)),
    SDLK_EJECT = (SDL_SCANCODE_EJECT | (1<<30)),
    SDLK_SLEEP = (SDL_SCANCODE_SLEEP | (1<<30)),
    SDLK_APP1 = (SDL_SCANCODE_APP1 | (1<<30)),
    SDLK_APP2 = (SDL_SCANCODE_APP2 | (1<<30)),

    SDLK_AUDIOREWIND = (SDL_SCANCODE_AUDIOREWIND | (1<<30)),
    SDLK_AUDIOFASTFORWARD = (SDL_SCANCODE_AUDIOFASTFORWARD | (1<<30))
};




typedef enum
{
    KMOD_NONE = 0x0000,
    KMOD_LSHIFT = 0x0001,
    KMOD_RSHIFT = 0x0002,
    KMOD_LCTRL = 0x0040,
    KMOD_RCTRL = 0x0080,
    KMOD_LALT = 0x0100,
    KMOD_RALT = 0x0200,
    KMOD_LGUI = 0x0400,
    KMOD_RGUI = 0x0800,
    KMOD_NUM = 0x1000,
    KMOD_CAPS = 0x2000,
    KMOD_MODE = 0x4000,
    KMOD_RESERVED = 0x8000
} SDL_Keymod;
# 34 "/usr/local/include/SDL2/SDL_keyboard.h" 2


# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 37 "/usr/local/include/SDL2/SDL_keyboard.h" 2


extern "C" {







typedef struct SDL_Keysym
{
    SDL_Scancode scancode;
    SDL_Keycode sym;
    Uint16 mod;
    Uint32 unused;
} SDL_Keysym;






extern __attribute__ ((visibility("default"))) SDL_Window * SDL_GetKeyboardFocus(void);
# 77 "/usr/local/include/SDL2/SDL_keyboard.h"
extern __attribute__ ((visibility("default"))) const Uint8 * SDL_GetKeyboardState(int *numkeys);




extern __attribute__ ((visibility("default"))) SDL_Keymod SDL_GetModState(void);






extern __attribute__ ((visibility("default"))) void SDL_SetModState(SDL_Keymod modstate);
# 99 "/usr/local/include/SDL2/SDL_keyboard.h"
extern __attribute__ ((visibility("default"))) SDL_Keycode SDL_GetKeyFromScancode(SDL_Scancode scancode);
# 109 "/usr/local/include/SDL2/SDL_keyboard.h"
extern __attribute__ ((visibility("default"))) SDL_Scancode SDL_GetScancodeFromKey(SDL_Keycode key);
# 120 "/usr/local/include/SDL2/SDL_keyboard.h"
extern __attribute__ ((visibility("default"))) const char * SDL_GetScancodeName(SDL_Scancode scancode);
# 129 "/usr/local/include/SDL2/SDL_keyboard.h"
extern __attribute__ ((visibility("default"))) SDL_Scancode SDL_GetScancodeFromName(const char *name);
# 141 "/usr/local/include/SDL2/SDL_keyboard.h"
extern __attribute__ ((visibility("default"))) const char * SDL_GetKeyName(SDL_Keycode key);
# 150 "/usr/local/include/SDL2/SDL_keyboard.h"
extern __attribute__ ((visibility("default"))) SDL_Keycode SDL_GetKeyFromName(const char *name);
# 160 "/usr/local/include/SDL2/SDL_keyboard.h"
extern __attribute__ ((visibility("default"))) void SDL_StartTextInput(void);







extern __attribute__ ((visibility("default"))) SDL_bool SDL_IsTextInputActive(void);
# 177 "/usr/local/include/SDL2/SDL_keyboard.h"
extern __attribute__ ((visibility("default"))) void SDL_StopTextInput(void);







extern __attribute__ ((visibility("default"))) void SDL_SetTextInputRect(SDL_Rect *rect);
# 196 "/usr/local/include/SDL2/SDL_keyboard.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasScreenKeyboardSupport(void);
# 207 "/usr/local/include/SDL2/SDL_keyboard.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_IsScreenKeyboardShown(SDL_Window *window);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 214 "/usr/local/include/SDL2/SDL_keyboard.h" 2
# 35 "/usr/local/include/SDL2/SDL_events.h" 2
# 1 "/usr/local/include/SDL2/SDL_mouse.h" 1
# 35 "/usr/local/include/SDL2/SDL_mouse.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 36 "/usr/local/include/SDL2/SDL_mouse.h" 2


extern "C" {


typedef struct SDL_Cursor SDL_Cursor;




typedef enum
{
    SDL_SYSTEM_CURSOR_ARROW,
    SDL_SYSTEM_CURSOR_IBEAM,
    SDL_SYSTEM_CURSOR_WAIT,
    SDL_SYSTEM_CURSOR_CROSSHAIR,
    SDL_SYSTEM_CURSOR_WAITARROW,
    SDL_SYSTEM_CURSOR_SIZENWSE,
    SDL_SYSTEM_CURSOR_SIZENESW,
    SDL_SYSTEM_CURSOR_SIZEWE,
    SDL_SYSTEM_CURSOR_SIZENS,
    SDL_SYSTEM_CURSOR_SIZEALL,
    SDL_SYSTEM_CURSOR_NO,
    SDL_SYSTEM_CURSOR_HAND,
    SDL_NUM_SYSTEM_CURSORS
} SDL_SystemCursor;




typedef enum
{
    SDL_MOUSEWHEEL_NORMAL,
    SDL_MOUSEWHEEL_FLIPPED
} SDL_MouseWheelDirection;






extern __attribute__ ((visibility("default"))) SDL_Window * SDL_GetMouseFocus(void);
# 87 "/usr/local/include/SDL2/SDL_mouse.h"
extern __attribute__ ((visibility("default"))) Uint32 SDL_GetMouseState(int *x, int *y);
# 112 "/usr/local/include/SDL2/SDL_mouse.h"
extern __attribute__ ((visibility("default"))) Uint32 SDL_GetGlobalMouseState(int *x, int *y);
# 121 "/usr/local/include/SDL2/SDL_mouse.h"
extern __attribute__ ((visibility("default"))) Uint32 SDL_GetRelativeMouseState(int *x, int *y);
# 132 "/usr/local/include/SDL2/SDL_mouse.h"
extern __attribute__ ((visibility("default"))) void SDL_WarpMouseInWindow(SDL_Window * window,
                                                   int x, int y);
# 144 "/usr/local/include/SDL2/SDL_mouse.h"
extern __attribute__ ((visibility("default"))) int SDL_WarpMouseGlobal(int x, int y);
# 162 "/usr/local/include/SDL2/SDL_mouse.h"
extern __attribute__ ((visibility("default"))) int SDL_SetRelativeMouseMode(SDL_bool enabled);
# 193 "/usr/local/include/SDL2/SDL_mouse.h"
extern __attribute__ ((visibility("default"))) int SDL_CaptureMouse(SDL_bool enabled);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_GetRelativeMouseMode(void);
# 220 "/usr/local/include/SDL2/SDL_mouse.h"
extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_CreateCursor(const Uint8 * data,
                                                     const Uint8 * mask,
                                                     int w, int h, int hot_x,
                                                     int hot_y);






extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_CreateColorCursor(SDL_Surface *surface,
                                                          int hot_x,
                                                          int hot_y);






extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_CreateSystemCursor(SDL_SystemCursor id);




extern __attribute__ ((visibility("default"))) void SDL_SetCursor(SDL_Cursor * cursor);




extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_GetCursor(void);




extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_GetDefaultCursor(void);
# 263 "/usr/local/include/SDL2/SDL_mouse.h"
extern __attribute__ ((visibility("default"))) void SDL_FreeCursor(SDL_Cursor * cursor);
# 273 "/usr/local/include/SDL2/SDL_mouse.h"
extern __attribute__ ((visibility("default"))) int SDL_ShowCursor(int toggle);
# 296 "/usr/local/include/SDL2/SDL_mouse.h"
}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 299 "/usr/local/include/SDL2/SDL_mouse.h" 2
# 36 "/usr/local/include/SDL2/SDL_events.h" 2
# 1 "/usr/local/include/SDL2/SDL_joystick.h" 1
# 45 "/usr/local/include/SDL2/SDL_joystick.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 46 "/usr/local/include/SDL2/SDL_joystick.h" 2


extern "C" {
# 66 "/usr/local/include/SDL2/SDL_joystick.h"
struct _SDL_Joystick;
typedef struct _SDL_Joystick SDL_Joystick;


typedef struct {
    Uint8 data[16];
} SDL_JoystickGUID;
# 81 "/usr/local/include/SDL2/SDL_joystick.h"
typedef Sint32 SDL_JoystickID;

typedef enum
{
    SDL_JOYSTICK_TYPE_UNKNOWN,
    SDL_JOYSTICK_TYPE_GAMECONTROLLER,
    SDL_JOYSTICK_TYPE_WHEEL,
    SDL_JOYSTICK_TYPE_ARCADE_STICK,
    SDL_JOYSTICK_TYPE_FLIGHT_STICK,
    SDL_JOYSTICK_TYPE_DANCE_PAD,
    SDL_JOYSTICK_TYPE_GUITAR,
    SDL_JOYSTICK_TYPE_DRUM_KIT,
    SDL_JOYSTICK_TYPE_ARCADE_PAD,
    SDL_JOYSTICK_TYPE_THROTTLE
} SDL_JoystickType;

typedef enum
{
    SDL_JOYSTICK_POWER_UNKNOWN = -1,
    SDL_JOYSTICK_POWER_EMPTY,
    SDL_JOYSTICK_POWER_LOW,
    SDL_JOYSTICK_POWER_MEDIUM,
    SDL_JOYSTICK_POWER_FULL,
    SDL_JOYSTICK_POWER_WIRED,
    SDL_JOYSTICK_POWER_MAX
} SDL_JoystickPowerLevel;
# 120 "/usr/local/include/SDL2/SDL_joystick.h"
extern __attribute__ ((visibility("default"))) void SDL_LockJoysticks(void);
extern __attribute__ ((visibility("default"))) void SDL_UnlockJoysticks(void);




extern __attribute__ ((visibility("default"))) int SDL_NumJoysticks(void);






extern __attribute__ ((visibility("default"))) const char * SDL_JoystickNameForIndex(int device_index);





extern __attribute__ ((visibility("default"))) SDL_JoystickGUID SDL_JoystickGetDeviceGUID(int device_index);






extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetDeviceVendor(int device_index);






extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetDeviceProduct(int device_index);






extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetDeviceProductVersion(int device_index);





extern __attribute__ ((visibility("default"))) SDL_JoystickType SDL_JoystickGetDeviceType(int device_index);






extern __attribute__ ((visibility("default"))) SDL_JoystickID SDL_JoystickGetDeviceInstanceID(int device_index);
# 184 "/usr/local/include/SDL2/SDL_joystick.h"
extern __attribute__ ((visibility("default"))) SDL_Joystick * SDL_JoystickOpen(int device_index);




extern __attribute__ ((visibility("default"))) SDL_Joystick * SDL_JoystickFromInstanceID(SDL_JoystickID joyid);





extern __attribute__ ((visibility("default"))) const char * SDL_JoystickName(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) SDL_JoystickGUID SDL_JoystickGetGUID(SDL_Joystick * joystick);





extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetVendor(SDL_Joystick * joystick);





extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetProduct(SDL_Joystick * joystick);





extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetProductVersion(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) SDL_JoystickType SDL_JoystickGetType(SDL_Joystick * joystick);





extern __attribute__ ((visibility("default"))) void SDL_JoystickGetGUIDString(SDL_JoystickGUID guid, char *pszGUID, int cbGUID);




extern __attribute__ ((visibility("default"))) SDL_JoystickGUID SDL_JoystickGetGUIDFromString(const char *pchGUID);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_JoystickGetAttached(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) SDL_JoystickID SDL_JoystickInstanceID(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) int SDL_JoystickNumAxes(SDL_Joystick * joystick);







extern __attribute__ ((visibility("default"))) int SDL_JoystickNumBalls(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) int SDL_JoystickNumHats(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) int SDL_JoystickNumButtons(SDL_Joystick * joystick);







extern __attribute__ ((visibility("default"))) void SDL_JoystickUpdate(void);
# 286 "/usr/local/include/SDL2/SDL_joystick.h"
extern __attribute__ ((visibility("default"))) int SDL_JoystickEventState(int state);
# 297 "/usr/local/include/SDL2/SDL_joystick.h"
extern __attribute__ ((visibility("default"))) Sint16 SDL_JoystickGetAxis(SDL_Joystick * joystick,
                                                   int axis);
# 309 "/usr/local/include/SDL2/SDL_joystick.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_JoystickGetAxisInitialState(SDL_Joystick * joystick,
                                                   int axis, Sint16 *state);
# 343 "/usr/local/include/SDL2/SDL_joystick.h"
extern __attribute__ ((visibility("default"))) Uint8 SDL_JoystickGetHat(SDL_Joystick * joystick,
                                                 int hat);
# 353 "/usr/local/include/SDL2/SDL_joystick.h"
extern __attribute__ ((visibility("default"))) int SDL_JoystickGetBall(SDL_Joystick * joystick,
                                                int ball, int *dx, int *dy);






extern __attribute__ ((visibility("default"))) Uint8 SDL_JoystickGetButton(SDL_Joystick * joystick,
                                                    int button);




extern __attribute__ ((visibility("default"))) void SDL_JoystickClose(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) SDL_JoystickPowerLevel SDL_JoystickCurrentPowerLevel(SDL_Joystick * joystick);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 379 "/usr/local/include/SDL2/SDL_joystick.h" 2
# 37 "/usr/local/include/SDL2/SDL_events.h" 2
# 1 "/usr/local/include/SDL2/SDL_gamecontroller.h" 1
# 36 "/usr/local/include/SDL2/SDL_gamecontroller.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 37 "/usr/local/include/SDL2/SDL_gamecontroller.h" 2


extern "C" {
# 57 "/usr/local/include/SDL2/SDL_gamecontroller.h"
struct _SDL_GameController;
typedef struct _SDL_GameController SDL_GameController;


typedef enum
{
    SDL_CONTROLLER_BINDTYPE_NONE = 0,
    SDL_CONTROLLER_BINDTYPE_BUTTON,
    SDL_CONTROLLER_BINDTYPE_AXIS,
    SDL_CONTROLLER_BINDTYPE_HAT
} SDL_GameControllerBindType;




typedef struct SDL_GameControllerButtonBind
{
    SDL_GameControllerBindType bindType;
    union
    {
        int button;
        int axis;
        struct {
            int hat;
            int hat_mask;
        } hat;
    } value;

} SDL_GameControllerButtonBind;
# 122 "/usr/local/include/SDL2/SDL_gamecontroller.h"
extern __attribute__ ((visibility("default"))) int SDL_GameControllerAddMappingsFromRW(SDL_RWops * rw, int freerw);
# 136 "/usr/local/include/SDL2/SDL_gamecontroller.h"
extern __attribute__ ((visibility("default"))) int SDL_GameControllerAddMapping(const char* mappingString);






extern __attribute__ ((visibility("default"))) int SDL_GameControllerNumMappings(void);






extern __attribute__ ((visibility("default"))) char * SDL_GameControllerMappingForIndex(int mapping_index);






extern __attribute__ ((visibility("default"))) char * SDL_GameControllerMappingForGUID(SDL_JoystickGUID guid);






extern __attribute__ ((visibility("default"))) char * SDL_GameControllerMapping(SDL_GameController * gamecontroller);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_IsGameController(int joystick_index);






extern __attribute__ ((visibility("default"))) const char * SDL_GameControllerNameForIndex(int joystick_index);
# 187 "/usr/local/include/SDL2/SDL_gamecontroller.h"
extern __attribute__ ((visibility("default"))) SDL_GameController * SDL_GameControllerOpen(int joystick_index);




extern __attribute__ ((visibility("default"))) SDL_GameController * SDL_GameControllerFromInstanceID(SDL_JoystickID joyid);




extern __attribute__ ((visibility("default"))) const char * SDL_GameControllerName(SDL_GameController *gamecontroller);





extern __attribute__ ((visibility("default"))) Uint16 SDL_GameControllerGetVendor(SDL_GameController * gamecontroller);





extern __attribute__ ((visibility("default"))) Uint16 SDL_GameControllerGetProduct(SDL_GameController * gamecontroller);





extern __attribute__ ((visibility("default"))) Uint16 SDL_GameControllerGetProductVersion(SDL_GameController * gamecontroller);





extern __attribute__ ((visibility("default"))) SDL_bool SDL_GameControllerGetAttached(SDL_GameController *gamecontroller);




extern __attribute__ ((visibility("default"))) SDL_Joystick * SDL_GameControllerGetJoystick(SDL_GameController *gamecontroller);
# 237 "/usr/local/include/SDL2/SDL_gamecontroller.h"
extern __attribute__ ((visibility("default"))) int SDL_GameControllerEventState(int state);







extern __attribute__ ((visibility("default"))) void SDL_GameControllerUpdate(void);
# 257 "/usr/local/include/SDL2/SDL_gamecontroller.h"
typedef enum
{
    SDL_CONTROLLER_AXIS_INVALID = -1,
    SDL_CONTROLLER_AXIS_LEFTX,
    SDL_CONTROLLER_AXIS_LEFTY,
    SDL_CONTROLLER_AXIS_RIGHTX,
    SDL_CONTROLLER_AXIS_RIGHTY,
    SDL_CONTROLLER_AXIS_TRIGGERLEFT,
    SDL_CONTROLLER_AXIS_TRIGGERRIGHT,
    SDL_CONTROLLER_AXIS_MAX
} SDL_GameControllerAxis;




extern __attribute__ ((visibility("default"))) SDL_GameControllerAxis SDL_GameControllerGetAxisFromString(const char *pchString);




extern __attribute__ ((visibility("default"))) const char* SDL_GameControllerGetStringForAxis(SDL_GameControllerAxis axis);




extern __attribute__ ((visibility("default"))) SDL_GameControllerButtonBind
SDL_GameControllerGetBindForAxis(SDL_GameController *gamecontroller,
                                 SDL_GameControllerAxis axis);
# 294 "/usr/local/include/SDL2/SDL_gamecontroller.h"
extern __attribute__ ((visibility("default"))) Sint16
SDL_GameControllerGetAxis(SDL_GameController *gamecontroller,
                          SDL_GameControllerAxis axis);




typedef enum
{
    SDL_CONTROLLER_BUTTON_INVALID = -1,
    SDL_CONTROLLER_BUTTON_A,
    SDL_CONTROLLER_BUTTON_B,
    SDL_CONTROLLER_BUTTON_X,
    SDL_CONTROLLER_BUTTON_Y,
    SDL_CONTROLLER_BUTTON_BACK,
    SDL_CONTROLLER_BUTTON_GUIDE,
    SDL_CONTROLLER_BUTTON_START,
    SDL_CONTROLLER_BUTTON_LEFTSTICK,
    SDL_CONTROLLER_BUTTON_RIGHTSTICK,
    SDL_CONTROLLER_BUTTON_LEFTSHOULDER,
    SDL_CONTROLLER_BUTTON_RIGHTSHOULDER,
    SDL_CONTROLLER_BUTTON_DPAD_UP,
    SDL_CONTROLLER_BUTTON_DPAD_DOWN,
    SDL_CONTROLLER_BUTTON_DPAD_LEFT,
    SDL_CONTROLLER_BUTTON_DPAD_RIGHT,
    SDL_CONTROLLER_BUTTON_MAX
} SDL_GameControllerButton;




extern __attribute__ ((visibility("default"))) SDL_GameControllerButton SDL_GameControllerGetButtonFromString(const char *pchString);




extern __attribute__ ((visibility("default"))) const char* SDL_GameControllerGetStringForButton(SDL_GameControllerButton button);




extern __attribute__ ((visibility("default"))) SDL_GameControllerButtonBind
SDL_GameControllerGetBindForButton(SDL_GameController *gamecontroller,
                                   SDL_GameControllerButton button);







extern __attribute__ ((visibility("default"))) Uint8 SDL_GameControllerGetButton(SDL_GameController *gamecontroller,
                                                          SDL_GameControllerButton button);




extern __attribute__ ((visibility("default"))) void SDL_GameControllerClose(SDL_GameController *gamecontroller);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 359 "/usr/local/include/SDL2/SDL_gamecontroller.h" 2
# 38 "/usr/local/include/SDL2/SDL_events.h" 2
# 1 "/usr/local/include/SDL2/SDL_quit.h" 1
# 39 "/usr/local/include/SDL2/SDL_events.h" 2
# 1 "/usr/local/include/SDL2/SDL_gesture.h" 1
# 35 "/usr/local/include/SDL2/SDL_gesture.h"
# 1 "/usr/local/include/SDL2/SDL_touch.h" 1
# 35 "/usr/local/include/SDL2/SDL_touch.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 36 "/usr/local/include/SDL2/SDL_touch.h" 2


extern "C" {


typedef Sint64 SDL_TouchID;
typedef Sint64 SDL_FingerID;

typedef struct SDL_Finger
{
    SDL_FingerID id;
    float x;
    float y;
    float pressure;
} SDL_Finger;
# 61 "/usr/local/include/SDL2/SDL_touch.h"
extern __attribute__ ((visibility("default"))) int SDL_GetNumTouchDevices(void);




extern __attribute__ ((visibility("default"))) SDL_TouchID SDL_GetTouchDevice(int index);




extern __attribute__ ((visibility("default"))) int SDL_GetNumTouchFingers(SDL_TouchID touchID);




extern __attribute__ ((visibility("default"))) SDL_Finger * SDL_GetTouchFinger(SDL_TouchID touchID, int index);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 83 "/usr/local/include/SDL2/SDL_touch.h" 2
# 36 "/usr/local/include/SDL2/SDL_gesture.h" 2


# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 39 "/usr/local/include/SDL2/SDL_gesture.h" 2


extern "C" {


typedef Sint64 SDL_GestureID;
# 53 "/usr/local/include/SDL2/SDL_gesture.h"
extern __attribute__ ((visibility("default"))) int SDL_RecordGesture(SDL_TouchID touchId);







extern __attribute__ ((visibility("default"))) int SDL_SaveAllDollarTemplates(SDL_RWops *dst);






extern __attribute__ ((visibility("default"))) int SDL_SaveDollarTemplate(SDL_GestureID gestureId,SDL_RWops *dst);







extern __attribute__ ((visibility("default"))) int SDL_LoadDollarTemplates(SDL_TouchID touchId, SDL_RWops *src);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 84 "/usr/local/include/SDL2/SDL_gesture.h" 2
# 40 "/usr/local/include/SDL2/SDL_events.h" 2


# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 43 "/usr/local/include/SDL2/SDL_events.h" 2


extern "C" {
# 55 "/usr/local/include/SDL2/SDL_events.h"
typedef enum
{
    SDL_FIRSTEVENT = 0,


    SDL_QUIT = 0x100,


    SDL_APP_TERMINATING,



    SDL_APP_LOWMEMORY,



    SDL_APP_WILLENTERBACKGROUND,



    SDL_APP_DIDENTERBACKGROUND,



    SDL_APP_WILLENTERFOREGROUND,



    SDL_APP_DIDENTERFOREGROUND,





    SDL_WINDOWEVENT = 0x200,
    SDL_SYSWMEVENT,


    SDL_KEYDOWN = 0x300,
    SDL_KEYUP,
    SDL_TEXTEDITING,
    SDL_TEXTINPUT,
    SDL_KEYMAPCHANGED,




    SDL_MOUSEMOTION = 0x400,
    SDL_MOUSEBUTTONDOWN,
    SDL_MOUSEBUTTONUP,
    SDL_MOUSEWHEEL,


    SDL_JOYAXISMOTION = 0x600,
    SDL_JOYBALLMOTION,
    SDL_JOYHATMOTION,
    SDL_JOYBUTTONDOWN,
    SDL_JOYBUTTONUP,
    SDL_JOYDEVICEADDED,
    SDL_JOYDEVICEREMOVED,


    SDL_CONTROLLERAXISMOTION = 0x650,
    SDL_CONTROLLERBUTTONDOWN,
    SDL_CONTROLLERBUTTONUP,
    SDL_CONTROLLERDEVICEADDED,
    SDL_CONTROLLERDEVICEREMOVED,
    SDL_CONTROLLERDEVICEREMAPPED,


    SDL_FINGERDOWN = 0x700,
    SDL_FINGERUP,
    SDL_FINGERMOTION,


    SDL_DOLLARGESTURE = 0x800,
    SDL_DOLLARRECORD,
    SDL_MULTIGESTURE,


    SDL_CLIPBOARDUPDATE = 0x900,


    SDL_DROPFILE = 0x1000,
    SDL_DROPTEXT,
    SDL_DROPBEGIN,
    SDL_DROPCOMPLETE,


    SDL_AUDIODEVICEADDED = 0x1100,
    SDL_AUDIODEVICEREMOVED,


    SDL_RENDER_TARGETS_RESET = 0x2000,
    SDL_RENDER_DEVICE_RESET,




    SDL_USEREVENT = 0x8000,




    SDL_LASTEVENT = 0xFFFF
} SDL_EventType;




typedef struct SDL_CommonEvent
{
    Uint32 type;
    Uint32 timestamp;
} SDL_CommonEvent;




typedef struct SDL_WindowEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Uint8 event;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint32 data1;
    Sint32 data2;
} SDL_WindowEvent;




typedef struct SDL_KeyboardEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Uint8 state;
    Uint8 repeat;
    Uint8 padding2;
    Uint8 padding3;
    SDL_Keysym keysym;
} SDL_KeyboardEvent;





typedef struct SDL_TextEditingEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    char text[(32)];
    Sint32 start;
    Sint32 length;
} SDL_TextEditingEvent;






typedef struct SDL_TextInputEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    char text[(32)];
} SDL_TextInputEvent;




typedef struct SDL_MouseMotionEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Uint32 which;
    Uint32 state;
    Sint32 x;
    Sint32 y;
    Sint32 xrel;
    Sint32 yrel;
} SDL_MouseMotionEvent;




typedef struct SDL_MouseButtonEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Uint32 which;
    Uint8 button;
    Uint8 state;
    Uint8 clicks;
    Uint8 padding1;
    Sint32 x;
    Sint32 y;
} SDL_MouseButtonEvent;




typedef struct SDL_MouseWheelEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Uint32 which;
    Sint32 x;
    Sint32 y;
    Uint32 direction;
} SDL_MouseWheelEvent;




typedef struct SDL_JoyAxisEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 axis;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 value;
    Uint16 padding4;
} SDL_JoyAxisEvent;




typedef struct SDL_JoyBallEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 ball;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 xrel;
    Sint16 yrel;
} SDL_JoyBallEvent;




typedef struct SDL_JoyHatEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 hat;
    Uint8 value;






    Uint8 padding1;
    Uint8 padding2;
} SDL_JoyHatEvent;




typedef struct SDL_JoyButtonEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 button;
    Uint8 state;
    Uint8 padding1;
    Uint8 padding2;
} SDL_JoyButtonEvent;




typedef struct SDL_JoyDeviceEvent
{
    Uint32 type;
    Uint32 timestamp;
    Sint32 which;
} SDL_JoyDeviceEvent;





typedef struct SDL_ControllerAxisEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 axis;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 value;
    Uint16 padding4;
} SDL_ControllerAxisEvent;





typedef struct SDL_ControllerButtonEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 button;
    Uint8 state;
    Uint8 padding1;
    Uint8 padding2;
} SDL_ControllerButtonEvent;





typedef struct SDL_ControllerDeviceEvent
{
    Uint32 type;
    Uint32 timestamp;
    Sint32 which;
} SDL_ControllerDeviceEvent;




typedef struct SDL_AudioDeviceEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 which;
    Uint8 iscapture;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
} SDL_AudioDeviceEvent;





typedef struct SDL_TouchFingerEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_TouchID touchId;
    SDL_FingerID fingerId;
    float x;
    float y;
    float dx;
    float dy;
    float pressure;
} SDL_TouchFingerEvent;





typedef struct SDL_MultiGestureEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_TouchID touchId;
    float dTheta;
    float dDist;
    float x;
    float y;
    Uint16 numFingers;
    Uint16 padding;
} SDL_MultiGestureEvent;





typedef struct SDL_DollarGestureEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_TouchID touchId;
    SDL_GestureID gestureId;
    Uint32 numFingers;
    float error;
    float x;
    float y;
} SDL_DollarGestureEvent;







typedef struct SDL_DropEvent
{
    Uint32 type;
    Uint32 timestamp;
    char *file;
    Uint32 windowID;
} SDL_DropEvent;





typedef struct SDL_QuitEvent
{
    Uint32 type;
    Uint32 timestamp;
} SDL_QuitEvent;




typedef struct SDL_OSEvent
{
    Uint32 type;
    Uint32 timestamp;
} SDL_OSEvent;




typedef struct SDL_UserEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Sint32 code;
    void *data1;
    void *data2;
} SDL_UserEvent;


struct SDL_SysWMmsg;
typedef struct SDL_SysWMmsg SDL_SysWMmsg;







typedef struct SDL_SysWMEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_SysWMmsg *msg;
} SDL_SysWMEvent;




typedef union SDL_Event
{
    Uint32 type;
    SDL_CommonEvent common;
    SDL_WindowEvent window;
    SDL_KeyboardEvent key;
    SDL_TextEditingEvent edit;
    SDL_TextInputEvent text;
    SDL_MouseMotionEvent motion;
    SDL_MouseButtonEvent button;
    SDL_MouseWheelEvent wheel;
    SDL_JoyAxisEvent jaxis;
    SDL_JoyBallEvent jball;
    SDL_JoyHatEvent jhat;
    SDL_JoyButtonEvent jbutton;
    SDL_JoyDeviceEvent jdevice;
    SDL_ControllerAxisEvent caxis;
    SDL_ControllerButtonEvent cbutton;
    SDL_ControllerDeviceEvent cdevice;
    SDL_AudioDeviceEvent adevice;
    SDL_QuitEvent quit;
    SDL_UserEvent user;
    SDL_SysWMEvent syswm;
    SDL_TouchFingerEvent tfinger;
    SDL_MultiGestureEvent mgesture;
    SDL_DollarGestureEvent dgesture;
    SDL_DropEvent drop;
# 560 "/usr/local/include/SDL2/SDL_events.h"
    Uint8 padding[56];
} SDL_Event;
# 573 "/usr/local/include/SDL2/SDL_events.h"
extern __attribute__ ((visibility("default"))) void SDL_PumpEvents(void);


typedef enum
{
    SDL_ADDEVENT,
    SDL_PEEKEVENT,
    SDL_GETEVENT
} SDL_eventaction;
# 601 "/usr/local/include/SDL2/SDL_events.h"
extern __attribute__ ((visibility("default"))) int SDL_PeepEvents(SDL_Event * events, int numevents,
                                           SDL_eventaction action,
                                           Uint32 minType, Uint32 maxType);





extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasEvent(Uint32 type);
extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasEvents(Uint32 minType, Uint32 maxType);







extern __attribute__ ((visibility("default"))) void SDL_FlushEvent(Uint32 type);
extern __attribute__ ((visibility("default"))) void SDL_FlushEvents(Uint32 minType, Uint32 maxType);
# 629 "/usr/local/include/SDL2/SDL_events.h"
extern __attribute__ ((visibility("default"))) int SDL_PollEvent(SDL_Event * event);
# 639 "/usr/local/include/SDL2/SDL_events.h"
extern __attribute__ ((visibility("default"))) int SDL_WaitEvent(SDL_Event * event);
# 651 "/usr/local/include/SDL2/SDL_events.h"
extern __attribute__ ((visibility("default"))) int SDL_WaitEventTimeout(SDL_Event * event,
                                                 int timeout);







extern __attribute__ ((visibility("default"))) int SDL_PushEvent(SDL_Event * event);

typedef int ( * SDL_EventFilter) (void *userdata, SDL_Event * event);
# 689 "/usr/local/include/SDL2/SDL_events.h"
extern __attribute__ ((visibility("default"))) void SDL_SetEventFilter(SDL_EventFilter filter,
                                                void *userdata);





extern __attribute__ ((visibility("default"))) SDL_bool SDL_GetEventFilter(SDL_EventFilter * filter,
                                                    void **userdata);




extern __attribute__ ((visibility("default"))) void SDL_AddEventWatch(SDL_EventFilter filter,
                                               void *userdata);




extern __attribute__ ((visibility("default"))) void SDL_DelEventWatch(SDL_EventFilter filter,
                                               void *userdata);





extern __attribute__ ((visibility("default"))) void SDL_FilterEvents(SDL_EventFilter filter,
                                              void *userdata);
# 733 "/usr/local/include/SDL2/SDL_events.h"
extern __attribute__ ((visibility("default"))) Uint8 SDL_EventState(Uint32 type, int state);
# 744 "/usr/local/include/SDL2/SDL_events.h"
extern __attribute__ ((visibility("default"))) Uint32 SDL_RegisterEvents(int numevents);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 751 "/usr/local/include/SDL2/SDL_events.h" 2
# 42 "/usr/local/include/SDL2/SDL.h" 2
# 1 "/usr/local/include/SDL2/SDL_filesystem.h" 1
# 33 "/usr/local/include/SDL2/SDL_filesystem.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 34 "/usr/local/include/SDL2/SDL_filesystem.h" 2



extern "C" {
# 63 "/usr/local/include/SDL2/SDL_filesystem.h"
extern __attribute__ ((visibility("default"))) char * SDL_GetBasePath(void);
# 126 "/usr/local/include/SDL2/SDL_filesystem.h"
extern __attribute__ ((visibility("default"))) char * SDL_GetPrefPath(const char *org, const char *app);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 133 "/usr/local/include/SDL2/SDL_filesystem.h" 2
# 43 "/usr/local/include/SDL2/SDL.h" 2

# 1 "/usr/local/include/SDL2/SDL_haptic.h" 1
# 114 "/usr/local/include/SDL2/SDL_haptic.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 115 "/usr/local/include/SDL2/SDL_haptic.h" 2


extern "C" {
# 129 "/usr/local/include/SDL2/SDL_haptic.h"
struct _SDL_Haptic;
typedef struct _SDL_Haptic SDL_Haptic;
# 439 "/usr/local/include/SDL2/SDL_haptic.h"
typedef struct SDL_HapticDirection
{
    Uint8 type;
    Sint32 dir[3];
} SDL_HapticDirection;
# 457 "/usr/local/include/SDL2/SDL_haptic.h"
typedef struct SDL_HapticConstant
{

    Uint16 type;
    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Sint16 level;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticConstant;
# 538 "/usr/local/include/SDL2/SDL_haptic.h"
typedef struct SDL_HapticPeriodic
{

    Uint16 type;


    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Uint16 period;
    Sint16 magnitude;
    Sint16 offset;
    Uint16 phase;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticPeriodic;
# 591 "/usr/local/include/SDL2/SDL_haptic.h"
typedef struct SDL_HapticCondition
{

    Uint16 type;

    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Uint16 right_sat[3];
    Uint16 left_sat[3];
    Sint16 right_coeff[3];
    Sint16 left_coeff[3];
    Uint16 deadband[3];
    Sint16 center[3];
} SDL_HapticCondition;
# 628 "/usr/local/include/SDL2/SDL_haptic.h"
typedef struct SDL_HapticRamp
{

    Uint16 type;
    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Sint16 start;
    Sint16 end;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticRamp;
# 665 "/usr/local/include/SDL2/SDL_haptic.h"
typedef struct SDL_HapticLeftRight
{

    Uint16 type;


    Uint32 length;


    Uint16 large_magnitude;
    Uint16 small_magnitude;
} SDL_HapticLeftRight;
# 693 "/usr/local/include/SDL2/SDL_haptic.h"
typedef struct SDL_HapticCustom
{

    Uint16 type;
    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Uint8 channels;
    Uint16 period;
    Uint16 samples;
    Uint16 *data;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticCustom;
# 789 "/usr/local/include/SDL2/SDL_haptic.h"
typedef union SDL_HapticEffect
{

    Uint16 type;
    SDL_HapticConstant constant;
    SDL_HapticPeriodic periodic;
    SDL_HapticCondition condition;
    SDL_HapticRamp ramp;
    SDL_HapticLeftRight leftright;
    SDL_HapticCustom custom;
} SDL_HapticEffect;
# 808 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_NumHaptics(void);
# 821 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) const char * SDL_HapticName(int device_index);
# 845 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) SDL_Haptic * SDL_HapticOpen(int device_index);
# 856 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticOpened(int device_index);
# 867 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticIndex(SDL_Haptic * haptic);
# 876 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_MouseIsHaptic(void);
# 886 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) SDL_Haptic * SDL_HapticOpenFromMouse(void);
# 897 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_JoystickIsHaptic(SDL_Joystick * joystick);
# 916 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) SDL_Haptic * SDL_HapticOpenFromJoystick(SDL_Joystick *
                                                               joystick);






extern __attribute__ ((visibility("default"))) void SDL_HapticClose(SDL_Haptic * haptic);
# 940 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticNumEffects(SDL_Haptic * haptic);
# 956 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticNumEffectsPlaying(SDL_Haptic * haptic);
# 974 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) unsigned int SDL_HapticQuery(SDL_Haptic * haptic);







extern __attribute__ ((visibility("default"))) int SDL_HapticNumAxes(SDL_Haptic * haptic);
# 994 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticEffectSupported(SDL_Haptic * haptic,
                                                      SDL_HapticEffect *
                                                      effect);
# 1009 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticNewEffect(SDL_Haptic * haptic,
                                                SDL_HapticEffect * effect);
# 1029 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticUpdateEffect(SDL_Haptic * haptic,
                                                   int effect,
                                                   SDL_HapticEffect * data);
# 1051 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticRunEffect(SDL_Haptic * haptic,
                                                int effect,
                                                Uint32 iterations);
# 1065 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticStopEffect(SDL_Haptic * haptic,
                                                 int effect);
# 1079 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) void SDL_HapticDestroyEffect(SDL_Haptic * haptic,
                                                     int effect);
# 1094 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticGetEffectStatus(SDL_Haptic * haptic,
                                                      int effect);
# 1113 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticSetGain(SDL_Haptic * haptic, int gain);
# 1129 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticSetAutocenter(SDL_Haptic * haptic,
                                                    int autocenter);
# 1146 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticPause(SDL_Haptic * haptic);
# 1158 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticUnpause(SDL_Haptic * haptic);







extern __attribute__ ((visibility("default"))) int SDL_HapticStopAll(SDL_Haptic * haptic);
# 1178 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticRumbleSupported(SDL_Haptic * haptic);
# 1191 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticRumbleInit(SDL_Haptic * haptic);
# 1205 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticRumblePlay(SDL_Haptic * haptic, float strength, Uint32 length );
# 1217 "/usr/local/include/SDL2/SDL_haptic.h"
extern __attribute__ ((visibility("default"))) int SDL_HapticRumbleStop(SDL_Haptic * haptic);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 1224 "/usr/local/include/SDL2/SDL_haptic.h" 2
# 45 "/usr/local/include/SDL2/SDL.h" 2
# 1 "/usr/local/include/SDL2/SDL_hints.h" 1
# 44 "/usr/local/include/SDL2/SDL_hints.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 45 "/usr/local/include/SDL2/SDL_hints.h" 2


extern "C" {
# 936 "/usr/local/include/SDL2/SDL_hints.h"
typedef enum
{
    SDL_HINT_DEFAULT,
    SDL_HINT_NORMAL,
    SDL_HINT_OVERRIDE
} SDL_HintPriority;
# 953 "/usr/local/include/SDL2/SDL_hints.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_SetHintWithPriority(const char *name,
                                                         const char *value,
                                                         SDL_HintPriority priority);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_SetHint(const char *name,
                                             const char *value);






extern __attribute__ ((visibility("default"))) const char * SDL_GetHint(const char *name);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_GetHintBoolean(const char *name, SDL_bool default_value);




typedef void ( *SDL_HintCallback)(void *userdata, const char *name, const char *oldValue, const char *newValue);
# 991 "/usr/local/include/SDL2/SDL_hints.h"
extern __attribute__ ((visibility("default"))) void SDL_AddHintCallback(const char *name,
                                                 SDL_HintCallback callback,
                                                 void *userdata);
# 1002 "/usr/local/include/SDL2/SDL_hints.h"
extern __attribute__ ((visibility("default"))) void SDL_DelHintCallback(const char *name,
                                                 SDL_HintCallback callback,
                                                 void *userdata);






extern __attribute__ ((visibility("default"))) void SDL_ClearHints(void);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 1019 "/usr/local/include/SDL2/SDL_hints.h" 2
# 46 "/usr/local/include/SDL2/SDL.h" 2

# 1 "/usr/local/include/SDL2/SDL_loadso.h" 1
# 47 "/usr/local/include/SDL2/SDL_loadso.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 48 "/usr/local/include/SDL2/SDL_loadso.h" 2


extern "C" {







extern __attribute__ ((visibility("default"))) void * SDL_LoadObject(const char *sofile);






extern __attribute__ ((visibility("default"))) void * SDL_LoadFunction(void *handle,
                                               const char *name);




extern __attribute__ ((visibility("default"))) void SDL_UnloadObject(void *handle);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 78 "/usr/local/include/SDL2/SDL_loadso.h" 2
# 48 "/usr/local/include/SDL2/SDL.h" 2
# 1 "/usr/local/include/SDL2/SDL_log.h" 1
# 42 "/usr/local/include/SDL2/SDL_log.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 43 "/usr/local/include/SDL2/SDL_log.h" 2


extern "C" {
# 64 "/usr/local/include/SDL2/SDL_log.h"
enum
{
    SDL_LOG_CATEGORY_APPLICATION,
    SDL_LOG_CATEGORY_ERROR,
    SDL_LOG_CATEGORY_ASSERT,
    SDL_LOG_CATEGORY_SYSTEM,
    SDL_LOG_CATEGORY_AUDIO,
    SDL_LOG_CATEGORY_VIDEO,
    SDL_LOG_CATEGORY_RENDER,
    SDL_LOG_CATEGORY_INPUT,
    SDL_LOG_CATEGORY_TEST,


    SDL_LOG_CATEGORY_RESERVED1,
    SDL_LOG_CATEGORY_RESERVED2,
    SDL_LOG_CATEGORY_RESERVED3,
    SDL_LOG_CATEGORY_RESERVED4,
    SDL_LOG_CATEGORY_RESERVED5,
    SDL_LOG_CATEGORY_RESERVED6,
    SDL_LOG_CATEGORY_RESERVED7,
    SDL_LOG_CATEGORY_RESERVED8,
    SDL_LOG_CATEGORY_RESERVED9,
    SDL_LOG_CATEGORY_RESERVED10,
# 96 "/usr/local/include/SDL2/SDL_log.h"
    SDL_LOG_CATEGORY_CUSTOM
};




typedef enum
{
    SDL_LOG_PRIORITY_VERBOSE = 1,
    SDL_LOG_PRIORITY_DEBUG,
    SDL_LOG_PRIORITY_INFO,
    SDL_LOG_PRIORITY_WARN,
    SDL_LOG_PRIORITY_ERROR,
    SDL_LOG_PRIORITY_CRITICAL,
    SDL_NUM_LOG_PRIORITIES
} SDL_LogPriority;





extern __attribute__ ((visibility("default"))) void SDL_LogSetAllPriority(SDL_LogPriority priority);




extern __attribute__ ((visibility("default"))) void SDL_LogSetPriority(int category,
                                                SDL_LogPriority priority);




extern __attribute__ ((visibility("default"))) SDL_LogPriority SDL_LogGetPriority(int category);






extern __attribute__ ((visibility("default"))) void SDL_LogResetPriorities(void);




extern __attribute__ ((visibility("default"))) void SDL_Log( const char *fmt, ...) __attribute__ (( format( __printf__, 1, 1 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogVerbose(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogDebug(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogInfo(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogWarn(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogError(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogCritical(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogMessage(int category,
                                            SDL_LogPriority priority,
                                                                     const char *fmt, ...) __attribute__ (( format( __printf__, 3, 3 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogMessageV(int category,
                                             SDL_LogPriority priority,
                                             const char *fmt, va_list ap);




typedef void ( *SDL_LogOutputFunction)(void *userdata, int category, SDL_LogPriority priority, const char *message);




extern __attribute__ ((visibility("default"))) void SDL_LogGetOutputFunction(SDL_LogOutputFunction *callback, void **userdata);





extern __attribute__ ((visibility("default"))) void SDL_LogSetOutputFunction(SDL_LogOutputFunction callback, void *userdata);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 208 "/usr/local/include/SDL2/SDL_log.h" 2
# 49 "/usr/local/include/SDL2/SDL.h" 2
# 1 "/usr/local/include/SDL2/SDL_messagebox.h" 1
# 28 "/usr/local/include/SDL2/SDL_messagebox.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 29 "/usr/local/include/SDL2/SDL_messagebox.h" 2


extern "C" {





typedef enum
{
    SDL_MESSAGEBOX_ERROR = 0x00000010,
    SDL_MESSAGEBOX_WARNING = 0x00000020,
    SDL_MESSAGEBOX_INFORMATION = 0x00000040
} SDL_MessageBoxFlags;




typedef enum
{
    SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = 0x00000001,
    SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = 0x00000002
} SDL_MessageBoxButtonFlags;




typedef struct
{
    Uint32 flags;
    int buttonid;
    const char * text;
} SDL_MessageBoxButtonData;




typedef struct
{
    Uint8 r, g, b;
} SDL_MessageBoxColor;

typedef enum
{
    SDL_MESSAGEBOX_COLOR_BACKGROUND,
    SDL_MESSAGEBOX_COLOR_TEXT,
    SDL_MESSAGEBOX_COLOR_BUTTON_BORDER,
    SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND,
    SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED,
    SDL_MESSAGEBOX_COLOR_MAX
} SDL_MessageBoxColorType;




typedef struct
{
    SDL_MessageBoxColor colors[SDL_MESSAGEBOX_COLOR_MAX];
} SDL_MessageBoxColorScheme;




typedef struct
{
    Uint32 flags;
    SDL_Window *window;
    const char *title;
    const char *message;

    int numbuttons;
    const SDL_MessageBoxButtonData *buttons;

    const SDL_MessageBoxColorScheme *colorScheme;
} SDL_MessageBoxData;
# 119 "/usr/local/include/SDL2/SDL_messagebox.h"
extern __attribute__ ((visibility("default"))) int SDL_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid);
# 133 "/usr/local/include/SDL2/SDL_messagebox.h"
extern __attribute__ ((visibility("default"))) int SDL_ShowSimpleMessageBox(Uint32 flags, const char *title, const char *message, SDL_Window *window);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 141 "/usr/local/include/SDL2/SDL_messagebox.h" 2
# 50 "/usr/local/include/SDL2/SDL.h" 2

# 1 "/usr/local/include/SDL2/SDL_power.h" 1
# 33 "/usr/local/include/SDL2/SDL_power.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 34 "/usr/local/include/SDL2/SDL_power.h" 2


extern "C" {





typedef enum
{
    SDL_POWERSTATE_UNKNOWN,
    SDL_POWERSTATE_ON_BATTERY,
    SDL_POWERSTATE_NO_BATTERY,
    SDL_POWERSTATE_CHARGING,
    SDL_POWERSTATE_CHARGED
} SDL_PowerState;
# 65 "/usr/local/include/SDL2/SDL_power.h"
extern __attribute__ ((visibility("default"))) SDL_PowerState SDL_GetPowerInfo(int *secs, int *pct);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 72 "/usr/local/include/SDL2/SDL_power.h" 2
# 52 "/usr/local/include/SDL2/SDL.h" 2
# 1 "/usr/local/include/SDL2/SDL_render.h" 1
# 55 "/usr/local/include/SDL2/SDL_render.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 56 "/usr/local/include/SDL2/SDL_render.h" 2


extern "C" {





typedef enum
{
    SDL_RENDERER_SOFTWARE = 0x00000001,
    SDL_RENDERER_ACCELERATED = 0x00000002,

    SDL_RENDERER_PRESENTVSYNC = 0x00000004,

    SDL_RENDERER_TARGETTEXTURE = 0x00000008

} SDL_RendererFlags;




typedef struct SDL_RendererInfo
{
    const char *name;
    Uint32 flags;
    Uint32 num_texture_formats;
    Uint32 texture_formats[16];
    int max_texture_width;
    int max_texture_height;
} SDL_RendererInfo;




typedef enum
{
    SDL_TEXTUREACCESS_STATIC,
    SDL_TEXTUREACCESS_STREAMING,
    SDL_TEXTUREACCESS_TARGET
} SDL_TextureAccess;




typedef enum
{
    SDL_TEXTUREMODULATE_NONE = 0x00000000,
    SDL_TEXTUREMODULATE_COLOR = 0x00000001,
    SDL_TEXTUREMODULATE_ALPHA = 0x00000002
} SDL_TextureModulate;




typedef enum
{
    SDL_FLIP_NONE = 0x00000000,
    SDL_FLIP_HORIZONTAL = 0x00000001,
    SDL_FLIP_VERTICAL = 0x00000002
} SDL_RendererFlip;




struct SDL_Renderer;
typedef struct SDL_Renderer SDL_Renderer;




struct SDL_Texture;
typedef struct SDL_Texture SDL_Texture;
# 144 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_GetNumRenderDrivers(void);
# 158 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_GetRenderDriverInfo(int index,
                                                    SDL_RendererInfo * info);
# 172 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_CreateWindowAndRenderer(
                                int width, int height, Uint32 window_flags,
                                SDL_Window **window, SDL_Renderer **renderer);
# 191 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) SDL_Renderer * SDL_CreateRenderer(SDL_Window * window,
                                               int index, Uint32 flags);
# 204 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) SDL_Renderer * SDL_CreateSoftwareRenderer(SDL_Surface * surface);




extern __attribute__ ((visibility("default"))) SDL_Renderer * SDL_GetRenderer(SDL_Window * window);




extern __attribute__ ((visibility("default"))) int SDL_GetRendererInfo(SDL_Renderer * renderer,
                                                SDL_RendererInfo * info);




extern __attribute__ ((visibility("default"))) int SDL_GetRendererOutputSize(SDL_Renderer * renderer,
                                                      int *w, int *h);
# 242 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) SDL_Texture * SDL_CreateTexture(SDL_Renderer * renderer,
                                                        Uint32 format,
                                                        int access, int w,
                                                        int h);
# 260 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) SDL_Texture * SDL_CreateTextureFromSurface(SDL_Renderer * renderer, SDL_Surface * surface);
# 275 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_QueryTexture(SDL_Texture * texture,
                                             Uint32 * format, int *access,
                                             int *w, int *h);
# 292 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_SetTextureColorMod(SDL_Texture * texture,
                                                   Uint8 r, Uint8 g, Uint8 b);
# 308 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_GetTextureColorMod(SDL_Texture * texture,
                                                   Uint8 * r, Uint8 * g,
                                                   Uint8 * b);
# 323 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_SetTextureAlphaMod(SDL_Texture * texture,
                                                   Uint8 alpha);
# 336 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_GetTextureAlphaMod(SDL_Texture * texture,
                                                   Uint8 * alpha);
# 353 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_SetTextureBlendMode(SDL_Texture * texture,
                                                    SDL_BlendMode blendMode);
# 366 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_GetTextureBlendMode(SDL_Texture * texture,
                                                    SDL_BlendMode *blendMode);
# 385 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_UpdateTexture(SDL_Texture * texture,
                                              const SDL_Rect * rect,
                                              const void *pixels, int pitch);
# 408 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_UpdateYUVTexture(SDL_Texture * texture,
                                                 const SDL_Rect * rect,
                                                 const Uint8 *Yplane, int Ypitch,
                                                 const Uint8 *Uplane, int Upitch,
                                                 const Uint8 *Vplane, int Vpitch);
# 429 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_LockTexture(SDL_Texture * texture,
                                            const SDL_Rect * rect,
                                            void **pixels, int *pitch);






extern __attribute__ ((visibility("default"))) void SDL_UnlockTexture(SDL_Texture * texture);
# 447 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_RenderTargetSupported(SDL_Renderer *renderer);
# 459 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_SetRenderTarget(SDL_Renderer *renderer,
                                                SDL_Texture *texture);
# 469 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) SDL_Texture * SDL_GetRenderTarget(SDL_Renderer *renderer);
# 494 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderSetLogicalSize(SDL_Renderer * renderer, int w, int h);
# 505 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) void SDL_RenderGetLogicalSize(SDL_Renderer * renderer, int *w, int *h);
# 519 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderSetIntegerScale(SDL_Renderer * renderer,
                                                      SDL_bool enable);
# 529 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_RenderGetIntegerScale(SDL_Renderer * renderer);
# 546 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderSetViewport(SDL_Renderer * renderer,
                                                  const SDL_Rect * rect);






extern __attribute__ ((visibility("default"))) void SDL_RenderGetViewport(SDL_Renderer * renderer,
                                                   SDL_Rect * rect);
# 568 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderSetClipRect(SDL_Renderer * renderer,
                                                  const SDL_Rect * rect);
# 580 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) void SDL_RenderGetClipRect(SDL_Renderer * renderer,
                                                   SDL_Rect * rect);
# 590 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_RenderIsClipEnabled(SDL_Renderer * renderer);
# 611 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderSetScale(SDL_Renderer * renderer,
                                               float scaleX, float scaleY);
# 623 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) void SDL_RenderGetScale(SDL_Renderer * renderer,
                                               float *scaleX, float *scaleY);
# 638 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_SetRenderDrawColor(SDL_Renderer * renderer,
                                           Uint8 r, Uint8 g, Uint8 b,
                                           Uint8 a);
# 654 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_GetRenderDrawColor(SDL_Renderer * renderer,
                                           Uint8 * r, Uint8 * g, Uint8 * b,
                                           Uint8 * a);
# 671 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_SetRenderDrawBlendMode(SDL_Renderer * renderer,
                                                       SDL_BlendMode blendMode);
# 684 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_GetRenderDrawBlendMode(SDL_Renderer * renderer,
                                                       SDL_BlendMode *blendMode);
# 695 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderClear(SDL_Renderer * renderer);
# 706 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawPoint(SDL_Renderer * renderer,
                                                int x, int y);
# 718 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawPoints(SDL_Renderer * renderer,
                                                 const SDL_Point * points,
                                                 int count);
# 733 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawLine(SDL_Renderer * renderer,
                                               int x1, int y1, int x2, int y2);
# 745 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawLines(SDL_Renderer * renderer,
                                                const SDL_Point * points,
                                                int count);
# 757 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawRect(SDL_Renderer * renderer,
                                               const SDL_Rect * rect);
# 769 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawRects(SDL_Renderer * renderer,
                                                const SDL_Rect * rects,
                                                int count);
# 782 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderFillRect(SDL_Renderer * renderer,
                                               const SDL_Rect * rect);
# 794 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderFillRects(SDL_Renderer * renderer,
                                                const SDL_Rect * rects,
                                                int count);
# 810 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderCopy(SDL_Renderer * renderer,
                                           SDL_Texture * texture,
                                           const SDL_Rect * srcrect,
                                           const SDL_Rect * dstrect);
# 830 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderCopyEx(SDL_Renderer * renderer,
                                           SDL_Texture * texture,
                                           const SDL_Rect * srcrect,
                                           const SDL_Rect * dstrect,
                                           const double angle,
                                           const SDL_Point *center,
                                           const SDL_RendererFlip flip);
# 853 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_RenderReadPixels(SDL_Renderer * renderer,
                                                 const SDL_Rect * rect,
                                                 Uint32 format,
                                                 void *pixels, int pitch);




extern __attribute__ ((visibility("default"))) void SDL_RenderPresent(SDL_Renderer * renderer);







extern __attribute__ ((visibility("default"))) void SDL_DestroyTexture(SDL_Texture * texture);







extern __attribute__ ((visibility("default"))) void SDL_DestroyRenderer(SDL_Renderer * renderer);
# 890 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_GL_BindTexture(SDL_Texture *texture, float *texw, float *texh);
# 899 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) int SDL_GL_UnbindTexture(SDL_Texture *texture);
# 910 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) void * SDL_RenderGetMetalLayer(SDL_Renderer * renderer);
# 921 "/usr/local/include/SDL2/SDL_render.h"
extern __attribute__ ((visibility("default"))) void * SDL_RenderGetMetalCommandEncoder(SDL_Renderer * renderer);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 928 "/usr/local/include/SDL2/SDL_render.h" 2
# 53 "/usr/local/include/SDL2/SDL.h" 2

# 1 "/usr/local/include/SDL2/SDL_shape.h" 1
# 31 "/usr/local/include/SDL2/SDL_shape.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 32 "/usr/local/include/SDL2/SDL_shape.h" 2


extern "C" {
# 66 "/usr/local/include/SDL2/SDL_shape.h"
extern __attribute__ ((visibility("default"))) SDL_Window * SDL_CreateShapedWindow(const char *title,unsigned int x,unsigned int y,unsigned int w,unsigned int h,Uint32 flags);
# 77 "/usr/local/include/SDL2/SDL_shape.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_IsShapedWindow(const SDL_Window *window);


typedef enum {

    ShapeModeDefault,

    ShapeModeBinarizeAlpha,

    ShapeModeReverseBinarizeAlpha,

    ShapeModeColorKey
} WindowShapeMode;




typedef union {

    Uint8 binarizationCutoff;
    SDL_Color colorKey;
} SDL_WindowShapeParams;


typedef struct SDL_WindowShapeMode {

    WindowShapeMode mode;

    SDL_WindowShapeParams parameters;
} SDL_WindowShapeMode;
# 121 "/usr/local/include/SDL2/SDL_shape.h"
extern __attribute__ ((visibility("default"))) int SDL_SetWindowShape(SDL_Window *window,SDL_Surface *shape,SDL_WindowShapeMode *shape_mode);
# 136 "/usr/local/include/SDL2/SDL_shape.h"
extern __attribute__ ((visibility("default"))) int SDL_GetShapedWindowMode(SDL_Window *window,SDL_WindowShapeMode *shape_mode);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 143 "/usr/local/include/SDL2/SDL_shape.h" 2
# 55 "/usr/local/include/SDL2/SDL.h" 2
# 1 "/usr/local/include/SDL2/SDL_system.h" 1
# 36 "/usr/local/include/SDL2/SDL_system.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 37 "/usr/local/include/SDL2/SDL_system.h" 2


extern "C" {
# 241 "/usr/local/include/SDL2/SDL_system.h"
}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 244 "/usr/local/include/SDL2/SDL_system.h" 2
# 56 "/usr/local/include/SDL2/SDL.h" 2

# 1 "/usr/local/include/SDL2/SDL_timer.h" 1
# 34 "/usr/local/include/SDL2/SDL_timer.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 35 "/usr/local/include/SDL2/SDL_timer.h" 2


extern "C" {







extern __attribute__ ((visibility("default"))) Uint32 SDL_GetTicks(void);
# 61 "/usr/local/include/SDL2/SDL_timer.h"
extern __attribute__ ((visibility("default"))) Uint64 SDL_GetPerformanceCounter(void);




extern __attribute__ ((visibility("default"))) Uint64 SDL_GetPerformanceFrequency(void);




extern __attribute__ ((visibility("default"))) void SDL_Delay(Uint32 ms);
# 81 "/usr/local/include/SDL2/SDL_timer.h"
typedef Uint32 ( * SDL_TimerCallback) (Uint32 interval, void *param);




typedef int SDL_TimerID;






extern __attribute__ ((visibility("default"))) SDL_TimerID SDL_AddTimer(Uint32 interval,
                                                 SDL_TimerCallback callback,
                                                 void *param);
# 104 "/usr/local/include/SDL2/SDL_timer.h"
extern __attribute__ ((visibility("default"))) SDL_bool SDL_RemoveTimer(SDL_TimerID id);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 112 "/usr/local/include/SDL2/SDL_timer.h" 2
# 58 "/usr/local/include/SDL2/SDL.h" 2
# 1 "/usr/local/include/SDL2/SDL_version.h" 1
# 33 "/usr/local/include/SDL2/SDL_version.h"
# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 34 "/usr/local/include/SDL2/SDL_version.h" 2


extern "C" {
# 51 "/usr/local/include/SDL2/SDL_version.h"
typedef struct SDL_version
{
    Uint8 major;
    Uint8 minor;
    Uint8 patch;
} SDL_version;
# 133 "/usr/local/include/SDL2/SDL_version.h"
extern __attribute__ ((visibility("default"))) void SDL_GetVersion(SDL_version * ver);
# 142 "/usr/local/include/SDL2/SDL_version.h"
extern __attribute__ ((visibility("default"))) const char * SDL_GetRevision(void);
# 151 "/usr/local/include/SDL2/SDL_version.h"
extern __attribute__ ((visibility("default"))) int SDL_GetRevisionNumber(void);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 159 "/usr/local/include/SDL2/SDL_version.h" 2
# 59 "/usr/local/include/SDL2/SDL.h" 2


# 1 "/usr/local/include/SDL2/begin_code.h" 1
# 62 "/usr/local/include/SDL2/SDL.h" 2


extern "C" {
# 93 "/usr/local/include/SDL2/SDL.h"
extern __attribute__ ((visibility("default"))) int SDL_Init(Uint32 flags);
# 104 "/usr/local/include/SDL2/SDL.h"
extern __attribute__ ((visibility("default"))) int SDL_InitSubSystem(Uint32 flags);




extern __attribute__ ((visibility("default"))) void SDL_QuitSubSystem(Uint32 flags);







extern __attribute__ ((visibility("default"))) Uint32 SDL_WasInit(Uint32 flags);





extern __attribute__ ((visibility("default"))) void SDL_Quit(void);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1
# 130 "/usr/local/include/SDL2/SDL.h" 2
# 14 "include/Simpleton/SDL/library.hpp" 2
# 1 "include/Simpleton/SDL/window.hpp" 1
# 13 "include/Simpleton/SDL/window.hpp"
# 1 "include/glm/vec2.hpp" 1




# 1 "include/glm/./ext/vector_bool2.hpp" 1




# 1 "include/glm/./ext/../detail/type_vec2.hpp" 1





# 1 "include/glm/./ext/../detail/qualifier.hpp" 1


# 1 "include/glm/./ext/../detail/setup.hpp" 1


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 2 3 4
# 75 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn)) __attribute__((__disable_tail_calls__));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 3
# 3 "include/glm/./ext/../detail/setup.hpp" 2
# 33 "include/glm/./ext/../detail/setup.hpp"
# 1 "include/glm/./ext/../detail/../simd/platform.h" 1
# 336 "include/glm/./ext/../detail/../simd/platform.h"
 typedef __m128 glm_f32vec4;
 typedef __m128i glm_i32vec4;
 typedef __m128i glm_u32vec4;
 typedef __m128d glm_f64vec2;
 typedef __m128i glm_i64vec2;
 typedef __m128i glm_u64vec2;

 typedef glm_f32vec4 glm_vec4;
 typedef glm_i32vec4 glm_ivec4;
 typedef glm_u32vec4 glm_uvec4;
 typedef glm_f64vec2 glm_dvec2;
# 33 "include/glm/./ext/../detail/setup.hpp" 2
# 519 "include/glm/./ext/../detail/setup.hpp"
namespace glm
{
 using std::size_t;



  typedef int length_t;

}
# 557 "include/glm/./ext/../detail/setup.hpp"
namespace glm{
namespace detail
{
 template<typename T>
 struct is_int
 {
  enum test {value = 0};
 };

 template<>
 struct is_int<unsigned int>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<signed int>
 {
  enum test {value = ~0};
 };
}

 typedef unsigned int uint;
}
# 589 "include/glm/./ext/../detail/setup.hpp"
namespace glm{
namespace detail
{

  typedef std::uint64_t uint64;
  typedef std::int64_t int64;
# 613 "include/glm/./ext/../detail/setup.hpp"
}
}







namespace glm{
namespace detail
{
 using std::make_unsigned;
}
}
# 3 "include/glm/./ext/../detail/qualifier.hpp" 2


namespace glm
{

 enum qualifier
 {
  packed_highp,
  packed_mediump,
  packed_lowp,


   aligned_highp,
   aligned_mediump,
   aligned_lowp,
   aligned = aligned_highp,


  highp = packed_highp,
  mediump = packed_mediump,
  lowp = packed_lowp,
  packed = packed_highp,




   defaultp = highp

 };

 typedef qualifier precision;

 template<length_t L, typename T, qualifier Q = defaultp> struct vec;
 template<length_t C, length_t R, typename T, qualifier Q = defaultp> struct mat;
 template<typename T, qualifier Q = defaultp> struct qua;


  template <typename T, qualifier Q = defaultp> using tvec1 = vec<1, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec2 = vec<2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec3 = vec<3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec4 = vec<4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x2 = mat<2, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x3 = mat<2, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x4 = mat<2, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x2 = mat<3, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x3 = mat<3, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x4 = mat<3, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x2 = mat<4, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x3 = mat<4, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x4 = mat<4, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tquat = qua<T, Q>;


namespace detail
{
 template<glm::qualifier P>
 struct is_aligned
 {
  static const bool value = false;
 };


  template<>
  struct is_aligned<glm::aligned_lowp>
  {
   static const bool value = true;
  };

  template<>
  struct is_aligned<glm::aligned_mediump>
  {
   static const bool value = true;
  };

  template<>
  struct is_aligned<glm::aligned_highp>
  {
   static const bool value = true;
  };


 template<length_t L, typename T, bool is_aligned>
 struct storage
 {
  typedef struct type {
   T data[L];
  } type;
 };


  template<length_t L, typename T>
  struct storage<L, T, true>
  {
   typedef struct alignas(L * sizeof(T)) type {
    T data[L];
   } type;
  };

  template<typename T>
  struct storage<3, T, true>
  {
   typedef struct alignas(4 * sizeof(T)) type {
    T data[4];
   } type;
  };



 template<>
 struct storage<4, float, true>
 {
  typedef glm_f32vec4 type;
 };

 template<>
 struct storage<4, int, true>
 {
  typedef glm_i32vec4 type;
 };

 template<>
 struct storage<4, unsigned int, true>
 {
  typedef glm_u32vec4 type;
 };

 template<>
 struct storage<2, double, true>
 {
  typedef glm_f64vec2 type;
 };

 template<>
 struct storage<2, detail::int64, true>
 {
  typedef glm_i64vec2 type;
 };

 template<>
 struct storage<2, detail::uint64, true>
 {
  typedef glm_u64vec2 type;
 };
# 170 "include/glm/./ext/../detail/qualifier.hpp"
 enum genTypeEnum
 {
  GENTYPE_VEC,
  GENTYPE_MAT,
  GENTYPE_QUAT
 };

 template <typename genType>
 struct genTypeTrait
 {};

 template <length_t C, length_t R, typename T>
 struct genTypeTrait<mat<C, R, T> >
 {
  static const genTypeEnum GENTYPE = GENTYPE_MAT;
 };

 template<typename genType, genTypeEnum type>
 struct init_gentype
 {
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_QUAT>
 {
  inline static genType identity()
  {
   return genType(1, 0, 0, 0);
  }
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_MAT>
 {
  inline static genType identity()
  {
   return genType(1);
  }
 };
}
}
# 6 "include/glm/./ext/../detail/type_vec2.hpp" 2








namespace glm
{
 template<typename T, qualifier Q>
 struct vec<2, T, Q>
 {


  typedef T value_type;
  typedef vec<2, T, Q> type;
  typedef vec<2, bool, Q> bool_type;






   union
   {
    struct{ T x, y; };
    struct{ T r, g; };
    struct{ T s, t; };

    typename detail::storage<2, T, detail::is_aligned<Q>::value>::type data;
# 49 "include/glm/./ext/../detail/type_vec2.hpp"
   };
# 62 "include/glm/./ext/../detail/type_vec2.hpp"
  typedef length_t length_type;
                static length_type length(){return 2;}

                              T& operator[](length_type i);
                              T const& operator[](length_type i) const;



                              vec() = default;
                              vec(vec const& v) = default;
  template<qualifier P>
                              vec(vec<2, T, P> const& v);



                              explicit vec(T scalar);
                              vec(T x, T y);



  template<typename U, qualifier P>
                              explicit vec(vec<1, U, P> const& v);


  template<typename A, typename B>
                              vec(A x, B y);
  template<typename A, typename B>
                              vec(vec<1, A, Q> const& x, B y);
  template<typename A, typename B>
                              vec(A x, vec<1, B, Q> const& y);
  template<typename A, typename B>
                              vec(vec<1, A, Q> const& x, vec<1, B, Q> const& y);




  template<typename U, qualifier P>
                                           vec(vec<3, U, P> const& v);

  template<typename U, qualifier P>
                                           vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
                                           vec(vec<2, U, P> const& v);
# 119 "include/glm/./ext/../detail/type_vec2.hpp"
                              vec<2, T, Q> & operator=(vec const& v) = default;

  template<typename U>
                              vec<2, T, Q> & operator=(vec<2, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator+=(U scalar);
  template<typename U>
                              vec<2, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator+=(vec<2, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator-=(U scalar);
  template<typename U>
                              vec<2, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator-=(vec<2, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator*=(U scalar);
  template<typename U>
                              vec<2, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator*=(vec<2, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator/=(U scalar);
  template<typename U>
                              vec<2, T, Q> & operator/=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator/=(vec<2, U, Q> const& v);



                              vec<2, T, Q> & operator++();
                              vec<2, T, Q> & operator--();
                              vec<2, T, Q> operator++(int);
                              vec<2, T, Q> operator--(int);



  template<typename U>
                              vec<2, T, Q> & operator%=(U scalar);
  template<typename U>
                              vec<2, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator%=(vec<2, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator&=(U scalar);
  template<typename U>
                              vec<2, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator&=(vec<2, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator|=(U scalar);
  template<typename U>
                              vec<2, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator|=(vec<2, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator^=(U scalar);
  template<typename U>
                              vec<2, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator^=(vec<2, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator<<=(U scalar);
  template<typename U>
                              vec<2, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator<<=(vec<2, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator>>=(U scalar);
  template<typename U>
                              vec<2, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<2, T, Q> & operator>>=(vec<2, U, Q> const& v);
 };



 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator~(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
                             bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<qualifier Q>
                             vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);

 template<qualifier Q>
                             vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);
}



# 1 "include/glm/./ext/../detail/type_vec2.inl" 1


# 1 "include/glm/./ext/../detail/./compute_vector_relational.hpp" 1



# 1 "include/glm/./ext/../detail/setup.hpp" 1
# 4 "include/glm/./ext/../detail/./compute_vector_relational.hpp" 2



namespace glm{
namespace detail
{
 template <typename T, bool isFloat>
 struct compute_equal
 {
  inline static bool call(T a, T b)
  {
   return a == b;
  }
 };
# 29 "include/glm/./ext/../detail/./compute_vector_relational.hpp"
}
}
# 3 "include/glm/./ext/../detail/type_vec2.inl" 2


namespace glm
{
# 23 "include/glm/./ext/../detail/type_vec2.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline vec<2, T, Q>::vec(vec<2, T, P> const& v)
  : x(v.x), y(v.y)
 {}



 template<typename T, qualifier Q>
 inline vec<2, T, Q>::vec(T scalar)
  : x(scalar), y(scalar)
 {}

 template<typename T, qualifier Q>
 inline vec<2, T, Q>::vec(T _x, T _y)
  : x(_x), y(_y)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<2, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline vec<2, T, Q>::vec(A _x, B _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline vec<2, T, Q>::vec(vec<1, A, Q> const& _x, B _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline vec<2, T, Q>::vec(A _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline vec<2, T, Q>::vec(vec<1, A, Q> const& _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<2, T, Q>::vec(vec<2, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<2, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<2, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}



 template<typename T, qualifier Q>
 inline T & vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "include/glm/./ext/../detail/type_vec2.inl", 106, "i >= 0 && i < this->length()") : (void)0);
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }

 template<typename T, qualifier Q>
 inline T const& vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "include/glm/./ext/../detail/type_vec2.inl", 120, "i >= 0 && i < this->length()") : (void)0);
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }
# 143 "include/glm/./ext/../detail/type_vec2.inl"
 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator=(vec<2, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<2, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<2, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<2, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  this->y /= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<2, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 inline vec<2, T, Q> & vec<2, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> & vec<2, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> vec<2, T, Q>::operator++(int)
 {
  vec<2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> vec<2, T, Q>::operator--(int)
 {
  vec<2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  this->y %= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<2, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  this->y &= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<2, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  this->y |= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<2, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  this->y ^= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<2, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  this->y <<= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<2, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<2, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   -v.x,
   -v.y);
 }



 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x + scalar,
   v.y + scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar + v.x,
   scalar + v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.x + v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x - scalar,
   v.y - scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar - v.x,
   scalar - v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.x - v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x * scalar,
   v.y * scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar * v.x,
   scalar * v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.x * v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x / scalar,
   v.y / scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar / v.x,
   scalar / v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.x / v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.y);
 }



 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x % scalar,
   v.y % scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar % v.x,
   scalar % v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.x % v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x & scalar,
   v.y & scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar & v.x,
   scalar & v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.x & v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x | scalar,
   v.y | scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar | v.x,
   scalar | v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.x | v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x ^ scalar,
   v.y ^ scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar ^ v.x,
   scalar ^ v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.x ^ v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x << scalar,
   v.y << scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar << v.x,
   scalar << v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.x << v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x >> scalar,
   v.y >> scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar >> v.x,
   scalar >> v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.x >> v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator~(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   ~v.x,
   ~v.y);
 }



 template<typename T, qualifier Q>
 inline bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x && v2.x, v1.y && v2.y);
 }

 template<qualifier Q>
 inline vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x || v2.x, v1.y || v2.y);
 }
}
# 374 "include/glm/./ext/../detail/type_vec2.hpp" 2
# 5 "include/glm/./ext/vector_bool2.hpp" 2


namespace glm
{






 typedef vec<2, bool, defaultp> bvec2;


}
# 5 "include/glm/vec2.hpp" 2

# 1 "include/glm/./ext/vector_bool2_precision.hpp" 1






namespace glm
{







 typedef vec<2, bool, highp> highp_bvec2;





 typedef vec<2, bool, mediump> mediump_bvec2;





 typedef vec<2, bool, lowp> lowp_bvec2;


}
# 6 "include/glm/vec2.hpp" 2

# 1 "include/glm/./ext/vector_float2.hpp" 1






namespace glm
{






 typedef vec<2, float, defaultp> vec2;


}
# 7 "include/glm/vec2.hpp" 2

# 1 "include/glm/./ext/vector_float2_precision.hpp" 1






namespace glm
{







 typedef vec<2, float, highp> highp_vec2;





 typedef vec<2, float, mediump> mediump_vec2;





 typedef vec<2, float, lowp> lowp_vec2;


}
# 8 "include/glm/vec2.hpp" 2

# 1 "include/glm/./ext/vector_double2.hpp" 1






namespace glm
{






 typedef vec<2, double, defaultp> dvec2;


}
# 9 "include/glm/vec2.hpp" 2

# 1 "include/glm/./ext/vector_double2_precision.hpp" 1






namespace glm
{







 typedef vec<2, double, highp> highp_dvec2;





 typedef vec<2, double, mediump> mediump_dvec2;





 typedef vec<2, double, lowp> lowp_dvec2;


}
# 10 "include/glm/vec2.hpp" 2

# 1 "include/glm/./ext/vector_int2.hpp" 1






namespace glm
{






 typedef vec<2, int, defaultp> ivec2;


}
# 11 "include/glm/vec2.hpp" 2

# 1 "include/glm/./ext/vector_int2_precision.hpp" 1






namespace glm
{







 typedef vec<2, int, highp> highp_ivec2;





 typedef vec<2, int, mediump> mediump_ivec2;





 typedef vec<2, int, lowp> lowp_ivec2;


}
# 12 "include/glm/vec2.hpp" 2

# 1 "include/glm/./ext/vector_uint2.hpp" 1






namespace glm
{






 typedef vec<2, unsigned int, defaultp> uvec2;


}
# 13 "include/glm/vec2.hpp" 2

# 1 "include/glm/./ext/vector_uint2_precision.hpp" 1






namespace glm
{







 typedef vec<2, unsigned int, highp> highp_uvec2;





 typedef vec<2, unsigned int, mediump> mediump_uvec2;





 typedef vec<2, unsigned int, lowp> lowp_uvec2;


}
# 14 "include/glm/vec2.hpp" 2
# 14 "include/Simpleton/SDL/window.hpp" 2


# 1 "include/Simpleton/SDL/../Utils/generic raii.hpp" 1
# 17 "include/Simpleton/SDL/window.hpp" 2

namespace SDL {
  class Window {
  public:
    using ID = uint32_t;

    struct Desc {
      std::string title;
      glm::ivec2 size = {1280, 720};
      bool resizable = false;
      bool openGL = false;
    };

    using value_type = SDL_Window *; constexpr Window() noexcept : window{} {} constexpr Window(std::nullptr_t) noexcept : window{} {} explicit Window(const value_type window) noexcept : window{window} {} Window(Window &&other) noexcept : window{other.release()} {} Window &operator=(Window &&other) noexcept { reset(other.release()); return *this; } Window &operator=(std::nullptr_t) noexcept { reset(); return *this; } ~Window() { SDL_DestroyWindow(window); } value_type release() noexcept { return std::exchange(window, value_type{}); } void reset(const value_type newwindow = {}) noexcept { SDL_DestroyWindow(window); window = newwindow; } value_type get() const noexcept { return window; } explicit operator bool() const noexcept { return window != value_type{}; } bool operator==(const Window &other) const noexcept { return window == other.window; } bool operator!=(const Window &other) const noexcept { return window != other.window; } bool operator<(const Window &other) const noexcept { return window < other.window; } bool operator<=(const Window &other) const noexcept { return window <= other.window; } bool operator>(const Window &other) const noexcept { return window > other.window; } bool operator>=(const Window &other) const noexcept { return window >= other.window; } friend bool operator==(const Window &obj, std::nullptr_t) noexcept { return obj.window == value_type{}; } friend bool operator!=(const Window &obj, std::nullptr_t) noexcept { return obj.window != value_type{}; } friend bool operator<(const Window &obj, std::nullptr_t) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return false; } else { return obj.window < value_type{}; } } friend bool operator<=(const Window &obj, std::nullptr_t) noexcept { return obj.window <= value_type{}; } friend bool operator>(const Window &obj, std::nullptr_t) noexcept { return obj.window > value_type{}; } friend bool operator>=(const Window &obj, std::nullptr_t) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return true; } else { return obj.window >= value_type{}; } } friend bool operator==(std::nullptr_t, const Window &obj) noexcept { return value_type{} == obj.window; } friend bool operator!=(std::nullptr_t, const Window &obj) noexcept { return value_type{} != obj.window; } friend bool operator<(std::nullptr_t, const Window &obj) noexcept { return value_type{} < obj.window; } friend bool operator<=(std::nullptr_t, const Window &obj) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return true; } else { return value_type{} <= obj.window; } } friend bool operator>(std::nullptr_t, const Window &obj) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return false; } else { return value_type{} > obj.window; } } friend bool operator>=(std::nullptr_t, const Window &obj) noexcept { return value_type{} >= obj.window; } void swap(Window &other) noexcept { std::swap(window, other.window); } friend void swap(Window &a, Window &b) noexcept { std::swap(a.window, b.window); }

    ID getID() const;

    void title(const std::string &);
    std::string title() const;

    void center();
    void pos(glm::ivec2);
    glm::ivec2 pos() const;

    void size(glm::ivec2);
    glm::ivec2 size() const;
    float aspect() const;

    void relMouse(bool);
    bool relMouse() const;

    void raise();
    void fullscreen(bool);
    void toggleFullscreen();

  private:
    SDL_Window *window;
  };
}


# 1 "include/Simpleton/SDL/window.inl" 1
# 11 "include/Simpleton/SDL/window.inl"
inline SDL::Window::ID SDL::Window::getID() const {
  return SDL_GetWindowID(window);
}

inline void SDL::Window::title(const std::string &newTitle) {
  SDL_SetWindowTitle(window, newTitle.c_str());
}

inline std::string SDL::Window::title() const {
  return SDL_GetWindowTitle(window);
}

inline void SDL::Window::center() {
  SDL_SetWindowPosition(window, (0x2FFF0000u|(0)), (0x2FFF0000u|(0)));
}

inline void SDL::Window::pos(const glm::ivec2 newPos) {
  SDL_SetWindowPosition(window, newPos.x, newPos.y);
}

inline glm::ivec2 SDL::Window::pos() const {
  glm::ivec2 pos;
  SDL_GetWindowPosition(window, &pos.x, &pos.y);
  return pos;
}

inline void SDL::Window::size(glm::ivec2 newSize) {
  SDL_SetWindowSize(window, newSize.x, newSize.y);
}

inline glm::ivec2 SDL::Window::size() const {
  glm::ivec2 size;
  SDL_GetWindowSize(window, &size.x, &size.y);
  return size;
}

inline float SDL::Window::aspect() const {
  glm::ivec2 size;
  SDL_GetWindowSize(window, &size.x, &size.y);
  return static_cast<float>(size.x) / size.y;
}

inline void SDL::Window::relMouse(const bool status) {
  (__builtin_expect(!(SDL_GetMouseFocus() == window), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/window.inl", 54, "SDL_GetMouseFocus() == window") : (void)0);
  ((SDL_SetRelativeMouseMode(static_cast<SDL_bool>(status))) != 0 ? throw SDL::Error() : void());
}

inline bool SDL::Window::relMouse() const {
  return SDL_GetRelativeMouseMode() && SDL_GetMouseFocus() == window;
}

inline void SDL::Window::raise() {
  SDL_RaiseWindow(window);
}

inline void SDL::Window::fullscreen(const bool enabled) {
  ((SDL_SetWindowFullscreen( window, enabled ? SDL_WINDOW_FULLSCREEN_DESKTOP : 0 )) != 0 ? throw SDL::Error() : void());



}

inline void SDL::Window::toggleFullscreen() {
  fullscreen((SDL_GetWindowFlags(window) & SDL_WINDOW_FULLSCREEN_DESKTOP) == 0);
}
# 58 "include/Simpleton/SDL/window.hpp" 2
# 15 "include/Simpleton/SDL/library.hpp" 2
# 1 "include/Simpleton/SDL/renderer.hpp" 1
# 12 "include/Simpleton/SDL/renderer.hpp"
# 1 "include/Simpleton/SDL/surface.hpp" 1
# 15 "include/Simpleton/SDL/surface.hpp"
namespace SDL {
  class Surface {
  public:
    using value_type = SDL_Surface *; constexpr Surface() noexcept : surface{} {} constexpr Surface(std::nullptr_t) noexcept : surface{} {} explicit Surface(const value_type surface) noexcept : surface{surface} {} Surface(Surface &&other) noexcept : surface{other.release()} {} Surface &operator=(Surface &&other) noexcept { reset(other.release()); return *this; } Surface &operator=(std::nullptr_t) noexcept { reset(); return *this; } ~Surface() { SDL_FreeSurface(surface); } value_type release() noexcept { return std::exchange(surface, value_type{}); } void reset(const value_type newsurface = {}) noexcept { SDL_FreeSurface(surface); surface = newsurface; } value_type get() const noexcept { return surface; } explicit operator bool() const noexcept { return surface != value_type{}; } bool operator==(const Surface &other) const noexcept { return surface == other.surface; } bool operator!=(const Surface &other) const noexcept { return surface != other.surface; } bool operator<(const Surface &other) const noexcept { return surface < other.surface; } bool operator<=(const Surface &other) const noexcept { return surface <= other.surface; } bool operator>(const Surface &other) const noexcept { return surface > other.surface; } bool operator>=(const Surface &other) const noexcept { return surface >= other.surface; } friend bool operator==(const Surface &obj, std::nullptr_t) noexcept { return obj.surface == value_type{}; } friend bool operator!=(const Surface &obj, std::nullptr_t) noexcept { return obj.surface != value_type{}; } friend bool operator<(const Surface &obj, std::nullptr_t) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return false; } else { return obj.surface < value_type{}; } } friend bool operator<=(const Surface &obj, std::nullptr_t) noexcept { return obj.surface <= value_type{}; } friend bool operator>(const Surface &obj, std::nullptr_t) noexcept { return obj.surface > value_type{}; } friend bool operator>=(const Surface &obj, std::nullptr_t) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return true; } else { return obj.surface >= value_type{}; } } friend bool operator==(std::nullptr_t, const Surface &obj) noexcept { return value_type{} == obj.surface; } friend bool operator!=(std::nullptr_t, const Surface &obj) noexcept { return value_type{} != obj.surface; } friend bool operator<(std::nullptr_t, const Surface &obj) noexcept { return value_type{} < obj.surface; } friend bool operator<=(std::nullptr_t, const Surface &obj) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return true; } else { return value_type{} <= obj.surface; } } friend bool operator>(std::nullptr_t, const Surface &obj) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return false; } else { return value_type{} > obj.surface; } } friend bool operator>=(std::nullptr_t, const Surface &obj) noexcept { return value_type{} >= obj.surface; } void swap(Surface &other) noexcept { std::swap(surface, other.surface); } friend void swap(Surface &a, Surface &b) noexcept { std::swap(a.surface, b.surface); }

  private:
    SDL_Surface *surface;
  };
}
# 13 "include/Simpleton/SDL/renderer.hpp" 2
# 1 "include/Simpleton/SDL/texture.hpp" 1
# 16 "include/Simpleton/SDL/texture.hpp"
namespace SDL {
  class Texture {
  public:
    using value_type = SDL_Texture *; constexpr Texture() noexcept : texture{} {} constexpr Texture(std::nullptr_t) noexcept : texture{} {} explicit Texture(const value_type texture) noexcept : texture{texture} {} Texture(Texture &&other) noexcept : texture{other.release()} {} Texture &operator=(Texture &&other) noexcept { reset(other.release()); return *this; } Texture &operator=(std::nullptr_t) noexcept { reset(); return *this; } ~Texture() { SDL_DestroyTexture(texture); } value_type release() noexcept { return std::exchange(texture, value_type{}); } void reset(const value_type newtexture = {}) noexcept { SDL_DestroyTexture(texture); texture = newtexture; } value_type get() const noexcept { return texture; } explicit operator bool() const noexcept { return texture != value_type{}; } bool operator==(const Texture &other) const noexcept { return texture == other.texture; } bool operator!=(const Texture &other) const noexcept { return texture != other.texture; } bool operator<(const Texture &other) const noexcept { return texture < other.texture; } bool operator<=(const Texture &other) const noexcept { return texture <= other.texture; } bool operator>(const Texture &other) const noexcept { return texture > other.texture; } bool operator>=(const Texture &other) const noexcept { return texture >= other.texture; } friend bool operator==(const Texture &obj, std::nullptr_t) noexcept { return obj.texture == value_type{}; } friend bool operator!=(const Texture &obj, std::nullptr_t) noexcept { return obj.texture != value_type{}; } friend bool operator<(const Texture &obj, std::nullptr_t) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return false; } else { return obj.texture < value_type{}; } } friend bool operator<=(const Texture &obj, std::nullptr_t) noexcept { return obj.texture <= value_type{}; } friend bool operator>(const Texture &obj, std::nullptr_t) noexcept { return obj.texture > value_type{}; } friend bool operator>=(const Texture &obj, std::nullptr_t) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return true; } else { return obj.texture >= value_type{}; } } friend bool operator==(std::nullptr_t, const Texture &obj) noexcept { return value_type{} == obj.texture; } friend bool operator!=(std::nullptr_t, const Texture &obj) noexcept { return value_type{} != obj.texture; } friend bool operator<(std::nullptr_t, const Texture &obj) noexcept { return value_type{} < obj.texture; } friend bool operator<=(std::nullptr_t, const Texture &obj) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return true; } else { return value_type{} <= obj.texture; } } friend bool operator>(std::nullptr_t, const Texture &obj) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return false; } else { return value_type{} > obj.texture; } } friend bool operator>=(std::nullptr_t, const Texture &obj) noexcept { return value_type{} >= obj.texture; } void swap(Texture &other) noexcept { std::swap(texture, other.texture); } friend void swap(Texture &a, Texture &b) noexcept { std::swap(a.texture, b.texture); }

    void blend(const SDL_BlendMode mode) {
      ((SDL_SetTextureBlendMode(texture, mode)) != 0 ? throw SDL::Error() : void());
    }
    SDL_BlendMode blend() const {
      SDL_BlendMode mode;
      ((SDL_GetTextureBlendMode(texture, &mode)) != 0 ? throw SDL::Error() : void());
      return mode;
    }

  private:
    SDL_Texture *texture;
  };
}
# 14 "include/Simpleton/SDL/renderer.hpp" 2
# 1 "include/glm/vec4.hpp" 1




# 1 "include/glm/./ext/vector_bool4.hpp" 1




# 1 "include/glm/./ext/../detail/type_vec4.hpp" 1
# 14 "include/glm/./ext/../detail/type_vec4.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<4, T, Q>
 {


  typedef T value_type;
  typedef vec<4, T, Q> type;
  typedef vec<4, bool, Q> bool_type;






   union
   {
    struct { T x, y, z, w; };
    struct { T r, g, b, a; };
    struct { T s, t, p, q; };

    typename detail::storage<4, T, detail::is_aligned<Q>::value>::type data;
# 49 "include/glm/./ext/../detail/type_vec4.hpp"
   };
# 64 "include/glm/./ext/../detail/type_vec4.hpp"
  typedef length_t length_type;
                static length_type length(){return 4;}

                              T & operator[](length_type i);
                              T const& operator[](length_type i) const;



                              vec() = default;
                              vec(vec<4, T, Q> const& v) = default;
  template<qualifier P>
                              vec(vec<4, T, P> const& v);



                              explicit vec(T scalar);
                              vec(T x, T y, T z, T w);



  template<typename U, qualifier P>
                              explicit vec(vec<1, U, P> const& v);


  template<typename X, typename Y, typename Z, typename W>
                              vec(X _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                              vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _Y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);




  template<typename A, typename B, typename C, qualifier P>
                              vec(vec<2, A, P> const& _xy, B _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
                              vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
                              vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
                              vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
                              vec(A _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
                              vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
                              vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
                              vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
                              vec(A _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
                              vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
                              vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
                              vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, qualifier P>
                              vec(vec<3, A, P> const& _xyz, B _w);

  template<typename A, typename B, qualifier P>
                              vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w);

  template<typename A, typename B, qualifier P>
                              vec(A _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
                              vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
                              vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw);


  template<typename U, qualifier P>
                                           vec(vec<4, U, P> const& v);
# 224 "include/glm/./ext/../detail/type_vec4.hpp"
                              vec<4, T, Q>& operator=(vec<4, T, Q> const& v) = default;

  template<typename U>
                              vec<4, T, Q>& operator=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q>& operator+=(U scalar);
  template<typename U>
                              vec<4, T, Q>& operator+=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q>& operator+=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q>& operator-=(U scalar);
  template<typename U>
                              vec<4, T, Q>& operator-=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q>& operator-=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q>& operator*=(U scalar);
  template<typename U>
                              vec<4, T, Q>& operator*=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q>& operator*=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q>& operator/=(U scalar);
  template<typename U>
                              vec<4, T, Q>& operator/=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q>& operator/=(vec<4, U, Q> const& v);



                              vec<4, T, Q> & operator++();
                              vec<4, T, Q> & operator--();
                              vec<4, T, Q> operator++(int);
                              vec<4, T, Q> operator--(int);



  template<typename U>
                              vec<4, T, Q> & operator%=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator%=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator&=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator&=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator|=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator|=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator^=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator^=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator<<=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator<<=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator>>=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator>>=(vec<4, U, Q> const& v);
 };



 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(vec<4, T, Q> const& v, T const & scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(vec<4, T, Q> const& v, T const & scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator*(vec<4, T, Q> const& v, T const & scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator/(vec<4, T, Q> const& v, T const & scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator%(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator&(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator|(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator|(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator^(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator^(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator<<(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator>>(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator~(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
                             bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<qualifier Q>
                             vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);

 template<qualifier Q>
                             vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);
}



# 1 "include/glm/./ext/../detail/type_vec4.inl" 1




namespace glm{
namespace detail
{
 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_add
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_sub
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mul
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_div
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mod
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_and
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_or
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_xor
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_left
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_right
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_equal
 {
  inline static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.w, v2.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_nequal
 {
  inline static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return !compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_bitwise_not
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& v)
  {
   return vec<4, T, Q>(~v.x, ~v.y, ~v.z, ~v.w);
  }
 };
}
# 146 "include/glm/./ext/../detail/type_vec4.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 inline vec<4, T, Q>::vec(vec<4, T, P> const& v)
  : x(v.x), y(v.y), z(v.z), w(v.w)
 {}



 template<typename T, qualifier Q>
 inline vec<4, T, Q>::vec(T scalar)
  : x(scalar), y(scalar), z(scalar), w(scalar)
 {}

 template <typename T, qualifier Q>
 inline vec<4, T, Q>::vec(T _x, T _y, T _z, T _w)
  : x(_x), y(_y), z(_z), w(_w)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
  , z(static_cast<T>(v.x))
  , w(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}



 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(A _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, B _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<4, T, Q>::vec(A _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<4, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
  , w(static_cast<T>(v.w))
 {}



 template<typename T, qualifier Q>
 inline T& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "include/glm/./ext/../detail/type_vec4.inl", 479, "i >= 0 && i < this->length()") : (void)0);
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }

 template<typename T, qualifier Q>
 inline T const& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "include/glm/./ext/../detail/type_vec4.inl", 497, "i >= 0 && i < this->length()") : (void)0);
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }
# 526 "include/glm/./ext/../detail/type_vec4.inl"
 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q>& vec<4, T, Q>::operator=(vec<4, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  this->w = static_cast<T>(v.w);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator+=(U scalar)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator-=(U scalar)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator*=(U scalar)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator/=(U scalar)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 inline vec<4, T, Q> & vec<4, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> & vec<4, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> vec<4, T, Q>::operator++(int)
 {
  vec<4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> vec<4, T, Q>::operator--(int)
 {
  vec<4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator%=(U scalar)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator&=(U scalar)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator|=(U scalar)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator^=(U scalar)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator<<=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator>>=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(0) -= v;
 }



 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v, T const & scalar)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) += v1;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v, T const & scalar)
 {
  return vec<4, T, Q>(v) -= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) -= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) -= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(vec<4, T, Q> const& v, T const & scalar)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) *= v1;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator/(vec<4, T, Q> const& v, T const & scalar)
 {
  return vec<4, T, Q>(v) /= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) /= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) /= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }



 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) %= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2.x;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) %= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar.x) %= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) &= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator&(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) &= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) &= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) |= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2.x;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) |= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator|(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) |= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) ^= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2.x;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) ^= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator^(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) ^= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) <<= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2.x;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) <<= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator<<(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) <<= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) >>= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2.x;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) >>= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator>>(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) >>= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator~(vec<4, T, Q> const& v)
 {
  return detail::compute_vec4_bitwise_not<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v);
 }



 template<typename T, qualifier Q>
 inline bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_nequal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<qualifier Q>
 inline vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
 }

 template<qualifier Q>
 inline vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
 }
}



# 1 "include/glm/./ext/../detail/type_vec4_simd.inl" 1


namespace glm{
namespace detail
{
# 51 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<qualifier Q>
 struct compute_vec4_add<float, Q, true>
 {
  static vec<4, float, Q> call(vec<4, float, Q> const& a, vec<4, float, Q> const& b)
  {
   vec<4, float, Q> Result;
   Result.data = _mm_add_ps(a.data, b.data);
   return Result;
  }
 };
# 75 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<qualifier Q>
 struct compute_vec4_sub<float, Q, true>
 {
  static vec<4, float, Q> call(vec<4, float, Q> const& a, vec<4, float, Q> const& b)
  {
   vec<4, float, Q> Result;
   Result.data = _mm_sub_ps(a.data, b.data);
   return Result;
  }
 };
# 99 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<qualifier Q>
 struct compute_vec4_mul<float, Q, true>
 {
  static vec<4, float, Q> call(vec<4, float, Q> const& a, vec<4, float, Q> const& b)
  {
   vec<4, float, Q> Result;
   Result.data = _mm_mul_ps(a.data, b.data);
   return Result;
  }
 };
# 123 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<qualifier Q>
 struct compute_vec4_div<float, Q, true>
 {
  static vec<4, float, Q> call(vec<4, float, Q> const& a, vec<4, float, Q> const& b)
  {
   vec<4, float, Q> Result;
   Result.data = _mm_div_ps(a.data, b.data);
   return Result;
  }
 };
# 147 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<>
 struct compute_vec4_div<float, aligned_lowp, true>
 {
  static vec<4, float, aligned_lowp> call(vec<4, float, aligned_lowp> const& a, vec<4, float, aligned_lowp> const& b)
  {
   vec<4, float, aligned_lowp> Result;
   Result.data = _mm_mul_ps(a.data, _mm_rcp_ps(b.data));
   return Result;
  }
 };

 template<typename T, qualifier Q>
 struct compute_vec4_and<T, Q, true, 32, true>
 {
  static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   vec<4, T, Q> Result;
   Result.data = _mm_and_si128(a.data, b.data);
   return Result;
  }
 };
# 182 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<typename T, qualifier Q>
 struct compute_vec4_or<T, Q, true, 32, true>
 {
  static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   vec<4, T, Q> Result;
   Result.data = _mm_or_si128(a.data, b.data);
   return Result;
  }
 };
# 206 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<typename T, qualifier Q>
 struct compute_vec4_xor<T, Q, true, 32, true>
 {
  static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   vec<4, T, Q> Result;
   Result.data = _mm_xor_si128(a.data, b.data);
   return Result;
  }
 };
# 230 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<typename T, qualifier Q>
 struct compute_vec4_shift_left<T, Q, true, 32, true>
 {
  static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   vec<4, T, Q> Result;
   Result.data = _mm_sll_epi32(a.data, b.data);
   return Result;
  }
 };
# 254 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<typename T, qualifier Q>
 struct compute_vec4_shift_right<T, Q, true, 32, true>
 {
  static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   vec<4, T, Q> Result;
   Result.data = _mm_srl_epi32(a.data, b.data);
   return Result;
  }
 };
# 278 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<typename T, qualifier Q>
 struct compute_vec4_bitwise_not<T, Q, true, 32, true>
 {
  static vec<4, T, Q> call(vec<4, T, Q> const& v)
  {
   vec<4, T, Q> Result;
   Result.data = _mm_xor_si128(v.data, _mm_set1_epi32(-1));
   return Result;
  }
 };
# 302 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<qualifier Q>
 struct compute_vec4_equal<float, Q, false, 32, true>
 {
  static bool call(vec<4, float, Q> const& v1, vec<4, float, Q> const& v2)
  {
   return _mm_movemask_ps(_mm_cmpeq_ps(v1.data, v2.data)) != 0;
  }
 };


 template<qualifier Q>
 struct compute_vec4_equal<int, Q, true, 32, true>
 {
  static bool call(vec<4, int, Q> const& v1, vec<4, int, Q> const& v2)
  {

   __m128i neq = _mm_xor_si128(v1.data, v2.data);
   return _mm_testz_si128 ((neq), (neq)) == 0;
  }
 };


 template<qualifier Q>
 struct compute_vec4_nequal<float, Q, false, 32, true>
 {
  static bool call(vec<4, float, Q> const& v1, vec<4, float, Q> const& v2)
  {
   return _mm_movemask_ps(_mm_cmpneq_ps(v1.data, v2.data)) != 0;
  }
 };


 template<qualifier Q>
 struct compute_vec4_nequal<int, Q, true, 32, true>
 {
  static bool call(vec<4, int, Q> const& v1, vec<4, int, Q> const& v2)
  {

   __m128i neq = _mm_xor_si128(v1.data, v2.data);
   return _mm_testz_si128 ((neq), (neq)) != 0;
  }
 };

}

 template<>
 inline vec<4, float, aligned_lowp>::vec(float _s) :
  data(_mm_set1_ps(_s))
 {}

 template<>
 inline vec<4, float, aligned_mediump>::vec(float _s) :
  data(_mm_set1_ps(_s))
 {}

 template<>
 inline vec<4, float, aligned_highp>::vec(float _s) :
  data(_mm_set1_ps(_s))
 {}
# 379 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<>
 inline vec<4, int, aligned_lowp>::vec(int _s) :
  data(_mm_set1_epi32(_s))
 {}

 template<>
 inline vec<4, int, aligned_mediump>::vec(int _s) :
  data(_mm_set1_epi32(_s))
 {}

 template<>
 inline vec<4, int, aligned_highp>::vec(int _s) :
  data(_mm_set1_epi32(_s))
 {}
# 411 "include/glm/./ext/../detail/type_vec4_simd.inl"
 template<>
 inline vec<4, float, aligned_lowp>::vec(float _x, float _y, float _z, float _w) :
  data(_mm_set_ps(_w, _z, _y, _x))
 {}

 template<>
 inline vec<4, float, aligned_mediump>::vec(float _x, float _y, float _z, float _w) :
  data(_mm_set_ps(_w, _z, _y, _x))
 {}

 template<>
 inline vec<4, float, aligned_highp>::vec(float _x, float _y, float _z, float _w) :
  data(_mm_set_ps(_w, _z, _y, _x))
 {}

 template<>
 template<>
 inline vec<4, int, aligned_lowp>::vec(int _x, int _y, int _z, int _w) :
  data(_mm_set_epi32(_w, _z, _y, _x))
 {}

 template<>
 template<>
 inline vec<4, int, aligned_mediump>::vec(int _x, int _y, int _z, int _w) :
  data(_mm_set_epi32(_w, _z, _y, _x))
 {}

 template<>
 template<>
 inline vec<4, int, aligned_highp>::vec(int _x, int _y, int _z, int _w) :
  data(_mm_set_epi32(_w, _z, _y, _x))
 {}

 template<>
 template<>
 inline vec<4, float, aligned_lowp>::vec(int _x, int _y, int _z, int _w) :
  data(_mm_cvtepi32_ps(_mm_set_epi32(_w, _z, _y, _x)))
 {}

 template<>
 template<>
 inline vec<4, float, aligned_mediump>::vec(int _x, int _y, int _z, int _w) :
  data(_mm_cvtepi32_ps(_mm_set_epi32(_w, _z, _y, _x)))
 {}

 template<>
 template<>
 inline vec<4, float, aligned_highp>::vec(int _x, int _y, int _z, int _w) :
  data(_mm_cvtepi32_ps(_mm_set_epi32(_w, _z, _y, _x)))
 {}
}
# 1139 "include/glm/./ext/../detail/type_vec4.inl" 2
# 479 "include/glm/./ext/../detail/type_vec4.hpp" 2
# 5 "include/glm/./ext/vector_bool4.hpp" 2


namespace glm
{






 typedef vec<4, bool, defaultp> bvec4;


}
# 5 "include/glm/vec4.hpp" 2

# 1 "include/glm/./ext/vector_bool4_precision.hpp" 1






namespace glm
{







 typedef vec<4, bool, highp> highp_bvec4;





 typedef vec<4, bool, mediump> mediump_bvec4;





 typedef vec<4, bool, lowp> lowp_bvec4;


}
# 6 "include/glm/vec4.hpp" 2

# 1 "include/glm/./ext/vector_float4.hpp" 1






namespace glm
{






 typedef vec<4, float, defaultp> vec4;


}
# 7 "include/glm/vec4.hpp" 2

# 1 "include/glm/./ext/vector_float4_precision.hpp" 1






namespace glm
{







 typedef vec<4, float, highp> highp_vec4;





 typedef vec<4, float, mediump> mediump_vec4;





 typedef vec<4, float, lowp> lowp_vec4;


}
# 8 "include/glm/vec4.hpp" 2

# 1 "include/glm/./ext/vector_double4.hpp" 1






namespace glm
{






 typedef vec<4, double, defaultp> dvec4;


}
# 9 "include/glm/vec4.hpp" 2

# 1 "include/glm/./ext/vector_double4_precision.hpp" 1




# 1 "include/glm/./ext/../detail/setup.hpp" 1
# 5 "include/glm/./ext/vector_double4_precision.hpp" 2



namespace glm
{
# 18 "include/glm/./ext/vector_double4_precision.hpp"
 typedef vec<4, double, highp> highp_dvec4;






 typedef vec<4, double, mediump> mediump_dvec4;






 typedef vec<4, double, lowp> lowp_dvec4;


}
# 10 "include/glm/vec4.hpp" 2

# 1 "include/glm/./ext/vector_int4.hpp" 1






namespace glm
{






 typedef vec<4, int, defaultp> ivec4;


}
# 11 "include/glm/vec4.hpp" 2

# 1 "include/glm/./ext/vector_int4_precision.hpp" 1






namespace glm
{







 typedef vec<4, int, highp> highp_ivec4;





 typedef vec<4, int, mediump> mediump_ivec4;





 typedef vec<4, int, lowp> lowp_ivec4;


}
# 12 "include/glm/vec4.hpp" 2

# 1 "include/glm/./ext/vector_uint4.hpp" 1






namespace glm
{






 typedef vec<4, unsigned int, defaultp> uvec4;


}
# 13 "include/glm/vec4.hpp" 2

# 1 "include/glm/./ext/vector_uint4_precision.hpp" 1






namespace glm
{







 typedef vec<4, unsigned int, highp> highp_uvec4;





 typedef vec<4, unsigned int, mediump> mediump_uvec4;





 typedef vec<4, unsigned int, lowp> lowp_uvec4;


}
# 14 "include/glm/vec4.hpp" 2
# 15 "include/Simpleton/SDL/renderer.hpp" 2

# 1 "include/Simpleton/SDL/../Graphics 2D/load surface.hpp" 1
# 14 "include/Simpleton/SDL/../Graphics 2D/load surface.hpp"
# 1 "include/Simpleton/SDL/../Graphics 2D/surface.hpp" 1
# 15 "include/Simpleton/SDL/../Graphics 2D/surface.hpp"
namespace G2D {
  class Surface {
  public:
    using Byte = uint8_t;
    using Size = uint32_t;
    using BytesPerPixel = uint32_t;
    using Pitch = int32_t;
    using Data = std::unique_ptr<Byte>;

    Surface(Surface &&) = default;
    Surface &operator=(Surface &&) = default;

    Surface();
    Surface(Size, Size, BytesPerPixel);
    Surface(Size, Size, BytesPerPixel, Byte);
    Surface(Size, Size, BytesPerPixel, Pitch, Byte *);

    Byte *data();
    Byte *data(Size, Size);
    Byte *dataEnd();

    const Byte *data() const;
    const Byte *data(Size, Size) const;
    const Byte *dataEnd() const;

    size_t size() const;
    Pitch pitch() const;
    Size padding() const;

    Size width() const;
    Size widthBytes() const;
    Size height() const;

    BytesPerPixel bytesPerPixel() const;

  private:
    Data mData;
    Pitch mPitch;
    Size mWidth;
    Size mHeight;
    BytesPerPixel mBytesPerPixel;
  };
}


# 1 "include/Simpleton/SDL/../Graphics 2D/surface.inl" 1








# 1 "include/Simpleton/SDL/../Graphics 2D/../Memory/alloc.hpp" 1
# 16 "include/Simpleton/SDL/../Graphics 2D/../Memory/alloc.hpp"
namespace Memory {

  inline void *alloc(const size_t bytes) {
    return operator new(
      bytes, std::align_val_t{alignof(std::max_align_t)}
    );
  }


  inline std::byte *allocBytes(const size_t bytes) {
    return static_cast<std::byte *>(alloc(bytes));
  }


  template <typename Object>
  Object *allocObj() {
    return static_cast<Object *>(operator new(
      sizeof(Object), std::align_val_t{alignof(Object)}
    ));
  }


  template <typename Object>
  Object *allocArr(const size_t count) {
    return static_cast<Object *>(operator new(
      sizeof(Object) * count, std::align_val_t{alignof(Object)}
    ));
  }


  inline void dealloc(void *const ptr) {
    operator delete(ptr);
  }


  inline void *realloc(void *const ptr, const size_t oldSize, const size_t newSize) {
    void *const newPtr = alloc(newSize);
    std::memcpy(newPtr, ptr, oldSize < newSize ? oldSize : newSize);
    dealloc(ptr);
    return newPtr;
  }
}
# 10 "include/Simpleton/SDL/../Graphics 2D/surface.inl" 2

inline G2D::Surface::Surface()
  : mData(nullptr),
    mPitch(0),
    mWidth(0),
    mHeight(0),
    mBytesPerPixel(0) {}

inline G2D::Surface::Surface(const Size width, const Size height, const BytesPerPixel bpp)
  : mData(static_cast<Surface::Byte *>(Memory::alloc(width * height * bpp))),
    mPitch(width * bpp),
    mWidth(width),
    mHeight(height),
    mBytesPerPixel(bpp) {}

inline G2D::Surface::Surface(const Size width, const Size height, const BytesPerPixel bpp, const Byte byte)
  : Surface(width, height, bpp) {
  std::memset(mData.get(), byte, height * mPitch);
}

inline G2D::Surface::Surface(
  const Size width,
  const Size height,
  const BytesPerPixel bpp,
  const Pitch pitch,
  Byte *const data
) : mData(data),
    mPitch(pitch),
    mWidth(width),
    mHeight(height),
    mBytesPerPixel(bpp) {}

inline G2D::Surface::Byte *G2D::Surface::data() {
  return mData.get();
}

inline G2D::Surface::Byte *G2D::Surface::data(const Size x, const Size y) {
  return mData.get() + (y * mPitch + x * mBytesPerPixel);
}

inline G2D::Surface::Byte *G2D::Surface::dataEnd() {
  return mData.get() + (static_cast<Pitch>(mHeight) * mPitch);
}

inline const G2D::Surface::Byte *G2D::Surface::data() const {
  return mData.get();
}

inline const G2D::Surface::Byte *G2D::Surface::data(const Size x, const Size y) const {
  return mData.get() + (y * mPitch + x * mBytesPerPixel);
}

inline const G2D::Surface::Byte *G2D::Surface::dataEnd() const {
  return mData.get() + (static_cast<Pitch>(mHeight) * mPitch);
}

inline size_t G2D::Surface::size() const {
  return std::abs(static_cast<Pitch>(mHeight) * mPitch);
}

inline G2D::Surface::Pitch G2D::Surface::pitch() const {
  return mPitch;
}

inline G2D::Surface::Size G2D::Surface::padding() const {
  return mPitch - widthBytes();
}

inline G2D::Surface::Size G2D::Surface::width() const {
  return mWidth;
}

inline G2D::Surface::Size G2D::Surface::widthBytes() const {
  return mWidth * mBytesPerPixel;
}

inline G2D::Surface::Size G2D::Surface::height() const {
  return mHeight;
}

inline G2D::Surface::BytesPerPixel G2D::Surface::bytesPerPixel() const {
  return mBytesPerPixel;
}
# 60 "include/Simpleton/SDL/../Graphics 2D/surface.hpp" 2
# 15 "include/Simpleton/SDL/../Graphics 2D/load surface.hpp" 2

namespace G2D {
  class SurfaceLoadError final : public std::runtime_error {
  public:
    SurfaceLoadError(std::string_view, std::string_view);
  };


  Surface loadSurface(std::string_view);

  Surface loadSurface(std::string_view, int);

  Surface loadSurfaceRGB(std::string_view);

  Surface loadSurfaceRGBA(std::string_view);
}


# 1 "include/Simpleton/SDL/../Graphics 2D/load surface.inl" 1
# 11 "include/Simpleton/SDL/../Graphics 2D/load surface.inl"
# 1 "include/Simpleton/SDL/../Graphics 2D/../Memory/file io.hpp" 1
# 14 "include/Simpleton/SDL/../Graphics 2D/../Memory/file io.hpp"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/fstream" 1 3
# 176 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/fstream" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/__undef_macros" 1 3
# 180 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/fstream" 2 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_filebuf
    : public basic_streambuf<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename traits_type::state_type state_type;


    basic_filebuf();

    basic_filebuf(basic_filebuf&& __rhs);

    virtual ~basic_filebuf();



    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_filebuf& operator=(basic_filebuf&& __rhs);

    void swap(basic_filebuf& __rhs);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is_open() const;

    basic_filebuf* open(const char* __s, ios_base::openmode __mode);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_filebuf* open(const string& __s, ios_base::openmode __mode);

    basic_filebuf* close();

protected:

    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();
    virtual void imbue(const locale& __loc);

private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    FILE* __file_;
    const codecvt<char_type, char, state_type>* __cv_;
    state_type __st_;
    state_type __st_last_;
    ios_base::openmode __om_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;

    bool __read_mode();
    void __write_mode();
};

template <class _CharT, class _Traits>
basic_filebuf<_CharT, _Traits>::basic_filebuf()
    : __extbuf_(0),
      __extbufnext_(0),
      __extbufend_(0),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __file_(0),
      __cv_(nullptr),
      __st_(),
      __st_last_(),
      __om_(0),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(false)
{
    if (has_facet<codecvt<char_type, char, state_type> >(this->getloc()))
    {
        __cv_ = &use_facet<codecvt<char_type, char, state_type> >(this->getloc());
        __always_noconv_ = __cv_->always_noconv();
    }
    setbuf(0, 4096);
}



template <class _CharT, class _Traits>
basic_filebuf<_CharT, _Traits>::basic_filebuf(basic_filebuf&& __rhs)
    : basic_streambuf<_CharT, _Traits>(__rhs)
{
    if (__rhs.__extbuf_ == __rhs.__extbuf_min_)
    {
        __extbuf_ = __extbuf_min_;
        __extbufnext_ = __extbuf_ + (__rhs.__extbufnext_ - __rhs.__extbuf_);
        __extbufend_ = __extbuf_ + (__rhs.__extbufend_ - __rhs.__extbuf_);
    }
    else
    {
        __extbuf_ = __rhs.__extbuf_;
        __extbufnext_ = __rhs.__extbufnext_;
        __extbufend_ = __rhs.__extbufend_;
    }
    __ebs_ = __rhs.__ebs_;
    __intbuf_ = __rhs.__intbuf_;
    __ibs_ = __rhs.__ibs_;
    __file_ = __rhs.__file_;
    __cv_ = __rhs.__cv_;
    __st_ = __rhs.__st_;
    __st_last_ = __rhs.__st_last_;
    __om_ = __rhs.__om_;
    __cm_ = __rhs.__cm_;
    __owns_eb_ = __rhs.__owns_eb_;
    __owns_ib_ = __rhs.__owns_ib_;
    __always_noconv_ = __rhs.__always_noconv_;
    if (__rhs.pbase())
    {
        if (__rhs.pbase() == __rhs.__intbuf_)
            this->setp(__intbuf_, __intbuf_ + (__rhs. epptr() - __rhs.pbase()));
        else
            this->setp((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + (__rhs. epptr() - __rhs.pbase()));
        this->pbump(__rhs. pptr() - __rhs.pbase());
    }
    else if (__rhs.eback())
    {
        if (__rhs.eback() == __rhs.__intbuf_)
            this->setg(__intbuf_, __intbuf_ + (__rhs.gptr() - __rhs.eback()),
                                  __intbuf_ + (__rhs.egptr() - __rhs.eback()));
        else
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + (__rhs.gptr() - __rhs.eback()),
                       (char_type*)__extbuf_ + (__rhs.egptr() - __rhs.eback()));
    }
    __rhs.__extbuf_ = 0;
    __rhs.__extbufnext_ = 0;
    __rhs.__extbufend_ = 0;
    __rhs.__ebs_ = 0;
    __rhs.__intbuf_ = 0;
    __rhs.__ibs_ = 0;
    __rhs.__file_ = 0;
    __rhs.__st_ = state_type();
    __rhs.__st_last_ = state_type();
    __rhs.__om_ = 0;
    __rhs.__cm_ = 0;
    __rhs.__owns_eb_ = false;
    __rhs.__owns_ib_ = false;
    __rhs.setg(0, 0, 0);
    __rhs.setp(0, 0);
}

template <class _CharT, class _Traits>
inline
basic_filebuf<_CharT, _Traits>&
basic_filebuf<_CharT, _Traits>::operator=(basic_filebuf&& __rhs)
{
    close();
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_filebuf<_CharT, _Traits>::~basic_filebuf()
{

    try
    {

        close();

    }
    catch (...)
    {
    }

    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template <class _CharT, class _Traits>
void
basic_filebuf<_CharT, _Traits>::swap(basic_filebuf& __rhs)
{
    basic_streambuf<char_type, traits_type>::swap(__rhs);
    if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)
    {
        std::__1::swap(__extbuf_, __rhs.__extbuf_);
        std::__1::swap(__extbufnext_, __rhs.__extbufnext_);
        std::__1::swap(__extbufend_, __rhs.__extbufend_);
    }
    else
    {
        ptrdiff_t __ln = __extbufnext_ - __extbuf_;
        ptrdiff_t __le = __extbufend_ - __extbuf_;
        ptrdiff_t __rn = __rhs.__extbufnext_ - __rhs.__extbuf_;
        ptrdiff_t __re = __rhs.__extbufend_ - __rhs.__extbuf_;
        if (__extbuf_ == __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)
        {
            __extbuf_ = __rhs.__extbuf_;
            __rhs.__extbuf_ = __rhs.__extbuf_min_;
        }
        else if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ == __rhs.__extbuf_min_)
        {
            __rhs.__extbuf_ = __extbuf_;
            __extbuf_ = __extbuf_min_;
        }
        __extbufnext_ = __extbuf_ + __rn;
        __extbufend_ = __extbuf_ + __re;
        __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;
        __rhs.__extbufend_ = __rhs.__extbuf_ + __le;
    }
    std::__1::swap(__ebs_, __rhs.__ebs_);
    std::__1::swap(__intbuf_, __rhs.__intbuf_);
    std::__1::swap(__ibs_, __rhs.__ibs_);
    std::__1::swap(__file_, __rhs.__file_);
    std::__1::swap(__cv_, __rhs.__cv_);
    std::__1::swap(__st_, __rhs.__st_);
    std::__1::swap(__st_last_, __rhs.__st_last_);
    std::__1::swap(__om_, __rhs.__om_);
    std::__1::swap(__cm_, __rhs.__cm_);
    std::__1::swap(__owns_eb_, __rhs.__owns_eb_);
    std::__1::swap(__owns_ib_, __rhs.__owns_ib_);
    std::__1::swap(__always_noconv_, __rhs.__always_noconv_);
    if (this->eback() == (char_type*)__rhs.__extbuf_min_)
    {
        ptrdiff_t __n = this->gptr() - this->eback();
        ptrdiff_t __e = this->egptr() - this->eback();
        this->setg((char_type*)__extbuf_min_,
                   (char_type*)__extbuf_min_ + __n,
                   (char_type*)__extbuf_min_ + __e);
    }
    else if (this->pbase() == (char_type*)__rhs.__extbuf_min_)
    {
        ptrdiff_t __n = this->pptr() - this->pbase();
        ptrdiff_t __e = this->epptr() - this->pbase();
        this->setp((char_type*)__extbuf_min_,
                   (char_type*)__extbuf_min_ + __e);
        this->pbump(__n);
    }
    if (__rhs.eback() == (char_type*)__extbuf_min_)
    {
        ptrdiff_t __n = __rhs.gptr() - __rhs.eback();
        ptrdiff_t __e = __rhs.egptr() - __rhs.eback();
        __rhs.setg((char_type*)__rhs.__extbuf_min_,
                   (char_type*)__rhs.__extbuf_min_ + __n,
                   (char_type*)__rhs.__extbuf_min_ + __e);
    }
    else if (__rhs.pbase() == (char_type*)__extbuf_min_)
    {
        ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();
        ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();
        __rhs.setp((char_type*)__rhs.__extbuf_min_,
                   (char_type*)__rhs.__extbuf_min_ + __e);
        __rhs.pbump(__n);
    }
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(basic_filebuf<_CharT, _Traits>& __x, basic_filebuf<_CharT, _Traits>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits>
inline
bool
basic_filebuf<_CharT, _Traits>::is_open() const
{
    return __file_ != 0;
}


template <class _CharT, class _Traits>
basic_filebuf<_CharT, _Traits>*
basic_filebuf<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
{
    basic_filebuf<_CharT, _Traits>* __rt = 0;
    if (__file_ == 0)
    {
        __rt = this;
        const char* __mdstr;
        switch (__mode & ~ios_base::ate)
        {
        case ios_base::out:
        case ios_base::out | ios_base::trunc:
            __mdstr = "w";
            break;
        case ios_base::out | ios_base::app:
        case ios_base::app:
            __mdstr = "a";
            break;
        case ios_base::in:
            __mdstr = "r";
            break;
        case ios_base::in | ios_base::out:
            __mdstr = "r+";
            break;
        case ios_base::in | ios_base::out | ios_base::trunc:
            __mdstr = "w+";
            break;
        case ios_base::in | ios_base::out | ios_base::app:
        case ios_base::in | ios_base::app:
            __mdstr = "a+";
            break;
        case ios_base::out | ios_base::binary:
        case ios_base::out | ios_base::trunc | ios_base::binary:
            __mdstr = "wb";
            break;
        case ios_base::out | ios_base::app | ios_base::binary:
        case ios_base::app | ios_base::binary:
            __mdstr = "ab";
            break;
        case ios_base::in | ios_base::binary:
            __mdstr = "rb";
            break;
        case ios_base::in | ios_base::out | ios_base::binary:
            __mdstr = "r+b";
            break;
        case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:
            __mdstr = "w+b";
            break;
        case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:
        case ios_base::in | ios_base::app | ios_base::binary:
            __mdstr = "a+b";
            break;
        default:
            __rt = 0;
            break;
        }
        if (__rt)
        {
            __file_ = fopen(__s, __mdstr);
            if (__file_)
            {
                __om_ = __mode;
                if (__mode & ios_base::ate)
                {
                    if (fseek(__file_, 0, 2))
                    {
                        fclose(__file_);
                        __file_ = 0;
                        __rt = 0;
                    }
                }
            }
            else
                __rt = 0;
        }
    }
    return __rt;
}

template <class _CharT, class _Traits>
inline
basic_filebuf<_CharT, _Traits>*
basic_filebuf<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
{
    return open(__s.c_str(), __mode);
}


template <class _CharT, class _Traits>
basic_filebuf<_CharT, _Traits>*
basic_filebuf<_CharT, _Traits>::close()
{
    basic_filebuf<_CharT, _Traits>* __rt = 0;
    if (__file_)
    {
        __rt = this;
        unique_ptr<FILE, int(*)(FILE*)> __h(__file_, fclose);
        if (sync())
            __rt = 0;
        if (fclose(__h.release()) == 0)
            __file_ = 0;
        else
            __rt = 0;
    }
    return __rt;
}

template <class _CharT, class _Traits>
typename basic_filebuf<_CharT, _Traits>::int_type
basic_filebuf<_CharT, _Traits>::underflow()
{
    if (__file_ == 0)
        return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == 0)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            size_t __nmemb = static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = fread(this->eback() + __unget_sz, 1, __nmemb, __file_);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = traits_type::to_int_type(*this->gptr());
            }
        }
        else
        {
            ((void)0);
            if (__extbufend_ != __extbufnext_)
                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            size_t __nmemb = std::__1::min(static_cast<size_t>(__ibs_ - __unget_sz),
                                 static_cast<size_t>(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;
            __st_last_ = __st_;
            size_t __nr = fread((void*) const_cast<char *>(__extbufnext_), 1, __nmemb, __file_);
            if (__nr != 0)
            {
                if (!__cv_)
                    __throw_bad_cast();

                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->eback() + __ibs_, __inext);
                if (__r == codecvt_base::noconv)
                {
                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_,
                                          (char_type*)const_cast<char *>(__extbufend_));
                    __c = traits_type::to_int_type(*this->gptr());
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = traits_type::to_int_type(*this->gptr());
                }
            }
        }
    }
    else
        __c = traits_type::to_int_type(*this->gptr());
    if (this->eback() == &__1buf)
        this->setg(0, 0, 0);
    return __c;
}

template <class _CharT, class _Traits>
typename basic_filebuf<_CharT, _Traits>::int_type
basic_filebuf<_CharT, _Traits>::pbackfail(int_type __c)
{
    if (__file_ && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if ((__om_ & ios_base::out) ||
            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_filebuf<_CharT, _Traits>::int_type
basic_filebuf<_CharT, _Traits>::overflow(int_type __c)
{
    if (__file_ == 0)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this->pbase();
    char_type* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == 0)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
            if (fwrite(this->pbase(), sizeof(char_type), __nmemb, __file_) != __nmemb)
                return traits_type::eof();
        }
        else
        {
            char* __extbe = __extbuf_;
            codecvt_base::result __r;
            do
            {
                if (!__cv_)
                    __throw_bad_cast();

                const char_type* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (fwrite(this->pbase(), 1, __nmemb, __file_) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                    if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this->setp(const_cast<char_type*>(__e), this->pptr());
                        this->pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_filebuf<_CharT, _Traits>::setbuf(char_type* __s, streamsize __n)
{
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

template <class _CharT, class _Traits>
typename basic_filebuf<_CharT, _Traits>::pos_type
basic_filebuf<_CharT, _Traits>::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode)
{
    if (!__cv_)
        __throw_bad_cast();

    int __width = __cv_->encoding();
    if (__file_ == 0 || (__width <= 0 && __off != 0) || sync())
        return pos_type(off_type(-1));

    int __whence;
    switch (__way)
    {
    case ios_base::beg:
        __whence = 0;
        break;
    case ios_base::cur:
        __whence = 1;
        break;
    case ios_base::end:
        __whence = 2;
        break;
    default:
        return pos_type(off_type(-1));
    }





    if (fseeko(__file_, __width > 0 ? __width * __off : 0, __whence))
        return pos_type(off_type(-1));
    pos_type __r = ftello(__file_);

    __r.state(__st_);
    return __r;
}

template <class _CharT, class _Traits>
typename basic_filebuf<_CharT, _Traits>::pos_type
basic_filebuf<_CharT, _Traits>::seekpos(pos_type __sp, ios_base::openmode)
{
    if (__file_ == 0 || sync())
        return pos_type(off_type(-1));




    if (fseeko(__file_, __sp, 0))
        return pos_type(off_type(-1));

    __st_ = __sp.state();
    return __sp;
}

template <class _CharT, class _Traits>
int
basic_filebuf<_CharT, _Traits>::sync()
{
    if (__file_ == 0)
        return 0;
    if (!__cv_)
        __throw_bad_cast();

    if (__cm_ & ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);
            if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (fflush(__file_))
            return -1;
    }
    else if (__cm_ & ios_base::in)
    {
        off_type __c;
        state_type __state = __st_last_;
        bool __update_st = false;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    const int __off = __cv_->length(__state, __extbuf_,
                                                     __extbufnext_,
                                                     this->gptr() - this->eback());
                    __c += __extbufnext_ - __extbuf_ - __off;
                    __update_st = true;
                }
            }
        }




        if (fseeko(__file_, -__c, 1))
            return -1;

        if (__update_st)
            __st_ = __state;
        __extbufnext_ = __extbufend_ = __extbuf_;
        this->setg(0, 0, 0);
        __cm_ = 0;
    }
    return 0;
}

template <class _CharT, class _Traits>
void
basic_filebuf<_CharT, _Traits>::imbue(const locale& __loc)
{
    sync();
    __cv_ = &use_facet<codecvt<char_type, char, state_type> >(__loc);
    bool __old_anc = __always_noconv_;
    __always_noconv_ = __cv_->always_noconv();
    if (__old_anc != __always_noconv_)
    {
        this->setg(0, 0, 0);
        this->setp(0, 0);

        if (__always_noconv_)
        {
            if (__owns_eb_)
                delete [] __extbuf_;
            __owns_eb_ = __owns_ib_;
            __ebs_ = __ibs_;
            __extbuf_ = (char*)__intbuf_;
            __ibs_ = 0;
            __intbuf_ = 0;
            __owns_ib_ = false;
        }
        else
        {
            if (!__owns_eb_ && __extbuf_ != __extbuf_min_)
            {
                __ibs_ = __ebs_;
                __intbuf_ = (char_type*)__extbuf_;
                __owns_ib_ = false;
                __extbuf_ = new char[__ebs_];
                __owns_eb_ = true;
            }
            else
            {
                __ibs_ = __ebs_;
                __intbuf_ = new char_type[__ibs_];
                __owns_ib_ = true;
            }
        }
    }
}

template <class _CharT, class _Traits>
bool
basic_filebuf<_CharT, _Traits>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
        this->setp(0, 0);
        if (__always_noconv_)
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template <class _CharT, class _Traits>
void
basic_filebuf<_CharT, _Traits>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
        this->setg(0, 0, 0);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(0, 0);
        __cm_ = ios_base::out;
    }
}



template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ifstream
    : public basic_istream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ifstream();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit basic_ifstream(const string& __s, ios_base::openmode __mode = ios_base::in);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ifstream(basic_ifstream&& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ifstream& operator=(basic_ifstream&& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_ifstream& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_filebuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is_open() const;

    void open(const char* __s, ios_base::openmode __mode = ios_base::in);
    void open(const string& __s, ios_base::openmode __mode = ios_base::in);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void close();

private:
    basic_filebuf<char_type, traits_type> __sb_;
};

template <class _CharT, class _Traits>
inline
basic_ifstream<_CharT, _Traits>::basic_ifstream()
    : basic_istream<char_type, traits_type>(&__sb_)
{
}


template <class _CharT, class _Traits>
inline
basic_ifstream<_CharT, _Traits>::basic_ifstream(const char* __s, ios_base::openmode __mode)
    : basic_istream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode | ios_base::in) == 0)
        this->setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
inline
basic_ifstream<_CharT, _Traits>::basic_ifstream(const string& __s, ios_base::openmode __mode)
    : basic_istream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode | ios_base::in) == 0)
        this->setstate(ios_base::failbit);
}




template <class _CharT, class _Traits>
inline
basic_ifstream<_CharT, _Traits>::basic_ifstream(basic_ifstream&& __rhs)
    : basic_istream<char_type, traits_type>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_))
{
    this->set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits>
inline
basic_ifstream<_CharT, _Traits>&
basic_ifstream<_CharT, _Traits>::operator=(basic_ifstream&& __rhs)
{
    basic_istream<char_type, traits_type>::operator=(std::__1::move(__rhs));
    __sb_ = std::__1::move(__rhs.__sb_);
    return *this;
}



template <class _CharT, class _Traits>
inline
void
basic_ifstream<_CharT, _Traits>::swap(basic_ifstream& __rhs)
{
    basic_istream<char_type, traits_type>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(basic_ifstream<_CharT, _Traits>& __x, basic_ifstream<_CharT, _Traits>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits>
inline
basic_filebuf<_CharT, _Traits>*
basic_ifstream<_CharT, _Traits>::rdbuf() const
{
    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);
}

template <class _CharT, class _Traits>
inline
bool
basic_ifstream<_CharT, _Traits>::is_open() const
{
    return __sb_.is_open();
}


template <class _CharT, class _Traits>
void
basic_ifstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode | ios_base::in))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
void
basic_ifstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode | ios_base::in))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}


template <class _CharT, class _Traits>
inline
void
basic_ifstream<_CharT, _Traits>::close()
{
    if (__sb_.close() == 0)
        this->setstate(ios_base::failbit);
}



template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ofstream
    : public basic_ostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ofstream();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit basic_ofstream(const char* __s, ios_base::openmode __mode = ios_base::out);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit basic_ofstream(const string& __s, ios_base::openmode __mode = ios_base::out);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ofstream(basic_ofstream&& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ofstream& operator=(basic_ofstream&& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_ofstream& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_filebuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is_open() const;

    void open(const char* __s, ios_base::openmode __mode = ios_base::out);
    void open(const string& __s, ios_base::openmode __mode = ios_base::out);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void close();

private:
    basic_filebuf<char_type, traits_type> __sb_;
};

template <class _CharT, class _Traits>
inline
basic_ofstream<_CharT, _Traits>::basic_ofstream()
    : basic_ostream<char_type, traits_type>(&__sb_)
{
}


template <class _CharT, class _Traits>
inline
basic_ofstream<_CharT, _Traits>::basic_ofstream(const char* __s, ios_base::openmode __mode)
    : basic_ostream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode | ios_base::out) == 0)
        this->setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
inline
basic_ofstream<_CharT, _Traits>::basic_ofstream(const string& __s, ios_base::openmode __mode)
    : basic_ostream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode | ios_base::out) == 0)
        this->setstate(ios_base::failbit);
}




template <class _CharT, class _Traits>
inline
basic_ofstream<_CharT, _Traits>::basic_ofstream(basic_ofstream&& __rhs)
    : basic_ostream<char_type, traits_type>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_))
{
    this->set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits>
inline
basic_ofstream<_CharT, _Traits>&
basic_ofstream<_CharT, _Traits>::operator=(basic_ofstream&& __rhs)
{
    basic_ostream<char_type, traits_type>::operator=(std::__1::move(__rhs));
    __sb_ = std::__1::move(__rhs.__sb_);
    return *this;
}



template <class _CharT, class _Traits>
inline
void
basic_ofstream<_CharT, _Traits>::swap(basic_ofstream& __rhs)
{
    basic_ostream<char_type, traits_type>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(basic_ofstream<_CharT, _Traits>& __x, basic_ofstream<_CharT, _Traits>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits>
inline
basic_filebuf<_CharT, _Traits>*
basic_ofstream<_CharT, _Traits>::rdbuf() const
{
    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);
}

template <class _CharT, class _Traits>
inline
bool
basic_ofstream<_CharT, _Traits>::is_open() const
{
    return __sb_.is_open();
}


template <class _CharT, class _Traits>
void
basic_ofstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode | ios_base::out))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
void
basic_ofstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode | ios_base::out))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}


template <class _CharT, class _Traits>
inline
void
basic_ofstream<_CharT, _Traits>::close()
{
    if (__sb_.close() == 0)
        this->setstate(ios_base::failbit);
}



template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_fstream
    : public basic_iostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_fstream();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit basic_fstream(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit basic_fstream(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_fstream(basic_fstream&& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_fstream& operator=(basic_fstream&& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_fstream& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_filebuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is_open() const;

    void open(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);
    void open(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void close();

private:
    basic_filebuf<char_type, traits_type> __sb_;
};

template <class _CharT, class _Traits>
inline
basic_fstream<_CharT, _Traits>::basic_fstream()
    : basic_iostream<char_type, traits_type>(&__sb_)
{
}


template <class _CharT, class _Traits>
inline
basic_fstream<_CharT, _Traits>::basic_fstream(const char* __s, ios_base::openmode __mode)
    : basic_iostream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode) == 0)
        this->setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
inline
basic_fstream<_CharT, _Traits>::basic_fstream(const string& __s, ios_base::openmode __mode)
    : basic_iostream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode) == 0)
        this->setstate(ios_base::failbit);
}




template <class _CharT, class _Traits>
inline
basic_fstream<_CharT, _Traits>::basic_fstream(basic_fstream&& __rhs)
    : basic_iostream<char_type, traits_type>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_))
{
    this->set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits>
inline
basic_fstream<_CharT, _Traits>&
basic_fstream<_CharT, _Traits>::operator=(basic_fstream&& __rhs)
{
    basic_iostream<char_type, traits_type>::operator=(std::__1::move(__rhs));
    __sb_ = std::__1::move(__rhs.__sb_);
    return *this;
}



template <class _CharT, class _Traits>
inline
void
basic_fstream<_CharT, _Traits>::swap(basic_fstream& __rhs)
{
    basic_iostream<char_type, traits_type>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(basic_fstream<_CharT, _Traits>& __x, basic_fstream<_CharT, _Traits>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits>
inline
basic_filebuf<_CharT, _Traits>*
basic_fstream<_CharT, _Traits>::rdbuf() const
{
    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);
}

template <class _CharT, class _Traits>
inline
bool
basic_fstream<_CharT, _Traits>::is_open() const
{
    return __sb_.is_open();
}


template <class _CharT, class _Traits>
void
basic_fstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
void
basic_fstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}


template <class _CharT, class _Traits>
inline
void
basic_fstream<_CharT, _Traits>::close()
{
    if (__sb_.close() == 0)
        this->setstate(ios_base::failbit);
}

} }
# 15 "include/Simpleton/SDL/../Graphics 2D/../Memory/file io.hpp" 2
# 1 "include/Simpleton/SDL/../Graphics 2D/../Memory/buffer.hpp" 1
# 14 "include/Simpleton/SDL/../Graphics 2D/../Memory/buffer.hpp"
namespace Memory {
  class Zero {};
  class One {};

  constexpr Zero ZERO_INIT {};
  constexpr One ONE_INIT {};

  class Buffer {
  public:
    explicit Buffer(size_t);
    Buffer(size_t, Zero);
    Buffer(size_t, One);
    Buffer(size_t, std::byte);

    Buffer(Buffer &&);
    Buffer &operator=(Buffer &&);
    ~Buffer();

    bool operator==(const Buffer &) const;
    bool operator!=(const Buffer &) const;
    bool operator<(const Buffer &) const;

    void swap(Buffer &);
    void copyFrom(const Buffer &);
    void resize(size_t);
    void resizeCopy(size_t);

    template <typename T = std::byte>
    T *data() {
      return reinterpret_cast<T *>(mData);
    }
    template <typename T = std::byte>
    const T *data() const {
      return reinterpret_cast<const T *>(mData);
    }
    template <typename T = std::byte>
    const T *cdata() const {
      return reinterpret_cast<const T *>(mData);
    }

    template <typename T = size_t>
    T size() const {
      return static_cast<T>(mSize);
    }

    template <typename T = std::byte>
    T *begin() {
      return reinterpret_cast<T *>(mData);
    }
    template <typename T = std::byte>
    T *end() {
      return reinterpret_cast<T *>(mData + mSize);
    }

    template <typename T = std::byte>
    const T *begin() const {
      return reinterpret_cast<const T *>(mData);
    }
    template <typename T = std::byte>
    const T *end() const {
      return reinterpret_cast<const T *>(mData + mSize);
    }

    template <typename T = std::byte>
    const T *cbegin() const {
      return reinterpret_cast<const T *>(mData);
    }
    template <typename T = std::byte>
    const T *cend() const {
      return reinterpret_cast<const T *>(mData + mSize);
    }

  private:
    std::byte *mData;
    size_t mSize;
  };
}


# 1 "include/Simpleton/SDL/../Graphics 2D/../Memory/buffer.inl" 1








inline Memory::Buffer::Buffer(const size_t size)
  : mData{allocBytes(size)}, mSize{size} {}

inline Memory::Buffer::Buffer(const size_t size, Zero)
  : mData{allocBytes(size)}, mSize{size} {
  std::memset(data(), 0, mSize);
}

inline Memory::Buffer::Buffer(const size_t size, One)
  : mData{allocBytes(size)}, mSize{size} {
  std::memset(data(), static_cast<int>(~std::byte{}), mSize);
}

inline Memory::Buffer::Buffer(const size_t size, const std::byte byte)
  : mData{allocBytes(size)}, mSize{size} {
  std::memset(data(), static_cast<int>(byte), mSize);
}

inline Memory::Buffer::Buffer(Buffer &&other)
  : mData{std::exchange(other.mData, nullptr)},
    mSize{std::exchange(other.mSize, 0)} {}

inline Memory::Buffer &Memory::Buffer::operator=(Buffer &&other) {
  dealloc(mData);
  mData = std::exchange(other.mData, nullptr);
  mSize = std::exchange(other.mSize, 0);
  return *this;
}

inline Memory::Buffer::~Buffer() {
  dealloc(mData);
}

inline bool Memory::Buffer::operator==(const Buffer &other) const {
  return mSize == other.mSize && std::memcmp(mData, other.mData, mSize) == 0;
}

inline bool Memory::Buffer::operator!=(const Buffer &other) const {
  return mSize != other.mSize || std::memcmp(mData, other.mData, mSize) != 0;
}

inline bool Memory::Buffer::operator<(const Buffer &other) const {
  if (mSize < other.mSize) {
    return true;
  } else if (other.mSize < mSize) {
    return false;
  } else {
    return std::memcmp(mData, other.mData, mSize) < 0;
  }
}

inline void Memory::Buffer::swap(Buffer &other) {
  std::swap(mData, other.mData);
  std::swap(mSize, other.mSize);
}

inline void Memory::Buffer::copyFrom(const Buffer &buffer) {
  std::memcpy(mData, buffer.mData, mSize < buffer.mSize ? mSize : buffer.mSize);
}

inline void Memory::Buffer::resize(const size_t size) {
  dealloc(mData);
  mData = allocBytes(size);
  mSize = size;
}

inline void Memory::Buffer::resizeCopy(const size_t size) {
  std::byte *const temp = allocBytes(size);
  std::memcpy(temp, mData, mSize < size ? mSize : size);
  dealloc(mData);
  mData = temp;
  mSize = size;
}
# 93 "include/Simpleton/SDL/../Graphics 2D/../Memory/buffer.hpp" 2
# 16 "include/Simpleton/SDL/../Graphics 2D/../Memory/file io.hpp" 2


namespace Memory {
  class FileError final : public std::runtime_error {
  public:
    explicit FileError(const char *);
  };

  struct FileCloser {
    void operator()(std::FILE *const file) const noexcept {
      std::fclose(file);
    }
  };

  using FileHandle = std::unique_ptr<std::FILE, FileCloser>;

  static_assert(sizeof(FileHandle) == sizeof(std::FILE *));

  FileHandle openFileRead(const char *);
  FileHandle openFileWrite(const char *);

  FileHandle openFileRead(std::string_view);
  FileHandle openFileWrite(std::string_view);

  size_t sizeOfFile(std::FILE *);

  void readFile(void *, size_t, std::FILE *);
  void writeFile(const void *, size_t, std::FILE *);

  Buffer readFile(std::string_view);
  Buffer readFile(const std::string &);
  Buffer readFile(const char *);
  Buffer readFile(std::FILE *);
  Buffer readFile(std::ifstream &);

  void writeFile(const Buffer &, std::string_view);
  void writeFile(const Buffer &, const std::string &);
  void writeFile(const Buffer &, const char *);
  void writeFile(const Buffer &, std::FILE *);
  void writeFile(const Buffer &, std::ofstream &);
}


# 1 "include/Simpleton/SDL/../Graphics 2D/../Memory/file io.inl" 1








inline Memory::FileError::FileError(const char *const what)
  : std::runtime_error(what) {}

inline Memory::FileHandle Memory::openFileRead(const char *const path) {
  (__builtin_expect(!(path), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/../Memory/file io.inl", 13, "path") : (void)0);
  std::FILE *const file = std::fopen(path, "rb");
  if (file == nullptr) {
    throw FileError("Failed to open file for reading");
  } else {
    return {file, {}};
  }
}

inline Memory::FileHandle Memory::openFileWrite(const char *const path) {
  (__builtin_expect(!(path), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/../Memory/file io.inl", 23, "path") : (void)0);
  std::FILE *const file = std::fopen(path, "wb");
  if (file == nullptr) {
    throw FileError("Failed to open file for writing");
  } else {
    return {file, {}};
  }
}

inline Memory::FileHandle Memory::openFileRead(const std::string_view path) {

  static std::string temp;
  temp.reserve(path.size());
  temp.clear();
  temp.append(path.data(), path.size());
  return openFileRead(temp.c_str());
}

inline Memory::FileHandle Memory::openFileWrite(const std::string_view path) {

  static std::string temp;
  temp.reserve(path.size());
  temp.clear();
  temp.append(path.data(), path.size());
  return openFileWrite(temp.c_str());
}

inline size_t Memory::sizeOfFile(std::FILE *const file) {
  if (std::fseek(file, 0, 2) != 0) {
    throw FileError("Failed to seek to end of file");
  }
  const long fileSize = std::ftell(file);
  if (fileSize == long(-1)) {
    throw FileError("Failed to get size of file");
  }
  std::rewind(file);
  return fileSize;
}

inline void Memory::readFile(void *const data, const size_t size, std::FILE *const file) {
  if (std::fread(data, size, 1, file) == 0) {
    throw FileError("Failed to read from file");
  }
}

inline void Memory::writeFile(const void *const data, const size_t size, std::FILE *const file) {
  if (std::fwrite(data, size, 1, file) == 0) {
    throw FileError("Failed to write to file");
  }
  if (std::fflush(file) != 0) {
    throw FileError("Failed to flush file after writing");
  }
}

inline Memory::Buffer Memory::readFile(const std::string_view path) {
  return readFile(std::string(path));
}

inline Memory::Buffer Memory::readFile(const std::string &path) {
  return readFile(path.c_str());
}

inline Memory::Buffer Memory::readFile(const char *const path) {
  return readFile(openFileRead(path).get());
}

inline Memory::Buffer Memory::readFile(std::FILE *const file) {
  Memory::Buffer buf(sizeOfFile(file));
  readFile(buf.data(), buf.size(), file);
  return buf;
}

inline Memory::Buffer Memory::readFile(std::ifstream &stream) {
  stream.seekg(0, std::ios::end);
  Memory::Buffer buf(stream.tellg());
  stream.seekg(0, std::ios::beg);
  stream.read(buf.data<std::ifstream::char_type>(), buf.size());
  if (stream.good()) {
    return buf;
  } else {
    throw FileError("Failed to read from input stream");
  }
}

inline void Memory::writeFile(const Memory::Buffer &buf, const std::string_view path) {
  writeFile(buf, std::string(path));
}

inline void Memory::writeFile(const Memory::Buffer &buf, const std::string &path) {
  writeFile(buf, path.c_str());
}

inline void Memory::writeFile(const Memory::Buffer &buf, const char *const path) {
  writeFile(buf, openFileWrite(path).get());
}

inline void Memory::writeFile(const Memory::Buffer &buf, std::FILE *const file) {
  if (std::fwrite(buf.data(), buf.size(), 1, file) == 0) {
    throw FileError("Failed to write to file");
  }
  if (std::fflush(file) != 0) {
    throw FileError("Failed to flush file after writing");
  }
}

inline void Memory::writeFile(const Memory::Buffer &buf, std::ofstream &stream) {
  stream.write(buf.data<std::ofstream::char_type>(), buf.size<std::streamsize>());
  stream.flush();
  if (!stream.good()) {
    throw FileError("Failed to write to output stream");
  }
}
# 59 "include/Simpleton/SDL/../Graphics 2D/../Memory/file io.hpp" 2
# 12 "include/Simpleton/SDL/../Graphics 2D/load surface.inl" 2
# 21 "include/Simpleton/SDL/../Graphics 2D/load surface.inl"
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wcomma"
#pragma clang diagnostic ignored "-Wunused-function"


# 1 "include/Simpleton/SDL/../Graphics 2D/stb_image.h" 1
# 307 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdio.h" 1 3
# 308 "include/Simpleton/SDL/../Graphics 2D/stb_image.h" 2




enum
{
   STBI_default = 0,

   STBI_grey = 1,
   STBI_grey_alpha = 2,
   STBI_rgb = 3,
   STBI_rgb_alpha = 4
};

typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;


extern "C" {
# 344 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
typedef struct
{
   int (*read) (void *user,char *data,int size);
   void (*skip) (void *user,int n);
   int (*eof) (void *user);
} stbi_io_callbacks;






static stbi_uc *stbi_load_from_memory (stbi_uc const *buffer, int len , int *x, int *y, int *channels_in_file, int desired_channels);
static stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk , void *user, int *x, int *y, int *channels_in_file, int desired_channels);






static stbi_uc *stbi_load (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
static stbi_uc *stbi_load_from_file (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
# 374 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static stbi_us *stbi_load_16_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
static stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);


static stbi_us *stbi_load_16 (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
static stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);







   static float *stbi_loadf_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
   static float *stbi_loadf_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);


   static float *stbi_loadf (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
   static float *stbi_loadf_from_file (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);




   static void stbi_hdr_to_ldr_gamma(float gamma);
   static void stbi_hdr_to_ldr_scale(float scale);



   static void stbi_ldr_to_hdr_gamma(float gamma);
   static void stbi_ldr_to_hdr_scale(float scale);



static int stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
static int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);

static int stbi_is_hdr (char const *filename);
static int stbi_is_hdr_from_file(FILE *f);





static const char *stbi_failure_reason (void);


static void stbi_image_free (void *retval_from_stbi_load);


static int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
static int stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
static int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
static int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);


static int stbi_info (char const *filename, int *x, int *y, int *comp);
static int stbi_info_from_file (FILE *f, int *x, int *y, int *comp);
static int stbi_is_16_bit (char const *filename);
static int stbi_is_16_bit_from_file(FILE *f);







static void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);



static void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);


static void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);



static char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
static char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
static char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
static int stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

static char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
static int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);



}
# 510 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stddef.h" 1 3
# 511 "include/Simpleton/SDL/../Graphics 2D/stb_image.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdlib.h" 1 3
# 512 "include/Simpleton/SDL/../Graphics 2D/stb_image.h" 2








# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdio.h" 1 3
# 521 "include/Simpleton/SDL/../Graphics 2D/stb_image.h" 2



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 2 3 4
# 75 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn)) __attribute__((__disable_tail_calls__));



}
# 525 "include/Simpleton/SDL/../Graphics 2D/stb_image.h" 2
# 547 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
typedef uint16_t stbi__uint16;
typedef int16_t stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t stbi__int32;



typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];
# 660 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static int stbi__sse2_available(void)
{



   return 1;
}
# 691 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
typedef struct
{
   stbi__uint32 img_x, img_y;
   int img_n, img_out_n;

   stbi_io_callbacks io;
   void *io_user_data;

   int read_from_callbacks;
   int buflen;
   stbi_uc buffer_start[128];

   stbi_uc *img_buffer, *img_buffer_end;
   stbi_uc *img_buffer_original, *img_buffer_original_end;
} stbi__context;


static void stbi__refill_buffer(stbi__context *s);


static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = __null;
   s->read_from_callbacks = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}


static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}



static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}

static void stbi__stdio_skip(void *user, int n)
{
   fseek((FILE*) user, n, 1);
}

static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}





static void stbi__rewind(stbi__context *s)
{



   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}

enum
{
   STBI_ORDER_RGB,
   STBI_ORDER_BGR
};

typedef struct
{
   int bits_per_channel;
   int num_channels;
   int channel_order;
} stbi__result_info;


static int stbi__jpeg_test(stbi__context *s);
static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);



static int stbi__png_test(stbi__context *s);
static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
static int stbi__png_is16(stbi__context *s);



static int stbi__bmp_test(stbi__context *s);
static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);



static int stbi__tga_test(stbi__context *s);
static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);



static int stbi__psd_test(stbi__context *s);
static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
static int stbi__psd_is16(stbi__context *s);



static int stbi__hdr_test(stbi__context *s);
static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);



static int stbi__pic_test(stbi__context *s);
static void *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
# 838 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static int stbi__pnm_test(stbi__context *s);
static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);



static const char *stbi__g_failure_reason;

static const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}

static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}

static void *stbi__malloc(size_t size)
{
    return Memory::alloc(size);
}
# 874 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;




   return a <= 2147483647 - b;
}



static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1;

   return a <= 2147483647/b;
}


static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}


static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}



static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}



static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return __null;
   return stbi__malloc(a*b + add);
}

static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return __null;
   return stbi__malloc(a*b*c + add);
}


static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return __null;
   return stbi__malloc(a*b*c*d + add);
}
# 952 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static void stbi_image_free(void *retval_from_stbi_load)
{
   Memory::dealloc(retval_from_stbi_load);
}


static float *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);



static stbi_uc *stbi__hdr_to_ldr(float *data, int x, int y, int comp);


static int stbi__vertically_flip_on_load = 0;

static void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
    stbi__vertically_flip_on_load = flag_true_if_should_flip;
}

static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri));
   ri->bits_per_channel = 8;
   ri->channel_order = STBI_ORDER_RGB;
   ri->num_channels = 0;


   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);


   if (stbi__png_test(s)) return stbi__png_load(s,x,y,comp,req_comp, ri);


   if (stbi__bmp_test(s)) return stbi__bmp_load(s,x,y,comp,req_comp, ri);





   if (stbi__psd_test(s)) return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);


   if (stbi__pic_test(s)) return stbi__pic_load(s,x,y,comp,req_comp, ri);


   if (stbi__pnm_test(s)) return stbi__pnm_load(s,x,y,comp,req_comp, ri);



   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }




   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);


   return ((unsigned char *)(size_t) (stbi__err("Image not of any known type, or corrupt")?__null:__null));
}

static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == __null) return ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null));

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF);

   Memory::dealloc(orig);
   return reduced;
}

static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == __null) return (stbi__uint16 *) ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null));

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]);

   Memory::dealloc(orig);
   return enlarged;
}

static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;

      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}

static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) {
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
      bytes += slice_size;
   }
}

static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == __null)
      return __null;

   if (ri.bits_per_channel != 8) {
      (__builtin_expect(!(ri.bits_per_channel == 16), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 1094, "ri.bits_per_channel == 16") : (void)0);
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }



   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}

static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == __null)
      return __null;

   if (ri.bits_per_channel != 16) {
      (__builtin_expect(!(ri.bits_per_channel == 8), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 1118, "ri.bits_per_channel == 8") : (void)0);
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }




   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}


static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != __null) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}




static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;




   f = fopen(filename, mode);

   return f;
}


static stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   unsigned char *result;
   if (!f) return ((unsigned char *)(size_t) (stbi__err("Unable to open file")?__null:__null));
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

static stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {

      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), 1);
   }
   return result;
}

static stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {

      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), 1);
   }
   return result;
}

static stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) ((unsigned char *)(size_t) (stbi__err("Unable to open file")?__null:__null));
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}




static stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

static stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

static stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

static stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}
# 1253 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;

   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }

   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return ((float *)(size_t) (stbi__err("Image not of any known type, or corrupt")?__null:__null));
}

static float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

static float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}


static float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, "rb");
   if (!f) return ((float *)(size_t) (stbi__err("Unable to open file")?__null:__null));
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

static float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}
# 1310 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{

   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);





}


static int stbi_is_hdr (char const *filename)
{
   FILE *f = stbi__fopen(filename, "rb");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}

static int stbi_is_hdr_from_file(FILE *f)
{

   long pos = ftell(f);
   int res;
   stbi__context s;
   stbi__start_file(&s,f);
   res = stbi__hdr_test(&s);
   fseek(f, pos, 0);
   return res;




}


static int stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{

   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);





}


static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;

static void stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
static void stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }


static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;

static void stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
static void stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }







enum
{
   STBI__SCAN_load=0,
   STBI__SCAN_type,
   STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   if (n == 0) {


      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}

inline static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}

inline static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;


      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}

static void stbi__skip(stbi__context *s, int n)
{
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}

static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}

static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}

static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}




static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}



static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   return z + (stbi__get16le(s) << 16);
}
# 1514 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) + (29*b)) >> 8);
}

static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   (__builtin_expect(!(req_comp >= 1 && req_comp <= 4), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 1525, "req_comp >= 1 && req_comp <= 4") : (void)0);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == __null) {
      Memory::dealloc(data);
      return ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null));
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src = data + j * x * img_n ;
      unsigned char *dest = good + j * x * req_comp;





      switch (((img_n)*8+(req_comp))) {
         case ((1)*8+(2)): for(i=x-1; i >= 0; --i, src += 1, dest += 2) { dest[0]=src[0], dest[1]=255; } break;
         case ((1)*8+(3)): for(i=x-1; i >= 0; --i, src += 1, dest += 3) { dest[0]=dest[1]=dest[2]=src[0]; } break;
         case ((1)*8+(4)): for(i=x-1; i >= 0; --i, src += 1, dest += 4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=255; } break;
         case ((2)*8+(1)): for(i=x-1; i >= 0; --i, src += 2, dest += 1) { dest[0]=src[0]; } break;
         case ((2)*8+(3)): for(i=x-1; i >= 0; --i, src += 2, dest += 3) { dest[0]=dest[1]=dest[2]=src[0]; } break;
         case ((2)*8+(4)): for(i=x-1; i >= 0; --i, src += 2, dest += 4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1]; } break;
         case ((3)*8+(4)): for(i=x-1; i >= 0; --i, src += 3, dest += 4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255; } break;
         case ((3)*8+(1)): for(i=x-1; i >= 0; --i, src += 3, dest += 1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); } break;
         case ((3)*8+(2)): for(i=x-1; i >= 0; --i, src += 3, dest += 2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = 255; } break;
         case ((4)*8+(1)): for(i=x-1; i >= 0; --i, src += 4, dest += 1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); } break;
         case ((4)*8+(2)): for(i=x-1; i >= 0; --i, src += 4, dest += 2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = src[3]; } break;
         case ((4)*8+(3)): for(i=x-1; i >= 0; --i, src += 4, dest += 3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2]; } break;
         default: (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 1554, "0") : (void)0);
      }

   }

   Memory::dealloc(data);
   return good;
}

static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) + (29*b)) >> 8);
}

static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   (__builtin_expect(!(req_comp >= 1 && req_comp <= 4), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 1574, "req_comp >= 1 && req_comp <= 4") : (void)0);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == __null) {
      Memory::dealloc(data);
      return (stbi__uint16 *) ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null));
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src = data + j * x * img_n ;
      stbi__uint16 *dest = good + j * x * req_comp;





      switch (((img_n)*8+(req_comp))) {
         case ((1)*8+(2)): for(i=x-1; i >= 0; --i, src += 1, dest += 2) { dest[0]=src[0], dest[1]=0xffff; } break;
         case ((1)*8+(3)): for(i=x-1; i >= 0; --i, src += 1, dest += 3) { dest[0]=dest[1]=dest[2]=src[0]; } break;
         case ((1)*8+(4)): for(i=x-1; i >= 0; --i, src += 1, dest += 4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=0xffff; } break;
         case ((2)*8+(1)): for(i=x-1; i >= 0; --i, src += 2, dest += 1) { dest[0]=src[0]; } break;
         case ((2)*8+(3)): for(i=x-1; i >= 0; --i, src += 2, dest += 3) { dest[0]=dest[1]=dest[2]=src[0]; } break;
         case ((2)*8+(4)): for(i=x-1; i >= 0; --i, src += 2, dest += 4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1]; } break;
         case ((3)*8+(4)): for(i=x-1; i >= 0; --i, src += 3, dest += 4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=0xffff; } break;
         case ((3)*8+(1)): for(i=x-1; i >= 0; --i, src += 3, dest += 1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); } break;
         case ((3)*8+(2)): for(i=x-1; i >= 0; --i, src += 3, dest += 2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = 0xffff; } break;
         case ((4)*8+(1)): for(i=x-1; i >= 0; --i, src += 4, dest += 1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); } break;
         case ((4)*8+(2)): for(i=x-1; i >= 0; --i, src += 4, dest += 2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = src[3]; } break;
         case ((4)*8+(3)): for(i=x-1; i >= 0; --i, src += 4, dest += 3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2]; } break;
         default: (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 1603, "0") : (void)0);
      }

   }

   Memory::dealloc(data);
   return good;
}


static float *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return __null;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == __null) { Memory::dealloc(data); return ((float *)(size_t) (stbi__err("Out of memory")?__null:__null)); }

   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
      if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;
   }
   Memory::dealloc(data);
   return output;
}




static stbi_uc *stbi__hdr_to_ldr(float *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return __null;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == __null) { Memory::dealloc(data); return ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null)); }

   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) ((int) (z));
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) ((int) (z));
      }
   }
   Memory::dealloc(data);
   return output;
}
# 1689 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
typedef struct
{
   stbi_uc fast[1 << 9];

   stbi__uint16 code[256];
   stbi_uc values[256];
   stbi_uc size[257];
   unsigned int maxcode[18];
   int delta[17];
} stbi__huffman;

typedef struct
{
   stbi__context *s;
   stbi__huffman huff_dc[4];
   stbi__huffman huff_ac[4];
   stbi__uint16 dequant[4][64];
   stbi__int16 fast_ac[4][1 << 9];


   int img_h_max, img_v_max;
   int img_mcu_x, img_mcu_y;
   int img_mcu_w, img_mcu_h;


   struct
   {
      int id;
      int h,v;
      int tq;
      int hd,ha;
      int dc_pred;

      int x,y,w2,h2;
      stbi_uc *data;
      void *raw_data, *raw_coeff;
      stbi_uc *linebuf;
      short *coeff;
      int coeff_w, coeff_h;
   } img_comp[4];

   stbi__uint32 code_buffer;
   int code_bits;
   unsigned char marker;
   int nomore;

   int progressive;
   int spec_start;
   int spec_end;
   int succ_high;
   int succ_low;
   int eob_run;
   int jfif;
   int app14_color_transform;
   int rgb;

   int scan_n, order[4];
   int restart_interval, todo;


   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0;
   unsigned int code;

   for (i=0; i < 16; ++i)
      for (j=0; j < count[i]; ++j)
         h->size[k++] = (stbi_uc) (i+1);
   h->size[k] = 0;


   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {

      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1u << j)) return stbi__err("Corrupt JPEG");
      }

      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;


   memset(h->fast, 255, 1 << 9);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= 9) {
         int c = h->code[i] << (9 -s);
         int m = 1 << (9 -s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}



static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << 9); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= 9) {

            int k = ((i << len) & ((1 << 9) - 1)) >> (9 - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;

            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
         }
      }
   }
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s);
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}


static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};


inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);



   c = (j->code_buffer >> (32 - 9)) & ((1 << 9)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }







   temp = j->code_buffer >> 16;
   for (k=9 +1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {

      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;


   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   (__builtin_expect(!((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 1886, "(((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]") : (void)0);


   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}


static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};



inline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

   sgn = (stbi__int32)j->code_buffer >> 31;
   k = (((j->code_buffer) << (n)) | ((j->code_buffer) >> (32 - (n))));
   (__builtin_expect(!(n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask))), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 1907, "n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask))") : (void)0);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & ~sgn);
}


inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   k = (((j->code_buffer) << (n)) | ((j->code_buffer) >> (32 - (n))));
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}

inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}



static const stbi_uc stbi__jpeg_dezigzag[64+15] =
{
    0, 1, 8, 16, 9, 2, 3, 10,
   17, 24, 32, 25, 18, 11, 4, 5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13, 6, 7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,

   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};


static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0) return stbi__err("Corrupt JPEG");


   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   data[0] = (short) (dc * dequant[0]);


   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - 9)) & ((1 << 9)-1);
      r = fac[c];
      if (r) {
         k += (r >> 4) & 15;
         s = r & 15;
         j->code_buffer <<= s;
         j->code_bits -= s;

         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err("Corrupt JPEG");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break;
            k += 16;
         } else {
            k += r;

            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err("Corrupt JPEG");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {

      memset(data,0,64*sizeof(data[0]));
      t = stbi__jpeg_huff_decode(j, hdc);
      diff = t ? stbi__extend_receive(j, t) : 0;

      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      data[0] = (short) (dc << j->succ_low);
   } else {

      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}



static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err("Corrupt JPEG");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - 9)) & ((1 << 9)-1);
         r = fac[c];
         if (r) {
            k += (r >> 4) & 15;
            s = r & 15;
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) << shift);
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err("Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) << shift);
            }
         }
      } while (k <= j->spec_end);
   } else {


      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err("Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64;
               } else {



               }
            } else {
               if (s != 1) return stbi__err("Corrupt JPEG");

               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }


            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}


inline static stbi_uc stbi__clamp(int x)
{

   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}
# 2204 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;


   for (i=0; i < 8; ++i,++d, ++v) {

      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {




         int dcterm = d[0]*4;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; p2 = d[16]; p3 = d[48]; p1 = (p2+p3) * ((int) (((0.5411961f) * 4096 + 0.5))); t2 = p1 + p3*((int) (((-1.847759065f) * 4096 + 0.5))); t3 = p1 + p2*((int) (((0.765366865f) * 4096 + 0.5))); p2 = d[ 0]; p3 = d[32]; t0 = ((p2+p3) * 4096); t1 = ((p2-p3) * 4096); x0 = t0+t3; x3 = t0-t3; x1 = t1+t2; x2 = t1-t2; t0 = d[56]; t1 = d[40]; t2 = d[24]; t3 = d[ 8]; p3 = t0+t2; p4 = t1+t3; p1 = t0+t3; p2 = t1+t2; p5 = (p3+p4)*((int) (((1.175875602f) * 4096 + 0.5))); t0 = t0*((int) (((0.298631336f) * 4096 + 0.5))); t1 = t1*((int) (((2.053119869f) * 4096 + 0.5))); t2 = t2*((int) (((3.072711026f) * 4096 + 0.5))); t3 = t3*((int) (((1.501321110f) * 4096 + 0.5))); p1 = p5 + p1*((int) (((-0.899976223f) * 4096 + 0.5))); p2 = p5 + p2*((int) (((-2.562915447f) * 4096 + 0.5))); p3 = p3*((int) (((-1.961570560f) * 4096 + 0.5))); p4 = p4*((int) (((-0.390180644f) * 4096 + 0.5))); t3 += p1+p4; t2 += p2+p3; t1 += p2+p4; t0 += p1+p3;


         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {

      int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; p2 = v[2]; p3 = v[6]; p1 = (p2+p3) * ((int) (((0.5411961f) * 4096 + 0.5))); t2 = p1 + p3*((int) (((-1.847759065f) * 4096 + 0.5))); t3 = p1 + p2*((int) (((0.765366865f) * 4096 + 0.5))); p2 = v[0]; p3 = v[4]; t0 = ((p2+p3) * 4096); t1 = ((p2-p3) * 4096); x0 = t0+t3; x3 = t0-t3; x1 = t1+t2; x2 = t1-t2; t0 = v[7]; t1 = v[5]; t2 = v[3]; t3 = v[1]; p3 = t0+t2; p4 = t1+t3; p1 = t0+t3; p2 = t1+t2; p5 = (p3+p4)*((int) (((1.175875602f) * 4096 + 0.5))); t0 = t0*((int) (((0.298631336f) * 4096 + 0.5))); t1 = t1*((int) (((2.053119869f) * 4096 + 0.5))); t2 = t2*((int) (((3.072711026f) * 4096 + 0.5))); t3 = t3*((int) (((1.501321110f) * 4096 + 0.5))); p1 = p5 + p1*((int) (((-0.899976223f) * 4096 + 0.5))); p2 = p5 + p2*((int) (((-2.562915447f) * 4096 + 0.5))); p3 = p3*((int) (((-1.961570560f) * 4096 + 0.5))); p4 = p4*((int) (((-0.390180644f) * 4096 + 0.5))); t3 += p1+p4; t2 += p2+p3; t1 += p2+p4; t0 += p1+p3;






      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);


      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}





static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{

   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;
# 2352 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
   __m128i rot0_0 = _mm_setr_epi16((((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((-1.847759065f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((-1.847759065f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((-1.847759065f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((-1.847759065f) * 4096 + 0.5)))));
   __m128i rot0_1 = _mm_setr_epi16((((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((0.765366865f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((0.765366865f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((0.765366865f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((0.765366865f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))));
   __m128i rot1_0 = _mm_setr_epi16((((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-0.899976223f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-0.899976223f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-0.899976223f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-0.899976223f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))));
   __m128i rot1_1 = _mm_setr_epi16((((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-2.562915447f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-2.562915447f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-2.562915447f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-2.562915447f) * 4096 + 0.5)))));
   __m128i rot2_0 = _mm_setr_epi16((((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((0.298631336f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((0.298631336f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((0.298631336f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((0.298631336f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))));
   __m128i rot2_1 = _mm_setr_epi16((((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((3.072711026f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((3.072711026f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((3.072711026f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((3.072711026f) * 4096 + 0.5)))));
   __m128i rot3_0 = _mm_setr_epi16((((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((2.053119869f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((2.053119869f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((2.053119869f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((2.053119869f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))));
   __m128i rot3_1 = _mm_setr_epi16((((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((1.501321110f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((1.501321110f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((1.501321110f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((1.501321110f) * 4096 + 0.5)))));


   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));


   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));


   { __m128i rot0_0lo = _mm_unpacklo_epi16((row2),(row6)); __m128i rot0_0hi = _mm_unpackhi_epi16((row2),(row6)); __m128i t2e_l = _mm_madd_epi16(rot0_0lo, rot0_0); __m128i t2e_h = _mm_madd_epi16(rot0_0hi, rot0_0); __m128i t3e_l = _mm_madd_epi16(rot0_0lo, rot0_1); __m128i t3e_h = _mm_madd_epi16(rot0_0hi, rot0_1); __m128i sum04 = _mm_add_epi16(row0, row4); __m128i dif04 = _mm_sub_epi16(row0, row4); __m128i t0e_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (sum04)), 4); __m128i t0e_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (sum04)), 4); __m128i t1e_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (dif04)), 4); __m128i t1e_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (dif04)), 4); __m128i x0_l = _mm_add_epi32(t0e_l, t3e_l); __m128i x0_h = _mm_add_epi32(t0e_h, t3e_h); __m128i x3_l = _mm_sub_epi32(t0e_l, t3e_l); __m128i x3_h = _mm_sub_epi32(t0e_h, t3e_h); __m128i x1_l = _mm_add_epi32(t1e_l, t2e_l); __m128i x1_h = _mm_add_epi32(t1e_h, t2e_h); __m128i x2_l = _mm_sub_epi32(t1e_l, t2e_l); __m128i x2_h = _mm_sub_epi32(t1e_h, t2e_h); __m128i rot2_0lo = _mm_unpacklo_epi16((row7),(row3)); __m128i rot2_0hi = _mm_unpackhi_epi16((row7),(row3)); __m128i y0o_l = _mm_madd_epi16(rot2_0lo, rot2_0); __m128i y0o_h = _mm_madd_epi16(rot2_0hi, rot2_0); __m128i y2o_l = _mm_madd_epi16(rot2_0lo, rot2_1); __m128i y2o_h = _mm_madd_epi16(rot2_0hi, rot2_1); __m128i rot3_0lo = _mm_unpacklo_epi16((row5),(row1)); __m128i rot3_0hi = _mm_unpackhi_epi16((row5),(row1)); __m128i y1o_l = _mm_madd_epi16(rot3_0lo, rot3_0); __m128i y1o_h = _mm_madd_epi16(rot3_0hi, rot3_0); __m128i y3o_l = _mm_madd_epi16(rot3_0lo, rot3_1); __m128i y3o_h = _mm_madd_epi16(rot3_0hi, rot3_1); __m128i sum17 = _mm_add_epi16(row1, row7); __m128i sum35 = _mm_add_epi16(row3, row5); __m128i rot1_0lo = _mm_unpacklo_epi16((sum17),(sum35)); __m128i rot1_0hi = _mm_unpackhi_epi16((sum17),(sum35)); __m128i y4o_l = _mm_madd_epi16(rot1_0lo, rot1_0); __m128i y4o_h = _mm_madd_epi16(rot1_0hi, rot1_0); __m128i y5o_l = _mm_madd_epi16(rot1_0lo, rot1_1); __m128i y5o_h = _mm_madd_epi16(rot1_0hi, rot1_1); __m128i x4_l = _mm_add_epi32(y0o_l, y4o_l); __m128i x4_h = _mm_add_epi32(y0o_h, y4o_h); __m128i x5_l = _mm_add_epi32(y1o_l, y5o_l); __m128i x5_h = _mm_add_epi32(y1o_h, y5o_h); __m128i x6_l = _mm_add_epi32(y2o_l, y5o_l); __m128i x6_h = _mm_add_epi32(y2o_h, y5o_h); __m128i x7_l = _mm_add_epi32(y3o_l, y4o_l); __m128i x7_h = _mm_add_epi32(y3o_h, y4o_h); { __m128i abiased_l = _mm_add_epi32(x0_l, bias_0); __m128i abiased_h = _mm_add_epi32(x0_h, bias_0); __m128i sum_l = _mm_add_epi32(abiased_l, x7_l); __m128i sum_h = _mm_add_epi32(abiased_h, x7_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x7_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x7_h); row0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 10), _mm_srai_epi32(sum_h, 10)); row7 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 10), _mm_srai_epi32(dif_h, 10)); }; { __m128i abiased_l = _mm_add_epi32(x1_l, bias_0); __m128i abiased_h = _mm_add_epi32(x1_h, bias_0); __m128i sum_l = _mm_add_epi32(abiased_l, x6_l); __m128i sum_h = _mm_add_epi32(abiased_h, x6_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x6_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x6_h); row1 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 10), _mm_srai_epi32(sum_h, 10)); row6 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 10), _mm_srai_epi32(dif_h, 10)); }; { __m128i abiased_l = _mm_add_epi32(x2_l, bias_0); __m128i abiased_h = _mm_add_epi32(x2_h, bias_0); __m128i sum_l = _mm_add_epi32(abiased_l, x5_l); __m128i sum_h = _mm_add_epi32(abiased_h, x5_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x5_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x5_h); row2 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 10), _mm_srai_epi32(sum_h, 10)); row5 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 10), _mm_srai_epi32(dif_h, 10)); }; { __m128i abiased_l = _mm_add_epi32(x3_l, bias_0); __m128i abiased_h = _mm_add_epi32(x3_h, bias_0); __m128i sum_l = _mm_add_epi32(abiased_l, x4_l); __m128i sum_h = _mm_add_epi32(abiased_h, x4_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x4_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x4_h); row3 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 10), _mm_srai_epi32(sum_h, 10)); row4 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 10), _mm_srai_epi32(dif_h, 10)); }; };

   {

      tmp = row0; row0 = _mm_unpacklo_epi16(row0, row4); row4 = _mm_unpackhi_epi16(tmp, row4);
      tmp = row1; row1 = _mm_unpacklo_epi16(row1, row5); row5 = _mm_unpackhi_epi16(tmp, row5);
      tmp = row2; row2 = _mm_unpacklo_epi16(row2, row6); row6 = _mm_unpackhi_epi16(tmp, row6);
      tmp = row3; row3 = _mm_unpacklo_epi16(row3, row7); row7 = _mm_unpackhi_epi16(tmp, row7);


      tmp = row0; row0 = _mm_unpacklo_epi16(row0, row2); row2 = _mm_unpackhi_epi16(tmp, row2);
      tmp = row1; row1 = _mm_unpacklo_epi16(row1, row3); row3 = _mm_unpackhi_epi16(tmp, row3);
      tmp = row4; row4 = _mm_unpacklo_epi16(row4, row6); row6 = _mm_unpackhi_epi16(tmp, row6);
      tmp = row5; row5 = _mm_unpacklo_epi16(row5, row7); row7 = _mm_unpackhi_epi16(tmp, row7);


      tmp = row0; row0 = _mm_unpacklo_epi16(row0, row1); row1 = _mm_unpackhi_epi16(tmp, row1);
      tmp = row2; row2 = _mm_unpacklo_epi16(row2, row3); row3 = _mm_unpackhi_epi16(tmp, row3);
      tmp = row4; row4 = _mm_unpacklo_epi16(row4, row5); row5 = _mm_unpackhi_epi16(tmp, row5);
      tmp = row6; row6 = _mm_unpacklo_epi16(row6, row7); row7 = _mm_unpackhi_epi16(tmp, row7);
   }


   { __m128i rot0_0lo = _mm_unpacklo_epi16((row2),(row6)); __m128i rot0_0hi = _mm_unpackhi_epi16((row2),(row6)); __m128i t2e_l = _mm_madd_epi16(rot0_0lo, rot0_0); __m128i t2e_h = _mm_madd_epi16(rot0_0hi, rot0_0); __m128i t3e_l = _mm_madd_epi16(rot0_0lo, rot0_1); __m128i t3e_h = _mm_madd_epi16(rot0_0hi, rot0_1); __m128i sum04 = _mm_add_epi16(row0, row4); __m128i dif04 = _mm_sub_epi16(row0, row4); __m128i t0e_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (sum04)), 4); __m128i t0e_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (sum04)), 4); __m128i t1e_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (dif04)), 4); __m128i t1e_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (dif04)), 4); __m128i x0_l = _mm_add_epi32(t0e_l, t3e_l); __m128i x0_h = _mm_add_epi32(t0e_h, t3e_h); __m128i x3_l = _mm_sub_epi32(t0e_l, t3e_l); __m128i x3_h = _mm_sub_epi32(t0e_h, t3e_h); __m128i x1_l = _mm_add_epi32(t1e_l, t2e_l); __m128i x1_h = _mm_add_epi32(t1e_h, t2e_h); __m128i x2_l = _mm_sub_epi32(t1e_l, t2e_l); __m128i x2_h = _mm_sub_epi32(t1e_h, t2e_h); __m128i rot2_0lo = _mm_unpacklo_epi16((row7),(row3)); __m128i rot2_0hi = _mm_unpackhi_epi16((row7),(row3)); __m128i y0o_l = _mm_madd_epi16(rot2_0lo, rot2_0); __m128i y0o_h = _mm_madd_epi16(rot2_0hi, rot2_0); __m128i y2o_l = _mm_madd_epi16(rot2_0lo, rot2_1); __m128i y2o_h = _mm_madd_epi16(rot2_0hi, rot2_1); __m128i rot3_0lo = _mm_unpacklo_epi16((row5),(row1)); __m128i rot3_0hi = _mm_unpackhi_epi16((row5),(row1)); __m128i y1o_l = _mm_madd_epi16(rot3_0lo, rot3_0); __m128i y1o_h = _mm_madd_epi16(rot3_0hi, rot3_0); __m128i y3o_l = _mm_madd_epi16(rot3_0lo, rot3_1); __m128i y3o_h = _mm_madd_epi16(rot3_0hi, rot3_1); __m128i sum17 = _mm_add_epi16(row1, row7); __m128i sum35 = _mm_add_epi16(row3, row5); __m128i rot1_0lo = _mm_unpacklo_epi16((sum17),(sum35)); __m128i rot1_0hi = _mm_unpackhi_epi16((sum17),(sum35)); __m128i y4o_l = _mm_madd_epi16(rot1_0lo, rot1_0); __m128i y4o_h = _mm_madd_epi16(rot1_0hi, rot1_0); __m128i y5o_l = _mm_madd_epi16(rot1_0lo, rot1_1); __m128i y5o_h = _mm_madd_epi16(rot1_0hi, rot1_1); __m128i x4_l = _mm_add_epi32(y0o_l, y4o_l); __m128i x4_h = _mm_add_epi32(y0o_h, y4o_h); __m128i x5_l = _mm_add_epi32(y1o_l, y5o_l); __m128i x5_h = _mm_add_epi32(y1o_h, y5o_h); __m128i x6_l = _mm_add_epi32(y2o_l, y5o_l); __m128i x6_h = _mm_add_epi32(y2o_h, y5o_h); __m128i x7_l = _mm_add_epi32(y3o_l, y4o_l); __m128i x7_h = _mm_add_epi32(y3o_h, y4o_h); { __m128i abiased_l = _mm_add_epi32(x0_l, bias_1); __m128i abiased_h = _mm_add_epi32(x0_h, bias_1); __m128i sum_l = _mm_add_epi32(abiased_l, x7_l); __m128i sum_h = _mm_add_epi32(abiased_h, x7_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x7_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x7_h); row0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 17), _mm_srai_epi32(sum_h, 17)); row7 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 17), _mm_srai_epi32(dif_h, 17)); }; { __m128i abiased_l = _mm_add_epi32(x1_l, bias_1); __m128i abiased_h = _mm_add_epi32(x1_h, bias_1); __m128i sum_l = _mm_add_epi32(abiased_l, x6_l); __m128i sum_h = _mm_add_epi32(abiased_h, x6_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x6_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x6_h); row1 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 17), _mm_srai_epi32(sum_h, 17)); row6 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 17), _mm_srai_epi32(dif_h, 17)); }; { __m128i abiased_l = _mm_add_epi32(x2_l, bias_1); __m128i abiased_h = _mm_add_epi32(x2_h, bias_1); __m128i sum_l = _mm_add_epi32(abiased_l, x5_l); __m128i sum_h = _mm_add_epi32(abiased_h, x5_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x5_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x5_h); row2 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 17), _mm_srai_epi32(sum_h, 17)); row5 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 17), _mm_srai_epi32(dif_h, 17)); }; { __m128i abiased_l = _mm_add_epi32(x3_l, bias_1); __m128i abiased_h = _mm_add_epi32(x3_h, bias_1); __m128i sum_l = _mm_add_epi32(abiased_l, x4_l); __m128i sum_h = _mm_add_epi32(abiased_h, x4_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x4_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x4_h); row3 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 17), _mm_srai_epi32(sum_h, 17)); row4 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 17), _mm_srai_epi32(dif_h, 17)); }; };

   {

      __m128i p0 = _mm_packus_epi16(row0, row1);
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);


      tmp = p0; p0 = _mm_unpacklo_epi8(p0, p2); p2 = _mm_unpackhi_epi8(tmp, p2);
      tmp = p1; p1 = _mm_unpacklo_epi8(p1, p3); p3 = _mm_unpackhi_epi8(tmp, p3);


      tmp = p0; p0 = _mm_unpacklo_epi8(p0, p1); p1 = _mm_unpackhi_epi8(tmp, p1);
      tmp = p2; p2 = _mm_unpacklo_epi8(p2, p3); p3 = _mm_unpackhi_epi8(tmp, p3);


      tmp = p0; p0 = _mm_unpacklo_epi8(p0, p2); p2 = _mm_unpackhi_epi8(tmp, p2);
      tmp = p1; p1 = _mm_unpacklo_epi8(p1, p3); p3 = _mm_unpackhi_epi8(tmp, p3);


      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, __extension__ ({ (__m128i)__builtin_shufflevector((__v4si)(__m128i)(p0), (__v4si)_mm_undefined_si128(), ((0x4e) >> 0) & 0x3, ((0x4e) >> 2) & 0x3, ((0x4e) >> 4) & 0x3, ((0x4e) >> 6) & 0x3); })); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, __extension__ ({ (__m128i)__builtin_shufflevector((__v4si)(__m128i)(p2), (__v4si)_mm_undefined_si128(), ((0x4e) >> 0) & 0x3, ((0x4e) >> 2) & 0x3, ((0x4e) >> 4) & 0x3, ((0x4e) >> 6) & 0x3); })); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, __extension__ ({ (__m128i)__builtin_shufflevector((__v4si)(__m128i)(p1), (__v4si)_mm_undefined_si128(), ((0x4e) >> 0) & 0x3, ((0x4e) >> 2) & 0x3, ((0x4e) >> 4) & 0x3, ((0x4e) >> 6) & 0x3); })); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, __extension__ ({ (__m128i)__builtin_shufflevector((__v4si)(__m128i)(p3), (__v4si)_mm_undefined_si128(), ((0x4e) >> 0) & 0x3, ((0x4e) >> 2) & 0x3, ((0x4e) >> 4) & 0x3, ((0x4e) >> 6) & 0x3); }));
   }
# 2440 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
}
# 2656 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != 0xff) { x = j->marker; j->marker = 0xff; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return 0xff;
   while (x == 0xff)
      x = stbi__get8(j->s);
   return x;
}







static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = 0xff;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;


}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         short data[64] __attribute__((aligned(16)));
         int n = z->order[0];




         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);

               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);


                  if (!((z->marker) >= 0xd0 && (z->marker) <= 0xd7)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else {
         int i,j,k,x,y;
         short data[64] __attribute__((aligned(16)));
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {

               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];


                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }


               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!((z->marker) >= 0xd0 && (z->marker) <= 0xd7)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];




         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }

               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!((z->marker) >= 0xd0 && (z->marker) <= 0xd7)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else {
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {

               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];


                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }


               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!((z->marker) >= 0xd0 && (z->marker) <= 0xd7)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}

static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {

      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case 0xff:
         return stbi__err("Corrupt JPEG");

      case 0xDD:
         if (stbi__get16be(z->s) != 4) return stbi__err("Corrupt JPEG");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB:
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err("Corrupt JPEG");
            if (t > 3) return stbi__err("Corrupt JPEG");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4:
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err("Corrupt JPEG");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }


   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err("Corrupt JPEG");
         else
            return stbi__err("Corrupt JPEG");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) {
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) {
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s);
            stbi__get16be(z->s);
            stbi__get16be(z->s);
            z->app14_color_transform = stbi__get8(z->s);
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err("Corrupt JPEG");
}


static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("Corrupt JPEG");
   if (Ls != 6+2*z->scan_n) return stbi__err("Corrupt JPEG");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0;
      z->img_comp[which].hd = q >> 4; if (z->img_comp[which].hd > 3) return stbi__err("Corrupt JPEG");
      z->img_comp[which].ha = q & 15; if (z->img_comp[which].ha > 3) return stbi__err("Corrupt JPEG");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end = stbi__get8(z->s);
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63 || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err("Corrupt JPEG");
      } else {
         if (z->spec_start != 0) return stbi__err("Corrupt JPEG");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("Corrupt JPEG");
         z->spec_end = 63;
      }
   }

   return 1;
}

static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         Memory::dealloc(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = __null;
         z->img_comp[i].data = __null;
      }
      if (z->img_comp[i].raw_coeff) {
         Memory::dealloc(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         Memory::dealloc(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = __null;
      }
   }
   return why;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s); if (Lf < 11) return stbi__err("Corrupt JPEG");
   p = stbi__get8(s); if (p != 8) return stbi__err("JPEG format not supported: 8-bit only");
   s->img_y = stbi__get16be(s); if (s->img_y == 0) return stbi__err("JPEG format not supported: delayed height");
   s->img_x = stbi__get16be(s); if (s->img_x == 0) return stbi__err("Corrupt JPEG");
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err("Corrupt JPEG");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = __null;
      z->img_comp[i].linebuf = __null;
   }

   if (Lf != 8+3*s->img_n) return stbi__err("Corrupt JPEG");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4); if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("Corrupt JPEG");
      z->img_comp[i].v = q & 15; if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("Corrupt JPEG");
      z->img_comp[i].tq = stbi__get8(s); if (z->img_comp[i].tq > 3) return stbi__err("Corrupt JPEG");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("Image too large to decode");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }


   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;

   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {

      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;







      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = __null;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == __null)
         return stbi__free_jpeg_components(z, i+1, stbi__err("Out of memory"));

      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {

         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == __null)
            return stbi__free_jpeg_components(z, i+1, stbi__err("Out of memory"));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}
# 3092 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1;
   z->marker = 0xff;
   m = stbi__get_marker(z);
   if (!((m) == 0xd8)) return stbi__err("Corrupt JPEG");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!((m) == 0xc0 || (m) == 0xc1 || (m) == 0xc2)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == 0xff) {

         if (stbi__at_eof(z->s)) return stbi__err("Corrupt JPEG");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = ((m) == 0xc2);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}


static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = __null;
      j->img_comp[m].raw_coeff = __null;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!((m) == 0xd9)) {
      if (((m) == 0xda)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == 0xff ) {

            while (!stbi__at_eof(j->s)) {
               int x = stbi__get8(j->s);
               if (x == 255) {
                  j->marker = stbi__get8(j->s);
                  break;
               }
            }

         }
      } else if (((m) == 0xdc)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) return stbi__err("Corrupt JPEG");
         if (NL != j->s->img_y) return stbi__err("Corrupt JPEG");
      } else {
         if (!stbi__process_marker(j, m)) return 0;
      }
      m = stbi__get_marker(j);
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}



typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
                                    int w, int hs);



static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   (void)sizeof(out);
   (void)sizeof(in_far);
   (void)sizeof(w);
   (void)sizeof(hs);
   return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{

   int i;
   (void)sizeof(hs);
   for (i=0; i < w; ++i)
      out[i] = ((stbi_uc) ((3*in_near[i] + in_far[i] + 2) >> 2));
   return out;
}

static stbi_uc* stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{

   int i;
   stbi_uc *input = in_near;

   if (w == 1) {

      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = ((stbi_uc) ((input[0]*3 + input[1] + 2) >> 2));
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = ((stbi_uc) ((n+input[i-1]) >> 2));
      out[i*2+1] = ((stbi_uc) ((n+input[i+1]) >> 2));
   }
   out[i*2+0] = ((stbi_uc) ((input[w-2]*3 + input[w-1] + 2) >> 2));
   out[i*2+1] = input[w-1];

   (void)sizeof(in_far);
   (void)sizeof(hs);

   return out;
}



static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{

   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = ((stbi_uc) ((3*in_near[0] + in_far[0] + 2) >> 2));
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = ((stbi_uc) ((t1+2) >> 2));
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = ((stbi_uc) ((3*t0 + t1 + 8) >> 4));
      out[i*2 ] = ((stbi_uc) ((3*t1 + t0 + 8) >> 4));
   }
   out[w*2-1] = ((stbi_uc) ((t1+2) >> 2));

   (void)sizeof(hs);

   return out;
}


static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{

   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = ((stbi_uc) ((3*in_near[0] + in_far[0] + 2) >> 2));
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];



   for (; i < ((w-1) & ~7); i += 8) {



      __m128i zero = _mm_setzero_si128();
      __m128i farb = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr = _mm_add_epi16(nears, diff);






      __m128i prv0 = __extension__ ({ (__m128i)__builtin_shufflevector( (__v16qi)_mm_setzero_si128(), (__v16qi)(__m128i)(curr), ((char)(2)&0xF0) ? 0 : 16 - (char)(2), ((char)(2)&0xF0) ? 1 : 17 - (char)(2), ((char)(2)&0xF0) ? 2 : 18 - (char)(2), ((char)(2)&0xF0) ? 3 : 19 - (char)(2), ((char)(2)&0xF0) ? 4 : 20 - (char)(2), ((char)(2)&0xF0) ? 5 : 21 - (char)(2), ((char)(2)&0xF0) ? 6 : 22 - (char)(2), ((char)(2)&0xF0) ? 7 : 23 - (char)(2), ((char)(2)&0xF0) ? 8 : 24 - (char)(2), ((char)(2)&0xF0) ? 9 : 25 - (char)(2), ((char)(2)&0xF0) ? 10 : 26 - (char)(2), ((char)(2)&0xF0) ? 11 : 27 - (char)(2), ((char)(2)&0xF0) ? 12 : 28 - (char)(2), ((char)(2)&0xF0) ? 13 : 29 - (char)(2), ((char)(2)&0xF0) ? 14 : 30 - (char)(2), ((char)(2)&0xF0) ? 15 : 31 - (char)(2)); });
      __m128i nxt0 = __extension__ ({ (__m128i)__builtin_shufflevector( (__v16qi)(__m128i)(curr), (__v16qi)_mm_setzero_si128(), ((char)(2)&0xF0) ? 16 : (char)(2) + 0, ((char)(2)&0xF0) ? 17 : (char)(2) + 1, ((char)(2)&0xF0) ? 18 : (char)(2) + 2, ((char)(2)&0xF0) ? 19 : (char)(2) + 3, ((char)(2)&0xF0) ? 20 : (char)(2) + 4, ((char)(2)&0xF0) ? 21 : (char)(2) + 5, ((char)(2)&0xF0) ? 22 : (char)(2) + 6, ((char)(2)&0xF0) ? 23 : (char)(2) + 7, ((char)(2)&0xF0) ? 24 : (char)(2) + 8, ((char)(2)&0xF0) ? 25 : (char)(2) + 9, ((char)(2)&0xF0) ? 26 : (char)(2) + 10, ((char)(2)&0xF0) ? 27 : (char)(2) + 11, ((char)(2)&0xF0) ? 28 : (char)(2) + 12, ((char)(2)&0xF0) ? 29 : (char)(2) + 13, ((char)(2)&0xF0) ? 30 : (char)(2) + 14, ((char)(2)&0xF0) ? 31 : (char)(2) + 15); });
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);





      __m128i bias = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd = _mm_add_epi16(nxtd, curb);


      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0 = _mm_srli_epi16(int0, 4);
      __m128i de1 = _mm_srli_epi16(int1, 4);


      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);
# 3333 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = ((stbi_uc) ((3*t1 + t0 + 8) >> 4));

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = ((stbi_uc) ((3*t0 + t1 + 8) >> 4));
      out[i*2 ] = ((stbi_uc) ((3*t1 + t0 + 8) >> 4));
   }
   out[w*2-1] = ((stbi_uc) ((t1+2) >> 2));

   (void)sizeof(hs);

   return out;
}


static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{

   int i,j;
   (void)sizeof(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}




static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19);
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* (((int) ((1.40200f) * 4096.0f + 0.5f)) << 8);
      g = y_fixed + (cr*-(((int) ((0.71414f) * 4096.0f + 0.5f)) << 8)) + ((cb*-(((int) ((0.34414f) * 4096.0f + 0.5f)) << 8)) & 0xffff0000);
      b = y_fixed + cb* (((int) ((1.77200f) * 4096.0f + 0.5f)) << 8);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}


static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;





   if (step == 4) {

      __m128i signflip = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16( (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16( (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255);

      for (; i+7 < count; i += 8) {

         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip);
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip);


         __m128i yw = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);


         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);


         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);


         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);


         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);


         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
# 3505 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19);
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* (((int) ((1.40200f) * 4096.0f + 0.5f)) << 8);
      g = y_fixed + cr*-(((int) ((0.71414f) * 4096.0f + 0.5f)) << 8) + ((cb*-(((int) ((0.34414f) * 4096.0f + 0.5f)) << 8)) & 0xffff0000);
      b = y_fixed + cb* (((int) ((1.77200f) * 4096.0f + 0.5f)) << 8);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}



static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;


   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }







}


static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}

typedef struct
{
   resample_row_func resample;
   stbi_uc *line0,*line1;
   int hs,vs;
   int w_lores;
   int ystep;
   int ypos;
} stbi__resample;


static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0;


   if (req_comp < 0 || req_comp > 4) return ((unsigned char *)(size_t) (stbi__err("Internal error")?__null:__null));


   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return __null; }


   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;


   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4];

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];



         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null)); }

         r->hs = z->img_h_max / z->img_comp[k].h;
         r->vs = z->img_v_max / z->img_comp[k].v;
         r->ystep = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos = 0;
         r->line0 = r->line1 = z->img_comp[k].data;

         if (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else r->resample = stbi__resample_row_generic;
      }


      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null)); }


      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) {
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255;
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1;
      return output;
   }
}

static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   (void)sizeof(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   Memory::dealloc(j);
   return result;
}

static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   Memory::dealloc(j);
   return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   Memory::dealloc(j);
   return result;
}
# 3794 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
typedef struct
{
   stbi__uint16 fast[1 << 9];
   stbi__uint16 firstcode[16];
   int maxcode[17];
   stbi__uint16 firstsymbol[16];
   stbi_uc size[288];
   stbi__uint16 value[288];
} stbi__zhuffman;

inline static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8);
  return n;
}

inline static int stbi__bit_reverse(int v, int bits)
{
   (__builtin_expect(!(bits <= 16), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 3815, "bits <= 16") : (void)0);


   return stbi__bitreverse16(v) >> (16-bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];


   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err("Corrupt PNG");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err("Corrupt PNG");
      z->maxcode[i] = code << (16-i);
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000;
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= 9) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << 9)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}







typedef struct
{
   stbi_uc *zbuffer, *zbuffer_end;
   int num_bits;
   stbi__uint32 code_buffer;

   char *zout;
   char *zout_start;
   char *zout_end;
   int z_expandable;

   stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

inline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   if (z->zbuffer >= z->zbuffer_end) return 0;
   return *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      (__builtin_expect(!(z->code_buffer < (1U << z->num_bits)), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 3897, "z->code_buffer < (1U << z->num_bits)") : (void)0);
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}

inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;


   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=9 +1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s == 16) return -1;

   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   (__builtin_expect(!(z->size[b] == s), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 3925, "z->size[b] == s") : (void)0);
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}

inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) stbi__fill_bits(a);
   b = z->fast[a->code_buffer & ((1 << 9) - 1)];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)
{
   char *q;
   int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err("Corrupt PNG");
   cur = (int) (z->zout - z->zout_start);
   limit = old_limit = (int) (z->zout_end - z->zout_start);
   while (cur + n > limit)
      limit *= 2;
   q = (char *) Memory::realloc(z->zout_start, old_limit, limit);
   (void)sizeof(old_limit);
   if (q == __null) return stbi__err("Out of memory");
   z->zout_start = q;
   z->zout = q + cur;
   z->zout_end = q + limit;
   return 1;
}

static const int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static const int stbi__zlength_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static const int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err("Corrupt PNG");
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            return 1;
         }
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0) return stbi__err("Corrupt PNG");
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err("Corrupt PNG");
         if (zout + len > a->zout_end) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) {
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err("Corrupt PNG");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err("Corrupt PNG");
            fill = lencodes[n-1];
         } else if (c == 17)
            c = stbi__zreceive(a,3)+3;
         else {
            (__builtin_expect(!(c == 18), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 4055, "c == 18") : (void)0);
            c = stbi__zreceive(a,7)+11;
         }
         if (ntot - n < c) return stbi__err("Corrupt PNG");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err("Corrupt PNG");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7);

   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255);
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   (__builtin_expect(!(a->num_bits == 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 4082, "a->num_bits == 0") : (void)0);

   while (k < 4)
      header[k++] = stbi__zget8(a);
   len = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err("Corrupt PNG");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("Corrupt PNG");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf = stbi__zget8(a);
   int cm = cmf & 15;

   int flg = stbi__zget8(a);
   if ((cmf*256+flg) % 31 != 0) return stbi__err("Corrupt PNG");
   if (flg & 32) return stbi__err("Corrupt PNG");
   if (cm != 8) return stbi__err("Corrupt PNG");

   return 1;
}

static const stbi_uc stbi__zdefault_length[288] =
{
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
};
static const stbi_uc stbi__zdefault_distance[32] =
{
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
};
# 4140 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {

            if (!stbi__zbuild_huffman(&a->z_length , stbi__zdefault_length , 288)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance, 32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout = obuf;
   a->zout_end = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}

static char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == __null) return __null;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      Memory::dealloc(a.zout_start);
      return __null;
   }
}

static char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

static char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == __null) return __null;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      Memory::dealloc(a.zout_start);
      return __null;
   }
}

static int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}

static char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == __null) return __null;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      Memory::dealloc(a.zout_start);
      return __null;
   }
}

static int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}
# 4265 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
typedef struct
{
   stbi__uint32 length;
   stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type = stbi__get32be(s);
   return c;
}

static int stbi__check_png_header(stbi__context *s)
{
   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err("Not a PNG");
   return 1;
}

typedef struct
{
   stbi__context *s;
   stbi_uc *idata, *expanded, *out;
   int depth;
} stbi__png;


enum {
   STBI__F_none=0,
   STBI__F_sub=1,
   STBI__F_up=2,
   STBI__F_avg=3,
   STBI__F_paeth=4,

   STBI__F_avg_first,
   STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
   int p = a + b - c;
   int pa = abs(p-a);
   int pb = abs(p-b);
   int pc = abs(p-c);
   if (pa <= pb && pa <= pc) return a;
   if (pb <= pc) return b;
   return c;
}

static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };


static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   int k;
   int img_n = s->img_n;

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   (__builtin_expect(!(out_n == s->img_n || out_n == s->img_n+1), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 4343, "out_n == s->img_n || out_n == s->img_n+1") : (void)0);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0);
   if (!a->out) return stbi__err("Out of memory");

   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("Corrupt PNG");
   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   img_len = (img_width_bytes + 1) * y;




   if (raw_len < img_len) return stbi__err("Corrupt PNG");

   for (j=0; j < y; ++j) {
      stbi_uc *cur = a->out + stride*j;
      stbi_uc *prior;
      int filter = *raw++;

      if (filter > 4)
         return stbi__err("Corrupt PNG");

      if (depth < 8) {
         (__builtin_expect(!(img_width_bytes <= x), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 4365, "img_width_bytes <= x") : (void)0);
         cur += x*out_n - img_width_bytes;
         filter_bytes = 1;
         width = img_width_bytes;
      }
      prior = cur - stride;


      if (j == 0) filter = first_row_filter[filter];


      for (k=0; k < filter_bytes; ++k) {
         switch (filter) {
            case STBI__F_none : cur[k] = raw[k]; break;
            case STBI__F_sub : cur[k] = raw[k]; break;
            case STBI__F_up : cur[k] = ((stbi_uc) ((raw[k] + prior[k]) & 255)); break;
            case STBI__F_avg : cur[k] = ((stbi_uc) ((raw[k] + (prior[k]>>1)) & 255)); break;
            case STBI__F_paeth : cur[k] = ((stbi_uc) ((raw[k] + stbi__paeth(0,prior[k],0)) & 255)); break;
            case STBI__F_avg_first : cur[k] = raw[k]; break;
            case STBI__F_paeth_first: cur[k] = raw[k]; break;
         }
      }

      if (depth == 8) {
         if (img_n != out_n)
            cur[img_n] = 255;
         raw += img_n;
         cur += out_n;
         prior += out_n;
      } else if (depth == 16) {
         if (img_n != out_n) {
            cur[filter_bytes] = 255;
            cur[filter_bytes+1] = 255;
         }
         raw += filter_bytes;
         cur += output_bytes;
         prior += output_bytes;
      } else {
         raw += 1;
         cur += 1;
         prior += 1;
      }


      if (depth < 8 || img_n == out_n) {
         int nk = (width - 1)*filter_bytes;



         switch (filter) {

            case STBI__F_none: memcpy(cur, raw, nk); break;
            case STBI__F_sub: for (k=0; k < nk; ++k) { cur[k] = ((stbi_uc) ((raw[k] + cur[k-filter_bytes]) & 255)); } break;
            case STBI__F_up: for (k=0; k < nk; ++k) { cur[k] = ((stbi_uc) ((raw[k] + prior[k]) & 255)); } break;
            case STBI__F_avg: for (k=0; k < nk; ++k) { cur[k] = ((stbi_uc) ((raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)) & 255)); } break;
            case STBI__F_paeth: for (k=0; k < nk; ++k) { cur[k] = ((stbi_uc) ((raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])) & 255)); } break;
            case STBI__F_avg_first: for (k=0; k < nk; ++k) { cur[k] = ((stbi_uc) ((raw[k] + (cur[k-filter_bytes] >> 1)) & 255)); } break;
            case STBI__F_paeth_first: for (k=0; k < nk; ++k) { cur[k] = ((stbi_uc) ((raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)) & 255)); } break;
         }

         raw += nk;
      } else {
         (__builtin_expect(!(img_n+1 == out_n), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 4427, "img_n+1 == out_n") : (void)0);




         switch (filter) {
            case STBI__F_none: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k) { cur[k] = raw[k]; } break;
            case STBI__F_sub: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k) { cur[k] = ((stbi_uc) ((raw[k] + cur[k- output_bytes]) & 255)); } break;
            case STBI__F_up: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k) { cur[k] = ((stbi_uc) ((raw[k] + prior[k]) & 255)); } break;
            case STBI__F_avg: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k) { cur[k] = ((stbi_uc) ((raw[k] + ((prior[k] + cur[k- output_bytes])>>1)) & 255)); } break;
            case STBI__F_paeth: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k) { cur[k] = ((stbi_uc) ((raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])) & 255)); } break;
            case STBI__F_avg_first: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k) { cur[k] = ((stbi_uc) ((raw[k] + (cur[k- output_bytes] >> 1)) & 255)); } break;
            case STBI__F_paeth_first: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k) { cur[k] = ((stbi_uc) ((raw[k] + stbi__paeth(cur[k- output_bytes],0,0)) & 255)); } break;
         }




         if (depth == 16) {
            cur = a->out + stride*j;
            for (i=0; i < x; ++i,cur+=output_bytes) {
               cur[filter_bytes+1] = 255;
            }
         }
      }
   }




   if (depth < 8) {
      for (j=0; j < y; ++j) {
         stbi_uc *cur = a->out + stride*j;
         stbi_uc *in = a->out + stride*j + x*out_n - img_width_bytes;


         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1;







         if (depth == 4) {
            for (k=x*img_n; k >= 2; k-=2, ++in) {
               *cur++ = scale * ((*in >> 4) );
               *cur++ = scale * ((*in ) & 0x0f);
            }
            if (k > 0) *cur++ = scale * ((*in >> 4) );
         } else if (depth == 2) {
            for (k=x*img_n; k >= 4; k-=4, ++in) {
               *cur++ = scale * ((*in >> 6) );
               *cur++ = scale * ((*in >> 4) & 0x03);
               *cur++ = scale * ((*in >> 2) & 0x03);
               *cur++ = scale * ((*in ) & 0x03);
            }
            if (k > 0) *cur++ = scale * ((*in >> 6) );
            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
         } else if (depth == 1) {
            for (k=x*img_n; k >= 8; k-=8, ++in) {
               *cur++ = scale * ((*in >> 7) );
               *cur++ = scale * ((*in >> 6) & 0x01);
               *cur++ = scale * ((*in >> 5) & 0x01);
               *cur++ = scale * ((*in >> 4) & 0x01);
               *cur++ = scale * ((*in >> 3) & 0x01);
               *cur++ = scale * ((*in >> 2) & 0x01);
               *cur++ = scale * ((*in >> 1) & 0x01);
               *cur++ = scale * ((*in ) & 0x01);
            }
            if (k > 0) *cur++ = scale * ((*in >> 7) );
            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
         }
         if (img_n != out_n) {
            int q;

            cur = a->out + stride*j;
            if (img_n == 1) {
               for (q=x-1; q >= 0; --q) {
                  cur[q*2+1] = 255;
                  cur[q*2+0] = cur[q];
               }
            } else {
               (__builtin_expect(!(img_n == 3), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 4516, "img_n == 3") : (void)0);
               for (q=x-1; q >= 0; --q) {
                  cur[q*4+3] = 255;
                  cur[q*4+2] = cur[q*3+2];
                  cur[q*4+1] = cur[q*3+1];
                  cur[q*4+0] = cur[q*3+0];
               }
            }
         }
      }
   } else if (depth == 16) {




      stbi_uc *cur = a->out;
      stbi__uint16 *cur16 = (stbi__uint16*)cur;

      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
         *cur16 = (cur[0] << 8) | cur[1];
      }
   }

   return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);


   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[] = { 8,8,4,4,2,2,1 };
      int yspc[] = { 8,8,8,4,4,2,2 };
      int i,j,x,y;

      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            Memory::dealloc(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         Memory::dealloc(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;



   (__builtin_expect(!(out_n == 2 || out_n == 4), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 4594, "out_n == 2 || out_n == 4") : (void)0);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;



   (__builtin_expect(!(out_n == 2 || out_n == 4), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 4619, "out_n == 2 || out_n == 4") : (void)0);

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == __null) return stbi__err("Out of memory");


   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   Memory::dealloc(a->out);
   a->out = temp_out;

   (void)sizeof(len);

   return 1;
}

static int stbi__unpremultiply_on_load = 0;
static int stbi__de_iphone_flag = 0;

static void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;
}

static void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag = flag_true_if_should_convert;
}

static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      (__builtin_expect(!(s->img_out_n == 4), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 4700, "s->img_out_n == 4") : (void)0);
      if (stbi__unpremultiply_on_load) {

         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {

         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}



static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3];
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = __null;
   z->idata = __null;
   z->out = __null;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case (((unsigned) ('C') << 24) + ((unsigned) ('g') << 16) + ((unsigned) ('B') << 8) + (unsigned) ('I')):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case (((unsigned) ('I') << 24) + ((unsigned) ('H') << 16) + ((unsigned) ('D') << 8) + (unsigned) ('R')): {
            int comp,filter;
            if (!first) return stbi__err("Corrupt PNG");
            first = 0;
            if (c.length != 13) return stbi__err("Corrupt PNG");
            s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("Very large image (corrupt?)");
            s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("Very large image (corrupt?)");
            z->depth = stbi__get8(s); if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16) return stbi__err("PNG not supported: 1/2/4/8/16-bit only");
            color = stbi__get8(s); if (color > 6) return stbi__err("Corrupt PNG");
            if (color == 3 && z->depth == 16) return stbi__err("Corrupt PNG");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("Corrupt PNG");
            comp = stbi__get8(s); if (comp) return stbi__err("Corrupt PNG");
            filter= stbi__get8(s); if (filter) return stbi__err("Corrupt PNG");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err("Corrupt PNG");
            if (!s->img_x || !s->img_y) return stbi__err("Corrupt PNG");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("Image too large to decode");
               if (scan == STBI__SCAN_header) return 1;
            } else {


               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("Corrupt PNG");

            }
            break;
         }

         case (((unsigned) ('P') << 24) + ((unsigned) ('L') << 16) + ((unsigned) ('T') << 8) + (unsigned) ('E')): {
            if (first) return stbi__err("Corrupt PNG");
            if (c.length > 256*3) return stbi__err("Corrupt PNG");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err("Corrupt PNG");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case (((unsigned) ('t') << 24) + ((unsigned) ('R') << 16) + ((unsigned) ('N') << 8) + (unsigned) ('S')): {
            if (first) return stbi__err("Corrupt PNG");
            if (z->idata) return stbi__err("Corrupt PNG");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err("Corrupt PNG");
               if (c.length > pal_len) return stbi__err("Corrupt PNG");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err("Corrupt PNG");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("Corrupt PNG");
               has_trans = 1;
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s);
               } else {
                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth];
               }
            }
            break;
         }

         case (((unsigned) ('I') << 24) + ((unsigned) ('D') << 16) + ((unsigned) ('A') << 8) + (unsigned) ('T')): {
            if (first) return stbi__err("Corrupt PNG");
            if (pal_img_n && !pal_len) return stbi__err("Corrupt PNG");
            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               (void)sizeof(idata_limit_old);
               p = (stbi_uc *) Memory::realloc(z->idata, idata_limit_old, idata_limit); if (p == __null) return stbi__err("Out of memory");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("Corrupt PNG");
            ioff += c.length;
            break;
         }

         case (((unsigned) ('I') << 24) + ((unsigned) ('E') << 16) + ((unsigned) ('N') << 8) + (unsigned) ('D')): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err("Corrupt PNG");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == __null) return stbi__err("Corrupt PNG");

            bpl = (s->img_x * z->depth + 7) / 8;
            raw_len = bpl * s->img_y * s->img_n + s->img_y ;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == __null) return 0;
            Memory::dealloc(z->idata); z->idata = __null;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {

               s->img_n = pal_img_n;
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {

               ++s->img_n;
            }
            Memory::dealloc(z->expanded); z->expanded = __null;
            return 1;
         }

         default:

            if (first) return stbi__err("Corrupt PNG");
            if ((c.type & (1 << 29)) == 0) {


               static char invalid_chunk[] = "XXXX PNG chunk not known";
               invalid_chunk[0] = ((stbi_uc) ((c.type >> 24) & 255));
               invalid_chunk[1] = ((stbi_uc) ((c.type >> 16) & 255));
               invalid_chunk[2] = ((stbi_uc) ((c.type >> 8) & 255));
               invalid_chunk[3] = ((stbi_uc) ((c.type >> 0) & 255));

               return stbi__err("PNG not supported: unknown PNG chunk type");
            }
            stbi__skip(s, c.length);
            break;
      }

      stbi__get32be(s);
   }
}

static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=__null;
   if (req_comp < 0 || req_comp > 4) return ((unsigned char *)(size_t) (stbi__err("Internal error")?__null:__null));
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth < 8)
         ri->bits_per_channel = 8;
      else
         ri->bits_per_channel = p->depth;
      result = p->out;
      p->out = __null;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == __null) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   Memory::dealloc(p->out); p->out = __null;
   Memory::dealloc(p->expanded); p->expanded = __null;
   Memory::dealloc(p->idata); p->idata = __null;

   return result;
}

static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}

static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}

static int stbi__png_is16(stbi__context *s)
{
   stbi__png p;
   p.s = s;
   if (!stbi__png_info_raw(&p, __null, __null, __null))
    return 0;
   if (p.depth != 16) {
      stbi__rewind(p.s);
      return 0;
   }
   return 1;
}





static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s);
   stbi__get16le(s);
   stbi__get16le(s);
   stbi__get32le(s);
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}

static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}



static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) n += 16, z >>= 16;
   if (z >= 0x00100) n += 8, z >>= 8;
   if (z >= 0x00010) n += 4, z >>= 4;
   if (z >= 0x00004) n += 2, z >>= 2;
   if (z >= 0x00002) n += 1, z >>= 1;
   return n;
}

static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >> 1) & 0x55555555);
   a = (a & 0x33333333) + ((a >> 2) & 0x33333333);
   a = (a + (a >> 4)) & 0x0f0f0f0f;
   a = (a + (a >> 8));
   a = (a + (a >> 16));
   return a & 0xff;
}




static int stbi__shiftsigned(int v, int shift, int bits)
{
   static unsigned int mul_table[9] = {
      0,
      0xff , 0x55 , 0x49 , 0x11 ,
      0x21 , 0x41 , 0x81 , 0x01 ,
   };
   static unsigned int shift_table[9] = {
      0, 0,0,1,0,2,4,6,0,
   };
   if (shift < 0)
      v <<= -shift;
   else
      v >>= shift;
   (__builtin_expect(!(v >= 0 && v < 256), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 5047, "v >= 0 && v < 256") : (void)0);
   v >>= (8-bits);
   (__builtin_expect(!(bits >= 0 && bits <= 8), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 5049, "bits >= 0 && bits <= 8") : (void)0);
   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
}

typedef struct
{
   int bpp, offset, hsz;
   unsigned int mr,mg,mb,ma, all_a;
} stbi__bmp_data;

static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return ((unsigned char *)(size_t) (stbi__err("Corrupt BMP")?__null:__null));
   stbi__get32le(s);
   stbi__get16le(s);
   stbi__get16le(s);
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return ((unsigned char *)(size_t) (stbi__err("BMP type not supported: unknown")?__null:__null));
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return ((unsigned char *)(size_t) (stbi__err("bad BMP")?__null:__null));
   info->bpp = stbi__get16le(s);
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return ((unsigned char *)(size_t) (stbi__err("BMP type not supported: RLE")?__null:__null));
      stbi__get32le(s);
      stbi__get32le(s);
      stbi__get32le(s);
      stbi__get32le(s);
      stbi__get32le(s);
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               if (info->bpp == 32) {
                  info->mr = 0xffu << 16;
                  info->mg = 0xffu << 8;
                  info->mb = 0xffu << 0;
                  info->ma = 0xffu << 24;
                  info->all_a = 0;
               } else {
                  info->mr = 31u << 10;
                  info->mg = 31u << 5;
                  info->mb = 31u << 0;
               }
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);

               if (info->mr == info->mg && info->mg == info->mb) {

                  return ((unsigned char *)(size_t) (stbi__err("bad BMP")?__null:__null));
               }
            } else
               return ((unsigned char *)(size_t) (stbi__err("bad BMP")?__null:__null));
         }
      } else {
         int i;
         if (hsz != 108 && hsz != 124)
            return ((unsigned char *)(size_t) (stbi__err("bad BMP")?__null:__null));
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         stbi__get32le(s);
         for (i=0; i < 12; ++i)
            stbi__get32le(s);
         if (hsz == 124) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
      }
   }
   return (void *) 1;
}


static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   (void)sizeof(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == __null)
      return __null;

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - 14 - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - 14 - info.hsz) >> 2;
   }

   s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3)
      target = req_comp;
   else
      target = s->img_n;


   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return ((unsigned char *)(size_t) (stbi__err("Corrupt BMP")?__null:__null));

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null));
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { Memory::dealloc(out); return ((unsigned char *)(size_t) (stbi__err("Corrupt BMP")?__null:__null)); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - 14 - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { Memory::dealloc(out); return ((unsigned char *)(size_t) (stbi__err("Corrupt BMP")?__null:__null)); }
      pad = (-width)&3;
      if (info.bpp == 1) {
         for (j=0; j < (int) s->img_y; ++j) {
            int bit_offset = 7, v = stbi__get8(s);
            for (i=0; i < (int) s->img_x; ++i) {
               int color = (v>>bit_offset)&0x1;
               out[z++] = pal[color][0];
               out[z++] = pal[color][1];
               out[z++] = pal[color][2];
               if((--bit_offset) < 0) {
                  bit_offset = 7;
                  v = stbi__get8(s);
               }
            }
            stbi__skip(s, pad);
         }
      } else {
         for (j=0; j < (int) s->img_y; ++j) {
            for (i=0; i < (int) s->img_x; i += 2) {
               int v=stbi__get8(s),v2=0;
               if (info.bpp == 4) {
                  v2 = v & 15;
                  v >>= 4;
               }
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               v = (info.bpp == 8) ? stbi__get8(s) : v2;
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
            }
            stbi__skip(s, pad);
         }
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - 14 - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { Memory::dealloc(out); return ((unsigned char *)(size_t) (stbi__err("Corrupt BMP")?__null:__null)); }

         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               unsigned int a;
               out[z++] = ((stbi_uc) ((stbi__shiftsigned(v & mr, rshift, rcount)) & 255));
               out[z++] = ((stbi_uc) ((stbi__shiftsigned(v & mg, gshift, gcount)) & 255));
               out[z++] = ((stbi_uc) ((stbi__shiftsigned(v & mb, bshift, bcount)) & 255));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = ((stbi_uc) ((a) & 255));
            }
         }
         stbi__skip(s, pad);
      }
   }


   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out + j *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i], p1[i] = p2[i], p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == __null) return out;
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}






static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{

   if (is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8: return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;

      case 15: if(is_rgb16) *is_rgb16 = 1;
               return STBI_rgb;
      case 24:
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}

static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);
    tga_colormap_type = stbi__get8(s);
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;
    }
    tga_image_type = stbi__get8(s);
    if ( tga_colormap_type == 1 ) {
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);
        sz = stbi__get8(s);
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);
        tga_colormap_bpp = sz;
    } else {
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,9);
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;
    }
    tga_bits_per_pixel = stbi__get8(s);
    stbi__get8(s);
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {


            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, __null);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), __null);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;
}

static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);
   tga_color_type = stbi__get8(s);
   if ( tga_color_type > 1 ) goto errorEnd;
   sz = stbi__get8(s);
   if ( tga_color_type == 1 ) {
      if (sz != 1 && sz != 9) goto errorEnd;
      stbi__skip(s,4);
      sz = stbi__get8(s);
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);
   } else {
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd;
      stbi__skip(s,9);
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;
   if ( stbi__get16le(s) < 1 ) goto errorEnd;
   sz = stbi__get8(s);
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd;
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1;

errorEnd:
   stbi__rewind(s);
   return res;
}


static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;

   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;

   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);





}

static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{

   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);


   unsigned char *tga_data;
   unsigned char *tga_palette = __null;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   (void)sizeof(ri);


   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);


   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp)
      return ((unsigned char *)(size_t) (stbi__err("Can't find out TGA pixelformat")?__null:__null));


   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return ((unsigned char *)(size_t) (stbi__err("Corrupt TGA")?__null:__null));

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null));


   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else {

      if ( tga_indexed)
      {

         stbi__skip(s, tga_palette_start );

         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            Memory::dealloc(tga_data);
            return ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null));
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            (__builtin_expect(!(tga_comp == STBI_rgb), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 5532, "tga_comp == STBI_rgb") : (void)0);
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               Memory::dealloc(tga_data);
               Memory::dealloc(tga_palette);
               return ((unsigned char *)(size_t) (stbi__err("Corrupt TGA")?__null:__null));
         }
      }

      for (i=0; i < tga_width * tga_height; ++i)
      {

         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {

               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }

         if ( read_next_pixel )
         {

            if ( tga_indexed )
            {

               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {

                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               (__builtin_expect(!(tga_comp == STBI_rgb), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Graphics 2D/stb_image.h", 5581, "tga_comp == STBI_rgb") : (void)0);
               stbi__tga_read_rgb16(s, raw_data);
            } else {

               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }

            read_next_pixel = 0;
         }


         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];


         --RLE_count;
      }

      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }

      if ( tga_palette != __null )
      {
         Memory::dealloc(tga_palette);
      }
   }


   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }


   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);



   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;

   return tga_data;
}






static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}

static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {

      } else if (len < 128) {

         len++;
         if (len > nleft) return 0;
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc val;


         len = 257 - len;
         if (len > nleft) return 0;
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}

static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   (void)sizeof(ri);


   if (stbi__get32be(s) != 0x38425053)
      return ((unsigned char *)(size_t) (stbi__err("Corrupt PSD image")?__null:__null));


   if (stbi__get16be(s) != 1)
      return ((unsigned char *)(size_t) (stbi__err("Unsupported version of PSD image")?__null:__null));


   stbi__skip(s, 6 );


   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return ((unsigned char *)(size_t) (stbi__err("Unsupported number of channels in PSD image")?__null:__null));


   h = stbi__get32be(s);
   w = stbi__get32be(s);


   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return ((unsigned char *)(size_t) (stbi__err("PSD bit depth is not 8 or 16 bit")?__null:__null));
# 5744 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
   if (stbi__get16be(s) != 3)
      return ((unsigned char *)(size_t) (stbi__err("PSD is not in RGB color format")?__null:__null));


   stbi__skip(s,stbi__get32be(s) );


   stbi__skip(s, stbi__get32be(s) );


   stbi__skip(s, stbi__get32be(s) );





   compression = stbi__get16be(s);
   if (compression > 1)
      return ((unsigned char *)(size_t) (stbi__err("PSD has an unknown compression format")?__null:__null));


   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return ((unsigned char *)(size_t) (stbi__err("Corrupt PSD")?__null:__null));



   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null));
   pixelCount = w*h;





   if (compression) {
# 5794 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
      stbi__skip(s, h * channelCount * 2 );


      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {

            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {

            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               Memory::dealloc(out);
               return ((unsigned char *)(size_t) (stbi__err("bad RLE data")?__null:__null));
            }
         }
      }

   } else {




      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {

            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }


   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }


   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == __null) return out;
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}
# 5906 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,"PICT"))
      return 0;

   return 1;
}

typedef struct
{
   stbi_uc size,type,channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return ((unsigned char *)(size_t) (stbi__err("PIC file too short")?__null:__null));
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}

static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask=0x80,i;

   for (i=0;i<4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp=0,num_packets=0,y,chained;
   stbi__pic_packet packets[10];



   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return ((unsigned char *)(size_t) (stbi__err("too many packets")?__null:__null));

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size = stbi__get8(s);
      packet->type = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s)) return ((unsigned char *)(size_t) (stbi__err("file too short (reading packets)")?__null:__null));
      if (packet->size != 8) return ((unsigned char *)(size_t) (stbi__err("packet isn't 8bpp")?__null:__null));
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return ((unsigned char *)(size_t) (stbi__err("packet has bad compression type")?__null:__null));

            case 0: {
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1:
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s)) return ((unsigned char *)(size_t) (stbi__err("file too short (pure read count)")?__null:__null));

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value)) return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s)) return ((unsigned char *)(size_t) (stbi__err("file too short (mixed read count)")?__null:__null));

                  if (count >= 128) {
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return ((unsigned char *)(size_t) (stbi__err("scanline overrun")?__null:__null));

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else {
                     ++count;
                     if (count>left) return ((unsigned char *)(size_t) (stbi__err("scanline overrun")?__null:__null));

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}

static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   (void)sizeof(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);
   if (stbi__at_eof(s)) return ((unsigned char *)(size_t) (stbi__err("file too short (pic header)")?__null:__null));
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return ((unsigned char *)(size_t) (stbi__err("PIC image too large to decode")?__null:__null));

   stbi__get32be(s);
   stbi__get16be(s);
   stbi__get16be(s);


   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      Memory::dealloc(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}

static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}
# 6598 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, "#?RGBE\n");
       stbi__rewind(s);
   }
   return r;
}


static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == 1024 -1) {

         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;

      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1;
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1;
         case 1: output[0] = 0;
                 break;
      }
   }
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[1024];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   (void)sizeof(ri);


   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
      return ((float *)(size_t) (stbi__err("Corrupt HDR image")?__null:__null));


   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid) return ((float *)(size_t) (stbi__err("Unsupported HDR format")?__null:__null));



   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3)) return ((float *)(size_t) (stbi__err("Unsupported HDR format")?__null:__null));
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3)) return ((float *)(size_t) (stbi__err("Unsupported HDR format")?__null:__null));
   token += 3;
   width = (int) strtol(token, __null, 10);

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
      return ((float *)(size_t) (stbi__err("HDR image is too large")?__null:__null));


   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
      return ((float *)(size_t) (stbi__err("Out of memory")?__null:__null));



   if ( width < 8 || width >= 32768) {

      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            stbi__getn(s, rgbe, 4);
            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
   } else {

      scanline = __null;

      for (j = 0; j < height; ++j) {
         c1 = stbi__get8(s);
         c2 = stbi__get8(s);
         len = stbi__get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {


            stbi_uc rgbe[4];
            rgbe[0] = (stbi_uc) c1;
            rgbe[1] = (stbi_uc) c2;
            rgbe[2] = (stbi_uc) len;
            rgbe[3] = (stbi_uc) stbi__get8(s);
            stbi__hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            Memory::dealloc(scanline);
            goto main_decode_loop;
         }
         len <<= 8;
         len |= stbi__get8(s);
         if (len != width) { Memory::dealloc(hdr_data); Memory::dealloc(scanline); return ((float *)(size_t) (stbi__err("corrupt HDR")?__null:__null)); }
         if (scanline == __null) {
            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
            if (!scanline) {
               Memory::dealloc(hdr_data);
               return ((float *)(size_t) (stbi__err("Out of memory")?__null:__null));
            }
         }

         for (k = 0; k < 4; ++k) {
            int nleft;
            i = 0;
            while ((nleft = width - i) > 0) {
               count = stbi__get8(s);
               if (count > 128) {

                  value = stbi__get8(s);
                  count -= 128;
                  if (count > nleft) { Memory::dealloc(hdr_data); Memory::dealloc(scanline); return ((float *)(size_t) (stbi__err("bad RLE data in HDR")?__null:__null)); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = value;
               } else {

                  if (count > nleft) { Memory::dealloc(hdr_data); Memory::dealloc(scanline); return ((float *)(size_t) (stbi__err("bad RLE data in HDR")?__null:__null)); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = stbi__get8(s);
               }
            }
         }
         for (i=0; i < width; ++i)
            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
      }
      if (scanline)
         Memory::dealloc(scanline);
   }

   return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[1024];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
       stbi__rewind( s );
       return 0;
   }

   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid) {
       stbi__rewind( s );
       return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *x = (int) strtol(token, __null, 10);
   *comp = 3;
   return 1;
}



static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   stbi__rewind( s );
   if (p == __null)
      return 0;
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) *comp = info.ma ? 4 : 3;
   return 1;
}



static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy, depth;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 8 && depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 3) {
       stbi__rewind( s );
       return 0;
   }
   *comp = 4;
   return 1;
}

static int stbi__psd_is16(stbi__context *s)
{
   int channelCount, depth;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   (void) stbi__get32be(s);
   (void) stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}



static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
      stbi__rewind(s);
      return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
      stbi__rewind( s);
      return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
      stbi__rewind( s );
      return 0;
   }

   stbi__skip(s, 8);

   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return 0;

      packet = &packets[num_packets++];
      chained = stbi__get8(s);
      packet->size = stbi__get8(s);
      packet->type = stbi__get8(s);
      packet->channel = stbi__get8(s);
      act_comp |= packet->channel;

      if (stbi__at_eof(s)) {
          stbi__rewind( s );
          return 0;
      }
      if (packet->size != 8) {
          stbi__rewind( s );
          return 0;
      }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}
# 6997 "include/Simpleton/SDL/../Graphics 2D/stb_image.h"
static int stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}

static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   (void)sizeof(ri);

   if (!stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n))
      return 0;

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad3sizes_valid(s->img_n, s->img_x, s->img_y, 0))
      return ((unsigned char *)(size_t) (stbi__err("PNM too large")?__null:__null));

   out = (stbi_uc *) stbi__malloc_mad3(s->img_n, s->img_x, s->img_y, 0);
   if (!out) return ((unsigned char *)(size_t) (stbi__err("Out of memory")?__null:__null));
   stbi__getn(s, out, s->img_n * s->img_x * s->img_y);

   if (req_comp && req_comp != s->img_n) {
      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
      if (out == __null) return out;
   }
   return out;
}

static int stbi__pnm_isspace(char c)
{
   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}

static void stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
         *c = (char) stbi__get8(s);

      if (stbi__at_eof(s) || *c != '#')
         break;

      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
         *c = (char) stbi__get8(s);
   }
}

static int stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9';
}

static int stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
      value = value*10 + (*c - '0');
      *c = (char) stbi__get8(s);
   }

   return value;
}

static int stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);


   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind(s);
       return 0;
   }

   *comp = (t == '6') ? 3 : 1;

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c);
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c);
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);

   if (maxv > 255)
      return stbi__err("PPM image not 8-bit");
   else
      return 1;
}


static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{

   if (stbi__jpeg_info(s, x, y, comp)) return 1;



   if (stbi__png_info(s, x, y, comp)) return 1;







   if (stbi__bmp_info(s, x, y, comp)) return 1;



   if (stbi__psd_info(s, x, y, comp)) return 1;



   if (stbi__pic_info(s, x, y, comp)) return 1;



   if (stbi__pnm_info(s, x, y, comp)) return 1;



   if (stbi__hdr_info(s, x, y, comp)) return 1;




   if (stbi__tga_info(s, x, y, comp))
       return 1;

   return stbi__err("Image not of any known type, or corrupt");
}

static int stbi__is_16_main(stbi__context *s)
{

   if (stbi__png_is16(s)) return 1;



   if (stbi__psd_is16(s)) return 1;


   return 0;
}


static int stbi_info(char const *filename, int *x, int *y, int *comp)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("Unable to open file");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}

static int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,0);
   return r;
}

static int stbi_is_16_bit(char const *filename)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("Unable to open file");
    result = stbi_is_16_bit_from_file(f);
    fclose(f);
    return result;
}

static int stbi_is_16_bit_from_file(FILE *f)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__is_16_main(&s);
   fseek(f,pos,0);
   return r;
}


static int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}

static int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}

static int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__is_16_main(&s);
}

static int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__is_16_main(&s);
}
# 26 "include/Simpleton/SDL/../Graphics 2D/load surface.inl" 2

#pragma clang diagnostic pop

inline G2D::SurfaceLoadError::SurfaceLoadError(
  const std::string_view file,
  const std::string_view reason
) : std::runtime_error(
      std::string("Failed to load surface: \"")
      + std::string(file)
      + "\": "
      + std::string(reason)
    ) {}

inline G2D::Surface G2D::loadSurface(const std::string_view path, const int bpp) {
  Memory::FileHandle file = Memory::openFileRead(path);
  int width, height;
  uint8_t *const data = stbi_load_from_file(file.get(), &width, &height, nullptr, bpp);
  if (data == nullptr) {
    throw SurfaceLoadError(path, stbi_failure_reason());
  }
  return Surface(width, height, bpp, width * bpp, data);
}

inline G2D::Surface G2D::loadSurface(const std::string_view path) {
  Memory::FileHandle file = Memory::openFileRead(path);
  int width, height, bytesPerPixel;
  uint8_t *const data = stbi_load_from_file(file.get(), &width, &height, &bytesPerPixel, 0);
  if (data == nullptr) {
    throw SurfaceLoadError(path, stbi_failure_reason());
  }
  return Surface(width, height, bytesPerPixel, width * bytesPerPixel, data);
}

inline G2D::Surface G2D::loadSurfaceRGB(const std::string_view path) {
  return loadSurface(path, STBI_rgb);
}

inline G2D::Surface G2D::loadSurfaceRGBA(const std::string_view path) {
  return loadSurface(path, STBI_rgb_alpha);
}
# 33 "include/Simpleton/SDL/../Graphics 2D/load surface.hpp" 2
# 17 "include/Simpleton/SDL/renderer.hpp" 2

namespace SDL {
  using Color = glm::tvec4<uint8_t>;

  class Renderer {
  public:
    using value_type = SDL_Renderer *; constexpr Renderer() noexcept : renderer{} {} constexpr Renderer(std::nullptr_t) noexcept : renderer{} {} explicit Renderer(const value_type renderer) noexcept : renderer{renderer} {} Renderer(Renderer &&other) noexcept : renderer{other.release()} {} Renderer &operator=(Renderer &&other) noexcept { reset(other.release()); return *this; } Renderer &operator=(std::nullptr_t) noexcept { reset(); return *this; } ~Renderer() { SDL_DestroyRenderer(renderer); } value_type release() noexcept { return std::exchange(renderer, value_type{}); } void reset(const value_type newrenderer = {}) noexcept { SDL_DestroyRenderer(renderer); renderer = newrenderer; } value_type get() const noexcept { return renderer; } explicit operator bool() const noexcept { return renderer != value_type{}; } bool operator==(const Renderer &other) const noexcept { return renderer == other.renderer; } bool operator!=(const Renderer &other) const noexcept { return renderer != other.renderer; } bool operator<(const Renderer &other) const noexcept { return renderer < other.renderer; } bool operator<=(const Renderer &other) const noexcept { return renderer <= other.renderer; } bool operator>(const Renderer &other) const noexcept { return renderer > other.renderer; } bool operator>=(const Renderer &other) const noexcept { return renderer >= other.renderer; } friend bool operator==(const Renderer &obj, std::nullptr_t) noexcept { return obj.renderer == value_type{}; } friend bool operator!=(const Renderer &obj, std::nullptr_t) noexcept { return obj.renderer != value_type{}; } friend bool operator<(const Renderer &obj, std::nullptr_t) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return false; } else { return obj.renderer < value_type{}; } } friend bool operator<=(const Renderer &obj, std::nullptr_t) noexcept { return obj.renderer <= value_type{}; } friend bool operator>(const Renderer &obj, std::nullptr_t) noexcept { return obj.renderer > value_type{}; } friend bool operator>=(const Renderer &obj, std::nullptr_t) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return true; } else { return obj.renderer >= value_type{}; } } friend bool operator==(std::nullptr_t, const Renderer &obj) noexcept { return value_type{} == obj.renderer; } friend bool operator!=(std::nullptr_t, const Renderer &obj) noexcept { return value_type{} != obj.renderer; } friend bool operator<(std::nullptr_t, const Renderer &obj) noexcept { return value_type{} < obj.renderer; } friend bool operator<=(std::nullptr_t, const Renderer &obj) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return true; } else { return value_type{} <= obj.renderer; } } friend bool operator>(std::nullptr_t, const Renderer &obj) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return false; } else { return value_type{} > obj.renderer; } } friend bool operator>=(std::nullptr_t, const Renderer &obj) noexcept { return value_type{} >= obj.renderer; } void swap(Renderer &other) noexcept { std::swap(renderer, other.renderer); } friend void swap(Renderer &a, Renderer &b) noexcept { std::swap(a.renderer, b.renderer); }

    void setColor(Color);
    Color getColor() const;

    void present();
    void clear(Color = {0, 0, 0, 0});

    Texture texture(const SDL::Surface &);
    Texture texture(const G2D::Surface &);
    Texture texture(std::string_view);

  private:
    SDL_Renderer *renderer;
  };
}


# 1 "include/Simpleton/SDL/renderer.inl" 1
# 11 "include/Simpleton/SDL/renderer.inl"
inline void SDL::Renderer::setColor(const Color color) {
  ((SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a)) != 0 ? throw SDL::Error() : void());
}

inline SDL::Color SDL::Renderer::getColor() const {
  Color color;
  ((SDL_GetRenderDrawColor(renderer, &color.r, &color.g, &color.b, &color.a)) != 0 ? throw SDL::Error() : void());
  return color;
}

inline void SDL::Renderer::present() {
  SDL_RenderPresent(renderer);
}

inline void SDL::Renderer::clear(const Color color) {
  setColor(color);
  ((SDL_RenderClear(renderer)) != 0 ? throw SDL::Error() : void());
}

inline SDL::Texture SDL::Renderer::texture(const SDL::Surface &surface) {
  return Texture{SDL::detail::checkSDLNull(SDL_CreateTextureFromSurface( renderer, surface.get() ))};


}

inline SDL::Texture SDL::Renderer::texture(const G2D::Surface &surface) {
  uint32_t format;
  if (surface.bytesPerPixel() == 4) {
    format = SDL_PIXELFORMAT_ABGR8888;
  } else if (surface.bytesPerPixel() == 3) {
    format = SDL_PIXELFORMAT_BGR888;
  } else if (surface.bytesPerPixel() == 1) {
    format = SDL_PIXELFORMAT_INDEX8;
  } else {
    format = SDL_PIXELFORMAT_UNKNOWN;
    (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/renderer.inl", 46, "false") : (void)0);
  }
  Texture tex{SDL::detail::checkSDLNull(SDL_CreateTexture( renderer, format, SDL_TEXTUREACCESS_STATIC, surface.width(), surface.height() ))};






  ((SDL_UpdateTexture( tex.get(), nullptr, surface.data(), surface.pitch() )) != 0 ? throw SDL::Error() : void());





  return tex;
}

inline SDL::Texture SDL::Renderer::texture(const std::string_view path) {
  return texture(G2D::loadSurface(path));
}
# 41 "include/Simpleton/SDL/renderer.hpp" 2
# 16 "include/Simpleton/SDL/library.hpp" 2

# 1 "include/Simpleton/SDL/../Utils/instance limiter.hpp" 1
# 14 "include/Simpleton/SDL/../Utils/instance limiter.hpp"
namespace Utils {
  class TooManyInstances : public std::exception {};

  template <typename T>
  class TooManyInstancesOf final : public TooManyInstances {
  public:
    const char *what() const noexcept override {
      return "Too many instances";
    }
  };
}
# 105 "include/Simpleton/SDL/../Utils/instance limiter.hpp"
namespace Utils {

  template <typename T, size_t>
  class LimitInstances {
  protected:
    LimitInstances() = default;
    LimitInstances(const LimitInstances &) = default;
    LimitInstances(LimitInstances &&) = default;
    ~LimitInstances() {
      static_assert(std::is_base_of<LimitInstances, T>::value);
    }

    LimitInstances &operator=(const LimitInstances &) = default;
    LimitInstances &operator=(LimitInstances &&) = default;
  };


  template <typename T>
  class LimitInstances<T, 1> {
  protected:
    LimitInstances() = default;
    LimitInstances(const LimitInstances &) = delete;
    LimitInstances(LimitInstances &&) = default;
    ~LimitInstances() {
      static_assert(std::is_base_of<LimitInstances, T>::value);
    }

    LimitInstances &operator=(const LimitInstances &) = delete;
    LimitInstances &operator=(LimitInstances &&) = default;

  public:
    static bool wasCreated() {
      return true;
    }
  };
}



namespace Utils {

  template <typename T>
  class LimitInstances<T, 0> {
  protected:
    LimitInstances() = delete;
    LimitInstances(const LimitInstances &) = delete;
    LimitInstances(LimitInstances &&) = delete;
    ~LimitInstances() = delete;

    LimitInstances &operator=(const LimitInstances &) = delete;
    LimitInstances &operator=(LimitInstances &&) = delete;
  };


  template <typename T>
  using ForceSingleton = LimitInstances<T, 1>;



  template <typename T>
  using ForceSymbol = LimitInstances<T, 0>;



  template <typename T>
  using ForceStaticClass = LimitInstances<T, 0>;
}
# 18 "include/Simpleton/SDL/library.hpp" 2

namespace SDL {
  namespace detail {
    void deleteLibrary(bool);
  }

  class Library final : public Utils::ForceSingleton<Library> {
  public:
    using value_type = bool; constexpr Library() noexcept : initialized{} {} constexpr Library(std::nullptr_t) noexcept : initialized{} {} explicit Library(const value_type initialized) noexcept : initialized{initialized} {} Library(Library &&other) noexcept : initialized{other.release()} {} Library &operator=(Library &&other) noexcept { reset(other.release()); return *this; } Library &operator=(std::nullptr_t) noexcept { reset(); return *this; } ~Library() { detail::deleteLibrary(initialized); } value_type release() noexcept { return std::exchange(initialized, value_type{}); } void reset(const value_type newinitialized = {}) noexcept { detail::deleteLibrary(initialized); initialized = newinitialized; } value_type get() const noexcept { return initialized; } explicit operator bool() const noexcept { return initialized != value_type{}; } bool operator==(const Library &other) const noexcept { return initialized == other.initialized; } bool operator!=(const Library &other) const noexcept { return initialized != other.initialized; } bool operator<(const Library &other) const noexcept { return initialized < other.initialized; } bool operator<=(const Library &other) const noexcept { return initialized <= other.initialized; } bool operator>(const Library &other) const noexcept { return initialized > other.initialized; } bool operator>=(const Library &other) const noexcept { return initialized >= other.initialized; } friend bool operator==(const Library &obj, std::nullptr_t) noexcept { return obj.initialized == value_type{}; } friend bool operator!=(const Library &obj, std::nullptr_t) noexcept { return obj.initialized != value_type{}; } friend bool operator<(const Library &obj, std::nullptr_t) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return false; } else { return obj.initialized < value_type{}; } } friend bool operator<=(const Library &obj, std::nullptr_t) noexcept { return obj.initialized <= value_type{}; } friend bool operator>(const Library &obj, std::nullptr_t) noexcept { return obj.initialized > value_type{}; } friend bool operator>=(const Library &obj, std::nullptr_t) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return true; } else { return obj.initialized >= value_type{}; } } friend bool operator==(std::nullptr_t, const Library &obj) noexcept { return value_type{} == obj.initialized; } friend bool operator!=(std::nullptr_t, const Library &obj) noexcept { return value_type{} != obj.initialized; } friend bool operator<(std::nullptr_t, const Library &obj) noexcept { return value_type{} < obj.initialized; } friend bool operator<=(std::nullptr_t, const Library &obj) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return true; } else { return value_type{} <= obj.initialized; } } friend bool operator>(std::nullptr_t, const Library &obj) noexcept { if constexpr (std::is_unsigned_v<value_type>) { return false; } else { return value_type{} > obj.initialized; } } friend bool operator>=(std::nullptr_t, const Library &obj) noexcept { return value_type{} >= obj.initialized; } void swap(Library &other) noexcept { std::swap(initialized, other.initialized); } friend void swap(Library &a, Library &b) noexcept { std::swap(a.initialized, b.initialized); }

  private:
    bool initialized;
  };

  Library makeLibrary(Uint32 = ( 0x00000001u | 0x00000010u | 0x00000020u | 0x00004000u | 0x00000200u | 0x00001000u | 0x00002000u ));

  Window makeWindow(const Window::Desc &);
  Window makeWindow(const char *, int, int);
  Renderer makeRenderer(Window &, bool);
}


# 1 "include/Simpleton/SDL/library.inl" 1








# 1 "include/Simpleton/SDL/../Utils/bool enable.hpp" 1
# 13 "include/Simpleton/SDL/../Utils/bool enable.hpp"
# 1 "include/Simpleton/SDL/../Utils/int least.hpp" 1
# 13 "include/Simpleton/SDL/../Utils/int least.hpp"
# 1 "include/Simpleton/SDL/../Utils/../Math/round.hpp" 1
# 12 "include/Simpleton/SDL/../Utils/../Math/round.hpp"
# 1 "include/Simpleton/SDL/../Utils/../Math/pow.hpp" 1
# 12 "include/Simpleton/SDL/../Utils/../Math/pow.hpp"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 2 3 4
# 75 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn)) __attribute__((__disable_tail_calls__));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/cassert" 3
# 13 "include/Simpleton/SDL/../Utils/../Math/pow.hpp" 2

# 1 "include/Simpleton/SDL/../Utils/../Math/../Utils/bits.hpp" 1
# 15 "include/Simpleton/SDL/../Utils/../Math/../Utils/bits.hpp"
namespace Utils {

  template <typename ...Ts>
  constexpr size_t bits = ((sizeof(Ts) * 8) + ...);
}
# 15 "include/Simpleton/SDL/../Utils/../Math/pow.hpp" 2

namespace Math {
  template <typename Number>
  constexpr Number square(const Number n) {
    return n * n;
  }

  template <typename Number>
  constexpr Number cube(const Number n) {
    return n * n * n;
  }



  template <typename Number, typename Exponent>
  constexpr std::enable_if_t<std::is_unsigned_v<Exponent>, Number>
  pow(const Number num, Exponent exp) {
    Number out = Number(1);
    while (exp--) {
      out *= num;
    }
    return out;
  }

  template <typename Number, typename Exponent>
  constexpr std::enable_if_t<std::is_signed_v<Exponent>, Number>
  pow(const Number num, const Exponent exp) {
    if (exp < Exponent(0)) {
      return Number(1) / pow(num, static_cast<std::make_unsigned_t<Exponent>>(-exp));
    } else {
      return pow(num, static_cast<std::make_unsigned_t<Exponent>>(exp));
    }
  }

  template <long long EXPONENT, typename Number>
  constexpr Number pow(const Number num) {
    if constexpr (EXPONENT < 0ll) {
      (__builtin_expect(!(num != Number(0)), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 52, "num != Number(0)") : (void)0);
      return Number(1) / pow<-EXPONENT>(num);
    } else if constexpr (EXPONENT == 0ll) {
      return Number(1);
    } else if constexpr (EXPONENT == 1ll) {
      return num;
    } else if constexpr (EXPONENT == 2ll) {
      return num * num;
    } else {
      const Number half = pow<EXPONENT / 2ll>(num);
      return half * half * pow<EXPONENT % 2ll>(num);
    }
  }




  constexpr unsigned long long log2(const unsigned long long num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 70, "num != 0") : (void)0);

    return (Utils::bits<long long> - 1) - __builtin_clzll(num);
  }


  constexpr unsigned long log2(const unsigned long num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 77, "num != 0") : (void)0);

    return (Utils::bits<long> - 1) - __builtin_clzl(num);
  }


  constexpr unsigned log2(const unsigned num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 84, "num != 0") : (void)0);

    return (Utils::bits<int> - 1) - __builtin_clz(num);
  }


  constexpr unsigned short log2(const unsigned short num) {
    return log2(static_cast<unsigned>(num));
  }


  constexpr unsigned char log2(const unsigned char num) {
    return log2(static_cast<unsigned>(num));
  }




  constexpr unsigned long long log2Ceil(const unsigned long long num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 103, "num != 0") : (void)0);

    const unsigned long long leading = __builtin_clzll(num);
    constexpr unsigned long long bits = Utils::bits<long long>;
    return bits - leading - (leading + __builtin_ctzll(num) == bits - 1);
  }


  constexpr unsigned long log2Ceil(const unsigned long num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 112, "num != 0") : (void)0);

    const unsigned long leading = __builtin_clzl(num);
    constexpr unsigned long bits = Utils::bits<long>;
    return bits - leading - (leading + __builtin_ctzl(num) == bits - 1);
  }


  constexpr unsigned log2Ceil(const unsigned num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 121, "num != 0") : (void)0);

    const unsigned leading = __builtin_clz(num);
    constexpr unsigned bits = Utils::bits<int>;
    return bits - leading - (leading + __builtin_ctz(num) == bits - 1);
  }


  constexpr unsigned short log2Ceil(const unsigned short num) {
    return log2Ceil(static_cast<unsigned>(num));
  }


  constexpr unsigned char log2Ceil(const unsigned char num) {
    return log2Ceil(static_cast<unsigned>(num));
  }


  template <typename Number>
  constexpr Number log(const Number base, Number num) {
    (__builtin_expect(!(base > 1), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 141, "base > 1") : (void)0);
    (__builtin_expect(!(num > 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 142, "num > 0") : (void)0);

    Number count = 0;
    while (num /= base) {
      ++count;
    }
    return count;
  }


  template <typename Number>
  constexpr Number logCeil(const Number base, Number num) {
    (__builtin_expect(!(base > 1), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 154, "base > 1") : (void)0);
    (__builtin_expect(!(num > 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 155, "num > 0") : (void)0);

    Number count = 0;
    bool up = false;
    while (Number numDivBase = num / base) {
      up = up || (num % base);
      ++count;
      num = numDivBase;
    }
    return count + up;
  }


  template <typename Number>
  constexpr bool isPowerOf2(const Number num) {
    (__builtin_expect(!(num > 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 170, "num > 0") : (void)0);

    return (num & (num - 1)) == 0;
  }


  template <typename Number>
  constexpr bool isPower(const Number base, Number num) {
    (__builtin_expect(!(base > 1), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 178, "base > 1") : (void)0);
    (__builtin_expect(!(num > 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/pow.hpp", 179, "num > 0") : (void)0);

    while (num % base == 0) {
      num /= base;
    }
    return num == 1;
  }
}
# 13 "include/Simpleton/SDL/../Utils/../Math/round.hpp" 2


namespace Math {

  constexpr unsigned long long ceilToPowerOf2(const unsigned long long num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/round.hpp", 18, "num != 0") : (void)0);

    return (1 << (Utils::bits<long long> - __builtin_clzll(num - 1))) - (num == 1);
  }


  constexpr unsigned long ceilToPowerOf2(const unsigned long num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/round.hpp", 25, "num != 0") : (void)0);

    return (1 << (Utils::bits<long> - __builtin_clzl(num - 1))) - (num == 1);
  }


  constexpr unsigned ceilToPowerOf2(const unsigned num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/round.hpp", 32, "num != 0") : (void)0);

    return (1 << (Utils::bits<int> - __builtin_clz(num - 1))) - (num == 1);
  }


  constexpr unsigned short ceilToPowerOf2(const unsigned short num) {
    return ceilToPowerOf2(static_cast<unsigned>(num));
  }


  constexpr unsigned char ceilToPowerOf2(const unsigned char num) {
    return ceilToPowerOf2(static_cast<unsigned>(num));
  }


  constexpr unsigned long long floorToPowerOf2(const unsigned long long num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/round.hpp", 49, "num != 0") : (void)0);

    return (1 << ((Utils::bits<long long> - 1) - __builtin_clzll(num)));
  }


  constexpr unsigned long floorToPowerOf2(const unsigned long num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/round.hpp", 56, "num != 0") : (void)0);

    return (1 << ((Utils::bits<long> - 1) - __builtin_clzl(num)));
  }


  constexpr unsigned floorToPowerOf2(const unsigned num) {
    (__builtin_expect(!(num != 0), 0) ? __assert_rtn(__func__, "include/Simpleton/SDL/../Utils/../Math/round.hpp", 63, "num != 0") : (void)0);

    return (1 << ((Utils::bits<int> - 1) - __builtin_clz(num)));
  }


  constexpr unsigned short floorToPowerOf2(const unsigned short num) {
    return floorToPowerOf2(static_cast<unsigned>(num));
  }


  constexpr unsigned char floorToPowerOf2(const unsigned char num) {
    return floorToPowerOf2(static_cast<unsigned>(num));
  }
# 93 "include/Simpleton/SDL/../Utils/../Math/round.hpp"
  template <typename SignedInt> constexpr std::enable_if_t< std::is_signed<SignedInt>::value, SignedInt > ceilToPowerOf2(const SignedInt num) { if (num < SignedInt(0)) { return -floorToPowerOf2(static_cast<std::make_unsigned_t<SignedInt>>(-num)); } else { return ceilToPowerOf2(static_cast<std::make_unsigned_t<SignedInt>>(num)); } }

  template <typename SignedInt> constexpr std::enable_if_t< std::is_signed<SignedInt>::value, SignedInt > floorToPowerOf2(const SignedInt num) { if (num < SignedInt(0)) { return -ceilToPowerOf2(static_cast<std::make_unsigned_t<SignedInt>>(-num)); } else { return floorToPowerOf2(static_cast<std::make_unsigned_t<SignedInt>>(num)); } }


  template <typename UnsignedInt>
  constexpr std::enable_if_t<
    std::is_unsigned<UnsignedInt>::value,
    UnsignedInt
  >
  ceilToPower(const UnsignedInt base, const UnsignedInt num) {
    return pow(base, logCeil(base, num));
  }


  template <typename UnsignedInt>
  constexpr std::enable_if_t<
    std::is_unsigned<UnsignedInt>::value,
    UnsignedInt
  >
  floorToPower(const UnsignedInt base, const UnsignedInt num) {
    return pow(base, log(base, num));
  }


  template <typename SignedInt> constexpr std::enable_if_t< std::is_signed<SignedInt>::value, SignedInt > ceilToPower(const SignedInt num) { if (num < SignedInt(0)) { return -floorToPower(static_cast<std::make_unsigned_t<SignedInt>>(-num)); } else { return ceilToPower(static_cast<std::make_unsigned_t<SignedInt>>(num)); } }

  template <typename SignedInt> constexpr std::enable_if_t< std::is_signed<SignedInt>::value, SignedInt > floorToPower(const SignedInt num) { if (num < SignedInt(0)) { return -ceilToPower(static_cast<std::make_unsigned_t<SignedInt>>(-num)); } else { return floorToPower(static_cast<std::make_unsigned_t<SignedInt>>(num)); } }


  template <typename UnsignedInt>
  constexpr std::enable_if_t<
    std::is_unsigned<UnsignedInt>::value,
    UnsignedInt
  >
  ceilToEven(const UnsignedInt num) {
    return (num + UnsignedInt(1)) & ~UnsignedInt(1);
  }


  template <typename UnsignedInt>
  constexpr std::enable_if_t<
    std::is_unsigned<UnsignedInt>::value,
    UnsignedInt
  >
  floorToEven(const UnsignedInt num) {
    return num & ~UnsignedInt(1);
  }


  template <typename SignedInt> constexpr std::enable_if_t< std::is_signed<SignedInt>::value, SignedInt > ceilToEven(const SignedInt num) { if (num < SignedInt(0)) { return -floorToEven(static_cast<std::make_unsigned_t<SignedInt>>(-num)); } else { return ceilToEven(static_cast<std::make_unsigned_t<SignedInt>>(num)); } }

  template <typename SignedInt> constexpr std::enable_if_t< std::is_signed<SignedInt>::value, SignedInt > floorToEven(const SignedInt num) { if (num < SignedInt(0)) { return -ceilToEven(static_cast<std::make_unsigned_t<SignedInt>>(-num)); } else { return floorToEven(static_cast<std::make_unsigned_t<SignedInt>>(num)); } }


  template <typename UnsignedInt>
  constexpr std::enable_if_t<
    std::is_unsigned<UnsignedInt>::value,
    UnsignedInt
  >
  ceilToMultiple(const UnsignedInt factor, const UnsignedInt num) {
    return (num + factor - UnsignedInt(1)) / factor * factor;
  }


  template <typename UnsignedInt>
  constexpr std::enable_if_t<
    std::is_unsigned<UnsignedInt>::value,
    UnsignedInt
  >
  floorToMultiple(const UnsignedInt factor, const UnsignedInt num) {
    return num / factor * factor;
  }


  template <typename SignedInt> constexpr std::enable_if_t< std::is_signed<SignedInt>::value, SignedInt > ceilToMultiple(const SignedInt num) { if (num < SignedInt(0)) { return -floorToMultiple(static_cast<std::make_unsigned_t<SignedInt>>(-num)); } else { return ceilToMultiple(static_cast<std::make_unsigned_t<SignedInt>>(num)); } }

  template <typename SignedInt> constexpr std::enable_if_t< std::is_signed<SignedInt>::value, SignedInt > floorToMultiple(const SignedInt num) { if (num < SignedInt(0)) { return -ceilToMultiple(static_cast<std::make_unsigned_t<SignedInt>>(-num)); } else { return floorToMultiple(static_cast<std::make_unsigned_t<SignedInt>>(num)); } }




  template <typename Num, typename Den>
  constexpr std::enable_if_t<
    std::is_unsigned<Num>::value &&
    std::is_unsigned<Den>::value,
    std::common_type_t<Num, Den>
  >
  divCeil(const Num num, const Den den) {
    return (num + den - 1) / den;
  }


  template <typename Num, typename Den>
  constexpr std::enable_if_t<
    std::is_signed<Num>::value ||
    std::is_signed<Den>::value,
    std::common_type_t<Num, Den>
  >
  divCeil(const Num num, const Den den) {

    return num / den + (((num < 0) ^ (den > 0)) && (num % den));
  }


  template <typename Num, typename Den>
  constexpr std::enable_if_t<
    std::is_unsigned<Num>::value &&
    std::is_unsigned<Den>::value,
    std::common_type_t<Num, Den>
  >
  divRound(const Num num, const Den den) {
    return (num + den / 2) / den;
  }


  template <typename Num, typename Den>
  constexpr std::enable_if_t<
    std::is_signed<Num>::value ||
    std::is_signed<Den>::value,
    std::common_type_t<Num, Den>
  >
  divRound(const Num num, const Den den) {

    return ((num < 0) ^ (den < 0)) ? ((num - den / 2) / den)
                                   : ((num + den / 2) / den);
  }
}
# 14 "include/Simpleton/SDL/../Utils/int least.hpp" 2

namespace Utils {
  template <size_t BYTES>
  struct int_least {
    using type = typename int_least<Math::ceilToPowerOf2(BYTES)>::type;
  };


  template <size_t BYTES>
  using int_least_t = typename int_least<BYTES>::type;


  template <size_t BYTES>
  using uint_least_t = std::make_unsigned_t<int_least_t<BYTES>>;

  template <size_t BYTES>
  struct int_exact {};


  template <size_t BYTES>
  using int_exact_t = typename int_exact<BYTES>::type;


  template <size_t BYTES>
  using uint_exact_t = std::make_unsigned_t<int_exact_t<BYTES>>;
# 52 "include/Simpleton/SDL/../Utils/int least.hpp"
  template <> struct int_least<1> { using type = int8_t; }; template <> struct int_exact<1> { using type = int8_t; };


  template <> struct int_least<2> { using type = int16_t; }; template <> struct int_exact<2> { using type = int16_t; };


  template <> struct int_least<4> { using type = int32_t; }; template <> struct int_exact<4> { using type = int32_t; };


  template <> struct int_least<8> { using type = int64_t; }; template <> struct int_exact<8> { using type = int64_t; };



  template <> struct int_least<16> { using type = __int128; }; template <> struct int_exact<16> { using type = __int128; };





  template <typename ...Types>
  using int_fit_t = int_least_t<(sizeof(Types) + ...)>;


  template <typename ...Types>
  using uint_fit_t = uint_least_t<(sizeof(Types) + ...)>;


  template <size_t BYTES>
  struct float_least {
    using type = typename float_least<Math::ceilToPowerOf2(BYTES)>::type;
  };

  template <size_t BYTES>
  struct float_exact {};


  template <size_t BYTES>
  using float_least_t = typename float_least<BYTES>::type;


  template <size_t BYTES>
  using float_exact_t = typename float_exact<BYTES>::type;
# 106 "include/Simpleton/SDL/../Utils/int least.hpp"
  template <> struct float_least<sizeof(float)> { using type = float; }; template <> struct float_exact<sizeof(float)> { using type = float; };

  template <> struct float_least<sizeof(double)> { using type = double; }; template <> struct float_exact<sizeof(double)> { using type = double; };


  template <> struct float_least<sizeof(long double)> { using type = long double; }; template <> struct float_exact<sizeof(long double)> { using type = long double; };



}
# 14 "include/Simpleton/SDL/../Utils/bool enable.hpp" 2




namespace Utils {

  template <typename T>
  inline std::enable_if_t<std::is_integral<T>::value, T>
  boolEnable(const bool status, const T value) {
    return -static_cast<T>(status) & value;
  }


  template <typename T>
  inline std::enable_if_t<std::is_enum<T>::value, T>
  boolEnable(const bool status, const T value) {
    using Int = std::underlying_type_t<T>;
    return static_cast<T>(-static_cast<Int>(status) & static_cast<Int>(value));
  }


  template <typename T>
  inline std::enable_if_t<std::is_floating_point<T>::value, T>
  boolEnable(const bool status, const T value) {
    using Int = uint_fit_t<T>;
    union {
      T f;
      Int i;
    } val;
    val.f = value;
    val.i &= -static_cast<Int>(status);
    return val.f;
  }


  template <typename T>
  inline std::enable_if_t<std::is_pointer<T>::value, T>
  boolEnable(const bool status, const T value) {
    union {
      T p;
      uintptr_t i;
    } val;
    val.p = value;
    val.i &= -static_cast<uintptr_t>(status);
    return val.p;
  }
}
# 10 "include/Simpleton/SDL/library.inl" 2

inline void SDL::detail::deleteLibrary(const bool initialized) {
  if (initialized) {
    SDL_Quit();
  }
}

inline SDL::Library SDL::makeLibrary(const Uint32 flags) {
  ((SDL_Init(flags)) != 0 ? throw SDL::Error() : void());
  return SDL::Library(true);
}

inline SDL::Window SDL::makeWindow(const Window::Desc &desc) {
  return Window(SDL::detail::checkSDLNull(SDL_CreateWindow( desc.title.c_str(), (0x2FFF0000u|(0)), (0x2FFF0000u|(0)), desc.size.x, desc.size.y, SDL_WINDOW_SHOWN | Utils::boolEnable(desc.resizable, SDL_WINDOW_RESIZABLE) | Utils::boolEnable(desc.openGL, SDL_WINDOW_OPENGL) )));







}

inline SDL::Window SDL::makeWindow(const char *title, const int w, const int h) {
  return Window(SDL::detail::checkSDLNull(SDL_CreateWindow( title, (0x2FFF0000u|(0)), (0x2FFF0000u|(0)), w, h, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE | SDL_WINDOW_OPENGL )));





}

inline SDL::Renderer SDL::makeRenderer(Window &window, const bool vsync) {
  return Renderer(SDL::detail::checkSDLNull(SDL_CreateRenderer( window.get(), -1, SDL_RENDERER_ACCELERATED | Utils::boolEnable(vsync, SDL_RENDERER_PRESENTVSYNC) )));





}
# 40 "include/Simpleton/SDL/library.hpp" 2
# 13 "src/main.cpp" 2

int main() {
  SDL::Library lib = SDL::makeLibrary(0x00000020u);
  try {
    runGame();
  } catch (std::exception &e) {
    std::cout << e.what() << '\n';
   return 1;
  }
  return 0;
}
